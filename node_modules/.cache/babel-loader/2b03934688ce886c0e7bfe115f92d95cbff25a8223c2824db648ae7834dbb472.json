{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.APEv2Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst token_types_1 = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst APEv2Token_1 = require(\"./APEv2Token\");\nconst debug = (0, debug_1.default)('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.ape = {};\n  }\n  static tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n  }\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n  static calculateDuration(ah) {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n  /**\n   * Calculates the APEv1 / APEv2 first field offset\n   * @param reader\n   * @param offset\n   */\n  static async findApeFooterOffset(reader, offset) {\n    // Search for APE footer header at the end of the file\n    const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n    await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n    const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n    if (tagFooter.ID === 'APETAGEX') {\n      debug(\"APE footer header at offset=\".concat(offset));\n      return {\n        footer: tagFooter,\n        offset: offset - tagFooter.size\n      };\n    }\n  }\n  static parseTagFooter(metadata, buffer, options) {\n    const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n    if (footer.ID !== preamble) throw new Error('Unexpected APEv2 Footer ID preamble value.');\n    strtok3.fromBuffer(buffer);\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n    return apeParser.parseTags(footer);\n  }\n  /**\n   * Parse APEv1 / APEv2 header if header signature found\n   */\n  async tryParseApeHeader() {\n    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n      debug(\"No APEv2 header found, end-of-file reached\");\n      return;\n    }\n    const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n    if (footer.ID === preamble) {\n      await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n      return this.parseTags(footer);\n    } else {\n      debug(\"APEv2 header not found at offset=\".concat(this.tokenizer.position));\n      if (this.tokenizer.fileInfo.size) {\n        // Try to read the APEv2 header using just the footer-header\n        const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n        const buffer = Buffer.alloc(remaining);\n        await this.tokenizer.readBuffer(buffer);\n        return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n      }\n    }\n  }\n  async parse() {\n    const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n    if (descriptor.ID !== 'MAC ') throw new Error('Unexpected descriptor ID');\n    this.ape.descriptor = descriptor;\n    const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n    const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n    await this.tokenizer.ignore(header.forwardBytes);\n    return this.tryParseApeHeader();\n  }\n  async parseTags(footer) {\n    const keyBuffer = Buffer.alloc(256); // maximum tag key length\n    let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n    debug(\"Parse APE tags at offset=\".concat(this.tokenizer.position, \", size=\").concat(bytesRemaining));\n    for (let i = 0; i < footer.fields; i++) {\n      if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n        this.metadata.addWarning(\"APEv2 Tag-header: \".concat(footer.fields - i, \" items remaining, but no more tag data to read.\"));\n        break;\n      }\n      // Only APEv2 tag has tag item headers\n      const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n      bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n      await this.tokenizer.peekBuffer(keyBuffer, {\n        length: Math.min(keyBuffer.length, bytesRemaining)\n      });\n      let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n      const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n      await this.tokenizer.ignore(1);\n      bytesRemaining -= key.length + 1;\n      switch (tagItemHeader.flags.dataType) {\n        case APEv2Token_1.DataType.text_utf8:\n          {\n            // utf-8 text-string\n            const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n            const values = value.split(/\\x00/g);\n            for (const val of values) {\n              this.metadata.addTag(tagFormat, key, val);\n            }\n            break;\n          }\n        case APEv2Token_1.DataType.binary:\n          // binary (probably artwork)\n          if (this.options.skipCovers) {\n            await this.tokenizer.ignore(tagItemHeader.size);\n          } else {\n            const picData = Buffer.alloc(tagItemHeader.size);\n            await this.tokenizer.readBuffer(picData);\n            zero = util.findZero(picData, 0, picData.length);\n            const description = picData.toString('utf8', 0, zero);\n            const data = Buffer.from(picData.slice(zero + 1));\n            this.metadata.addTag(tagFormat, key, {\n              description,\n              data\n            });\n          }\n          break;\n        case APEv2Token_1.DataType.external_info:\n          debug(\"Ignore external info \".concat(key));\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n        case APEv2Token_1.DataType.reserved:\n          debug(\"Ignore external info \".concat(key));\n          this.metadata.addWarning(\"APEv2 header declares a reserved datatype for \\\"\".concat(key, \"\\\"\"));\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n      }\n    }\n  }\n  async parseDescriptorExpansion(lenExp) {\n    await this.tokenizer.ignore(lenExp);\n    return this.parseHeader();\n  }\n  async parseHeader() {\n    const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n    // ToDo before\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('container', 'Monkey\\'s Audio');\n    this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n    this.metadata.setFormat('sampleRate', header.sampleRate);\n    this.metadata.setFormat('numberOfChannels', header.channel);\n    this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n    return {\n      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n    };\n  }\n}\nexports.APEv2Parser = APEv2Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","APEv2Parser","debug_1","require","strtok3","token_types_1","util","BasicParser_1","APEv2Token_1","debug","default","tagFormat","preamble","BasicParser","constructor","arguments","ape","tryParseApeHeader","metadata","tokenizer","options","apeParser","init","calculateDuration","ah","duration","totalFrames","blocksPerFrame","finalFrameBlocks","sampleRate","findApeFooterOffset","reader","offset","apeBuf","Buffer","alloc","TagFooter","len","randomRead","tagFooter","get","ID","concat","footer","size","parseTagFooter","buffer","length","Error","fromBuffer","parseTags","fileInfo","position","peekToken","ignore","remaining","readBuffer","parse","descriptor","readToken","DescriptorParser","lenExp","descriptorBytes","header","parseDescriptorExpansion","parseHeader","forwardBytes","keyBuffer","bytesRemaining","i","fields","TagItemHeader","addWarning","tagItemHeader","peekBuffer","Math","min","zero","findZero","key","StringType","flags","dataType","DataType","text_utf8","values","split","val","addTag","binary","skipCovers","picData","description","toString","data","from","slice","external_info","reserved","Header","setFormat","bitsPerSample","channel","seekTableBytes","headerDataBytes","apeFrameDataBytes","terminatingDataBytes"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/node_modules/music-metadata/lib/apev2/APEv2Parser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APEv2Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst token_types_1 = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst APEv2Token_1 = require(\"./APEv2Token\");\nconst debug = (0, debug_1.default)('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    static tryParseApeHeader(metadata, tokenizer, options) {\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, tokenizer, options);\n        return apeParser.tryParseApeHeader();\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param reader\n     * @param offset\n     */\n    static async findApeFooterOffset(reader, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n        if (tagFooter.ID === 'APETAGEX') {\n            debug(`APE footer header at offset=${offset}`);\n            return { footer: tagFooter, offset: offset - tagFooter.size };\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n        if (footer.ID !== preamble)\n            throw new Error('Unexpected APEv2 Footer ID preamble value.');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n            debug(`No APEv2 header found, end-of-file reached`);\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n            return this.parseTags(footer);\n        }\n        else {\n            debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n            if (this.tokenizer.fileInfo.size) {\n                // Try to read the APEv2 header using just the footer-header\n                const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n                const buffer = Buffer.alloc(remaining);\n                await this.tokenizer.readBuffer(buffer);\n                return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n            }\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n        if (descriptor.ID !== 'MAC ')\n            throw new Error('Unexpected descriptor ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = Buffer.alloc(256); // maximum tag key length\n        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n            bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case APEv2Token_1.DataType.text_utf8: { // utf-8 text-string\n                    const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    for (const val of values) {\n                        this.metadata.addTag(tagFormat, key, val);\n                    }\n                    break;\n                }\n                case APEv2Token_1.DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = Buffer.alloc(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = util.findZero(picData, 0, picData.length);\n                        const description = picData.toString('utf8', 0, zero);\n                        const data = Buffer.from(picData.slice(zero + 1));\n                        this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case APEv2Token_1.DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                case APEv2Token_1.DataType.reserved:\n                    debug(`Ignore external info ${key}`);\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\nexports.APEv2Parser = APEv2Parser;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAChC,MAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAME,aAAa,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC5C,MAAMG,IAAI,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACtC,MAAMI,aAAa,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AACtD,MAAMK,YAAY,GAAGL,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAMM,KAAK,GAAG,CAAC,CAAC,EAAEP,OAAO,CAACQ,OAAO,EAAE,6BAA6B,CAAC;AACjE,MAAMC,SAAS,GAAG,OAAO;AACzB,MAAMC,QAAQ,GAAG,UAAU;AAC3B,MAAMX,WAAW,SAASM,aAAa,CAACM,WAAW,CAAC;EAChDC,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC;EACjB;EACA,OAAOC,iBAAiBA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAE;IACnD,MAAMC,SAAS,GAAG,IAAIpB,WAAW,CAAC,CAAC;IACnCoB,SAAS,CAACC,IAAI,CAACJ,QAAQ,EAAEC,SAAS,EAAEC,OAAO,CAAC;IAC5C,OAAOC,SAAS,CAACJ,iBAAiB,CAAC,CAAC;EACxC;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOM,iBAAiBA,CAACC,EAAE,EAAE;IACzB,IAAIC,QAAQ,GAAGD,EAAE,CAACE,WAAW,GAAG,CAAC,GAAGF,EAAE,CAACG,cAAc,IAAIH,EAAE,CAACE,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC;IAChFD,QAAQ,IAAID,EAAE,CAACI,gBAAgB;IAC/B,OAAOH,QAAQ,GAAGD,EAAE,CAACK,UAAU;EACnC;EACA;AACJ;AACA;AACA;AACA;EACI,aAAaC,mBAAmBA,CAACC,MAAM,EAAEC,MAAM,EAAE;IAC7C;IACA,MAAMC,MAAM,GAAGC,MAAM,CAACC,KAAK,CAAC3B,YAAY,CAAC4B,SAAS,CAACC,GAAG,CAAC;IACvD,MAAMN,MAAM,CAACO,UAAU,CAACL,MAAM,EAAE,CAAC,EAAEzB,YAAY,CAAC4B,SAAS,CAACC,GAAG,EAAEL,MAAM,GAAGxB,YAAY,CAAC4B,SAAS,CAACC,GAAG,CAAC;IACnG,MAAME,SAAS,GAAG/B,YAAY,CAAC4B,SAAS,CAACI,GAAG,CAACP,MAAM,EAAE,CAAC,CAAC;IACvD,IAAIM,SAAS,CAACE,EAAE,KAAK,UAAU,EAAE;MAC7BhC,KAAK,gCAAAiC,MAAA,CAAgCV,MAAM,CAAE,CAAC;MAC9C,OAAO;QAAEW,MAAM,EAAEJ,SAAS;QAAEP,MAAM,EAAEA,MAAM,GAAGO,SAAS,CAACK;MAAK,CAAC;IACjE;EACJ;EACA,OAAOC,cAAcA,CAAC3B,QAAQ,EAAE4B,MAAM,EAAE1B,OAAO,EAAE;IAC7C,MAAMuB,MAAM,GAAGnC,YAAY,CAAC4B,SAAS,CAACI,GAAG,CAACM,MAAM,EAAEA,MAAM,CAACC,MAAM,GAAGvC,YAAY,CAAC4B,SAAS,CAACC,GAAG,CAAC;IAC7F,IAAIM,MAAM,CAACF,EAAE,KAAK7B,QAAQ,EACtB,MAAM,IAAIoC,KAAK,CAAC,4CAA4C,CAAC;IACjE5C,OAAO,CAAC6C,UAAU,CAACH,MAAM,CAAC;IAC1B,MAAMzB,SAAS,GAAG,IAAIpB,WAAW,CAAC,CAAC;IACnCoB,SAAS,CAACC,IAAI,CAACJ,QAAQ,EAAEd,OAAO,CAAC6C,UAAU,CAACH,MAAM,CAAC,EAAE1B,OAAO,CAAC;IAC7D,OAAOC,SAAS,CAAC6B,SAAS,CAACP,MAAM,CAAC;EACtC;EACA;AACJ;AACA;EACI,MAAM1B,iBAAiBA,CAAA,EAAG;IACtB,IAAI,IAAI,CAACE,SAAS,CAACgC,QAAQ,CAACP,IAAI,IAAI,IAAI,CAACzB,SAAS,CAACgC,QAAQ,CAACP,IAAI,GAAG,IAAI,CAACzB,SAAS,CAACiC,QAAQ,GAAG5C,YAAY,CAAC4B,SAAS,CAACC,GAAG,EAAE;MACrH5B,KAAK,6CAA6C,CAAC;MACnD;IACJ;IACA,MAAMkC,MAAM,GAAG,MAAM,IAAI,CAACxB,SAAS,CAACkC,SAAS,CAAC7C,YAAY,CAAC4B,SAAS,CAAC;IACrE,IAAIO,MAAM,CAACF,EAAE,KAAK7B,QAAQ,EAAE;MACxB,MAAM,IAAI,CAACO,SAAS,CAACmC,MAAM,CAAC9C,YAAY,CAAC4B,SAAS,CAACC,GAAG,CAAC;MACvD,OAAO,IAAI,CAACa,SAAS,CAACP,MAAM,CAAC;IACjC,CAAC,MACI;MACDlC,KAAK,qCAAAiC,MAAA,CAAqC,IAAI,CAACvB,SAAS,CAACiC,QAAQ,CAAE,CAAC;MACpE,IAAI,IAAI,CAACjC,SAAS,CAACgC,QAAQ,CAACP,IAAI,EAAE;QAC9B;QACA,MAAMW,SAAS,GAAG,IAAI,CAACpC,SAAS,CAACgC,QAAQ,CAACP,IAAI,GAAG,IAAI,CAACzB,SAAS,CAACiC,QAAQ,CAAC,CAAC;QAC1E,MAAMN,MAAM,GAAGZ,MAAM,CAACC,KAAK,CAACoB,SAAS,CAAC;QACtC,MAAM,IAAI,CAACpC,SAAS,CAACqC,UAAU,CAACV,MAAM,CAAC;QACvC,OAAO7C,WAAW,CAAC4C,cAAc,CAAC,IAAI,CAAC3B,QAAQ,EAAE4B,MAAM,EAAE,IAAI,CAAC1B,OAAO,CAAC;MAC1E;IACJ;EACJ;EACA,MAAMqC,KAAKA,CAAA,EAAG;IACV,MAAMC,UAAU,GAAG,MAAM,IAAI,CAACvC,SAAS,CAACwC,SAAS,CAACnD,YAAY,CAACoD,gBAAgB,CAAC;IAChF,IAAIF,UAAU,CAACjB,EAAE,KAAK,MAAM,EACxB,MAAM,IAAIO,KAAK,CAAC,0BAA0B,CAAC;IAC/C,IAAI,CAAChC,GAAG,CAAC0C,UAAU,GAAGA,UAAU;IAChC,MAAMG,MAAM,GAAGH,UAAU,CAACI,eAAe,GAAGtD,YAAY,CAACoD,gBAAgB,CAACvB,GAAG;IAC7E,MAAM0B,MAAM,GAAG,OAAOF,MAAM,GAAG,CAAC,GAAG,IAAI,CAACG,wBAAwB,CAACH,MAAM,CAAC,GAAG,IAAI,CAACI,WAAW,CAAC,CAAC,CAAC;IAC9F,MAAM,IAAI,CAAC9C,SAAS,CAACmC,MAAM,CAACS,MAAM,CAACG,YAAY,CAAC;IAChD,OAAO,IAAI,CAACjD,iBAAiB,CAAC,CAAC;EACnC;EACA,MAAMiC,SAASA,CAACP,MAAM,EAAE;IACpB,MAAMwB,SAAS,GAAGjC,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IACrC,IAAIiC,cAAc,GAAGzB,MAAM,CAACC,IAAI,GAAGpC,YAAY,CAAC4B,SAAS,CAACC,GAAG;IAC7D5B,KAAK,6BAAAiC,MAAA,CAA6B,IAAI,CAACvB,SAAS,CAACiC,QAAQ,aAAAV,MAAA,CAAU0B,cAAc,CAAE,CAAC;IACpF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1B,MAAM,CAAC2B,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,IAAID,cAAc,GAAG5D,YAAY,CAAC+D,aAAa,CAAClC,GAAG,EAAE;QACjD,IAAI,CAACnB,QAAQ,CAACsD,UAAU,sBAAA9B,MAAA,CAAsBC,MAAM,CAAC2B,MAAM,GAAGD,CAAC,oDAAiD,CAAC;QACjH;MACJ;MACA;MACA,MAAMI,aAAa,GAAG,MAAM,IAAI,CAACtD,SAAS,CAACwC,SAAS,CAACnD,YAAY,CAAC+D,aAAa,CAAC;MAChFH,cAAc,IAAI5D,YAAY,CAAC+D,aAAa,CAAClC,GAAG,GAAGoC,aAAa,CAAC7B,IAAI;MACrE,MAAM,IAAI,CAACzB,SAAS,CAACuD,UAAU,CAACP,SAAS,EAAE;QAAEpB,MAAM,EAAE4B,IAAI,CAACC,GAAG,CAACT,SAAS,CAACpB,MAAM,EAAEqB,cAAc;MAAE,CAAC,CAAC;MAClG,IAAIS,IAAI,GAAGvE,IAAI,CAACwE,QAAQ,CAACX,SAAS,EAAE,CAAC,EAAEA,SAAS,CAACpB,MAAM,CAAC;MACxD,MAAMgC,GAAG,GAAG,MAAM,IAAI,CAAC5D,SAAS,CAACwC,SAAS,CAAC,IAAItD,aAAa,CAAC2E,UAAU,CAACH,IAAI,EAAE,OAAO,CAAC,CAAC;MACvF,MAAM,IAAI,CAAC1D,SAAS,CAACmC,MAAM,CAAC,CAAC,CAAC;MAC9Bc,cAAc,IAAIW,GAAG,CAAChC,MAAM,GAAG,CAAC;MAChC,QAAQ0B,aAAa,CAACQ,KAAK,CAACC,QAAQ;QAChC,KAAK1E,YAAY,CAAC2E,QAAQ,CAACC,SAAS;UAAE;YAAE;YACpC,MAAMpF,KAAK,GAAG,MAAM,IAAI,CAACmB,SAAS,CAACwC,SAAS,CAAC,IAAItD,aAAa,CAAC2E,UAAU,CAACP,aAAa,CAAC7B,IAAI,EAAE,MAAM,CAAC,CAAC;YACtG,MAAMyC,MAAM,GAAGrF,KAAK,CAACsF,KAAK,CAAC,OAAO,CAAC;YACnC,KAAK,MAAMC,GAAG,IAAIF,MAAM,EAAE;cACtB,IAAI,CAACnE,QAAQ,CAACsE,MAAM,CAAC7E,SAAS,EAAEoE,GAAG,EAAEQ,GAAG,CAAC;YAC7C;YACA;UACJ;QACA,KAAK/E,YAAY,CAAC2E,QAAQ,CAACM,MAAM;UAAE;UAC/B,IAAI,IAAI,CAACrE,OAAO,CAACsE,UAAU,EAAE;YACzB,MAAM,IAAI,CAACvE,SAAS,CAACmC,MAAM,CAACmB,aAAa,CAAC7B,IAAI,CAAC;UACnD,CAAC,MACI;YACD,MAAM+C,OAAO,GAAGzD,MAAM,CAACC,KAAK,CAACsC,aAAa,CAAC7B,IAAI,CAAC;YAChD,MAAM,IAAI,CAACzB,SAAS,CAACqC,UAAU,CAACmC,OAAO,CAAC;YACxCd,IAAI,GAAGvE,IAAI,CAACwE,QAAQ,CAACa,OAAO,EAAE,CAAC,EAAEA,OAAO,CAAC5C,MAAM,CAAC;YAChD,MAAM6C,WAAW,GAAGD,OAAO,CAACE,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAEhB,IAAI,CAAC;YACrD,MAAMiB,IAAI,GAAG5D,MAAM,CAAC6D,IAAI,CAACJ,OAAO,CAACK,KAAK,CAACnB,IAAI,GAAG,CAAC,CAAC,CAAC;YACjD,IAAI,CAAC3D,QAAQ,CAACsE,MAAM,CAAC7E,SAAS,EAAEoE,GAAG,EAAE;cACjCa,WAAW;cACXE;YACJ,CAAC,CAAC;UACN;UACA;QACJ,KAAKtF,YAAY,CAAC2E,QAAQ,CAACc,aAAa;UACpCxF,KAAK,yBAAAiC,MAAA,CAAyBqC,GAAG,CAAE,CAAC;UACpC,MAAM,IAAI,CAAC5D,SAAS,CAACmC,MAAM,CAACmB,aAAa,CAAC7B,IAAI,CAAC;UAC/C;QACJ,KAAKpC,YAAY,CAAC2E,QAAQ,CAACe,QAAQ;UAC/BzF,KAAK,yBAAAiC,MAAA,CAAyBqC,GAAG,CAAE,CAAC;UACpC,IAAI,CAAC7D,QAAQ,CAACsD,UAAU,oDAAA9B,MAAA,CAAmDqC,GAAG,OAAG,CAAC;UAClF,MAAM,IAAI,CAAC5D,SAAS,CAACmC,MAAM,CAACmB,aAAa,CAAC7B,IAAI,CAAC;UAC/C;MACR;IACJ;EACJ;EACA,MAAMoB,wBAAwBA,CAACH,MAAM,EAAE;IACnC,MAAM,IAAI,CAAC1C,SAAS,CAACmC,MAAM,CAACO,MAAM,CAAC;IACnC,OAAO,IAAI,CAACI,WAAW,CAAC,CAAC;EAC7B;EACA,MAAMA,WAAWA,CAAA,EAAG;IAChB,MAAMF,MAAM,GAAG,MAAM,IAAI,CAAC5C,SAAS,CAACwC,SAAS,CAACnD,YAAY,CAAC2F,MAAM,CAAC;IAClE;IACA,IAAI,CAACjF,QAAQ,CAACkF,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC;IACzC,IAAI,CAAClF,QAAQ,CAACkF,SAAS,CAAC,WAAW,EAAE,iBAAiB,CAAC;IACvD,IAAI,CAAClF,QAAQ,CAACkF,SAAS,CAAC,eAAe,EAAErC,MAAM,CAACsC,aAAa,CAAC;IAC9D,IAAI,CAACnF,QAAQ,CAACkF,SAAS,CAAC,YAAY,EAAErC,MAAM,CAAClC,UAAU,CAAC;IACxD,IAAI,CAACX,QAAQ,CAACkF,SAAS,CAAC,kBAAkB,EAAErC,MAAM,CAACuC,OAAO,CAAC;IAC3D,IAAI,CAACpF,QAAQ,CAACkF,SAAS,CAAC,UAAU,EAAEnG,WAAW,CAACsB,iBAAiB,CAACwC,MAAM,CAAC,CAAC;IAC1E,OAAO;MACHG,YAAY,EAAE,IAAI,CAAClD,GAAG,CAAC0C,UAAU,CAAC6C,cAAc,GAAG,IAAI,CAACvF,GAAG,CAAC0C,UAAU,CAAC8C,eAAe,GAClF,IAAI,CAACxF,GAAG,CAAC0C,UAAU,CAAC+C,iBAAiB,GAAG,IAAI,CAACzF,GAAG,CAAC0C,UAAU,CAACgD;IACpE,CAAC;EACL;AACJ;AACA3G,OAAO,CAACE,WAAW,GAAGA,WAAW","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}