{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OggParser = exports.SegmentTable = void 0;\nconst Token = require(\"token-types\");\nconst core_1 = require(\"strtok3/lib/core\");\nconst debug_1 = require(\"debug\");\nconst util = require(\"../common/Util\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst VorbisParser_1 = require(\"./vorbis/VorbisParser\");\nconst OpusParser_1 = require(\"./opus/OpusParser\");\nconst SpeexParser_1 = require(\"./speex/SpeexParser\");\nconst TheoraParser_1 = require(\"./theora/TheoraParser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg');\nclass SegmentTable {\n  static sum(buf, off, len) {\n    let s = 0;\n    for (let i = off; i < off + len; ++i) {\n      s += buf[i];\n    }\n    return s;\n  }\n  constructor(header) {\n    this.len = header.page_segments;\n  }\n  get(buf, off) {\n    return {\n      totalPageSize: SegmentTable.sum(buf, off, this.len)\n    };\n  }\n}\nexports.SegmentTable = SegmentTable;\n/**\n * Parser for Ogg logical bitstream framing\n */\nclass OggParser extends BasicParser_1.BasicParser {\n  /**\n   * Parse page\n   * @returns {Promise<void>}\n   */\n  async parse() {\n    debug('pos=%s, parsePage()', this.tokenizer.position);\n    try {\n      let header;\n      do {\n        header = await this.tokenizer.readToken(OggParser.Header);\n        if (header.capturePattern !== 'OggS') throw new Error('Invalid Ogg capture pattern');\n        this.metadata.setFormat('container', 'Ogg');\n        this.header = header;\n        this.pageNumber = header.pageSequenceNo;\n        debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);\n        const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));\n        debug('totalPageSize=%s', segmentTable.totalPageSize);\n        const pageData = await this.tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n        debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n        if (header.headerType.firstPage) {\n          const id = new Token.StringType(7, 'ascii').get(Buffer.from(pageData), 0);\n          switch (id) {\n            case '\\x01vorbis':\n              // Ogg/Vorbis\n              debug('Set page consumer to Ogg/Vorbis');\n              this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);\n              break;\n            case 'OpusHea':\n              // Ogg/Opus\n              debug('Set page consumer to Ogg/Opus');\n              this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);\n              break;\n            case 'Speex  ':\n              // Ogg/Speex\n              debug('Set page consumer to Ogg/Speex');\n              this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);\n              break;\n            case 'fishead':\n            case '\\x00theora':\n              // Ogg/Theora\n              debug('Set page consumer to Ogg/Theora');\n              this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);\n              break;\n            default:\n              throw new Error('gg audio-codec not recognized (id=' + id + ')');\n          }\n        }\n        this.pageConsumer.parsePage(header, pageData);\n      } while (!header.headerType.lastPage);\n    } catch (err) {\n      if (err instanceof core_1.EndOfStreamError) {\n        this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n        debug(`End-of-stream`);\n        this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n        if (this.header) {\n          this.pageConsumer.calculateDuration(this.header);\n        }\n      } else if (err.message.startsWith('FourCC')) {\n        if (this.pageNumber > 0) {\n          // ignore this error: work-around if last OGG-page is not marked with last-page flag\n          this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');\n          this.pageConsumer.flush();\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n}\nOggParser.Header = {\n  len: 27,\n  get: (buf, off) => {\n    return {\n      capturePattern: FourCC_1.FourCcToken.get(buf, off),\n      version: Token.UINT8.get(buf, off + 4),\n      headerType: {\n        continued: util.getBit(buf, off + 5, 0),\n        firstPage: util.getBit(buf, off + 5, 1),\n        lastPage: util.getBit(buf, off + 5, 2)\n      },\n      // packet_flag: buf.readUInt8(off + 5),\n      absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\n      streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n      pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n      pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n      page_segments: Token.UINT8.get(buf, off + 26)\n    };\n  }\n};\nexports.OggParser = OggParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}