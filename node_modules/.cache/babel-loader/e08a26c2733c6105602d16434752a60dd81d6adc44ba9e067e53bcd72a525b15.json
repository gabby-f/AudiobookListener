{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { _generateLinkResponse, _noResolveJsonResponse, _request, _userResponse } from './lib/fetch';\nimport { resolveFetch, validateUUID } from './lib/helpers';\nimport { SIGN_OUT_SCOPES } from './lib/types';\nimport { isAuthError } from './lib/errors';\nexport default class GoTrueAdminApi {\n  /**\n   * Creates an admin API client that can be used to manage users and OAuth clients.\n   *\n   * @example\n   * ```ts\n   * import { GoTrueAdminApi } from '@supabase/auth-js'\n   *\n   * const admin = new GoTrueAdminApi({\n   *   url: 'https://xyzcompany.supabase.co/auth/v1',\n   *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },\n   * })\n   * ```\n   */\n  constructor({\n    url = '',\n    headers = {},\n    fetch\n  }) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch(fetch);\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this)\n    };\n    this.oauth = {\n      listClients: this._listOAuthClients.bind(this),\n      createClient: this._createOAuthClient.bind(this),\n      getClient: this._getOAuthClient.bind(this),\n      updateClient: this._updateOAuthClient.bind(this),\n      deleteClient: this._deleteOAuthClient.bind(this),\n      regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)\n    };\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   * @param scope The logout sope.\n   */\n  async signOut(jwt, scope = SIGN_OUT_SCOPES[0]) {\n    if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n      throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(', ')}`);\n    }\n    try {\n      await _request(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {\n        headers: this.headers,\n        jwt,\n        noResolveJson: true\n      });\n      return {\n        data: null,\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param options Additional options to be included when inviting.\n   */\n  async inviteUserByEmail(email, options = {}) {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\n        body: {\n          email,\n          data: options.data\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Generates email links and OTPs to be sent via a custom email provider.\n   * @param email The user's email.\n   * @param options.password User password. For signup only.\n   * @param options.data Optional user metadata. For signup only.\n   * @param options.redirectTo The redirect url which should be appended to the generated link\n   */\n  async generateLink(params) {\n    try {\n      const {\n          options\n        } = params,\n        rest = __rest(params, [\"options\"]);\n      const body = Object.assign(Object.assign({}, rest), options);\n      if ('newEmail' in rest) {\n        // replace newEmail with new_email in request body\n        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n        delete body['newEmail'];\n      }\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n        body: body,\n        headers: this.headers,\n        xform: _generateLinkResponse,\n        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            properties: null,\n            user: null\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  // User Admin API\n  /**\n   * Creates a new user.\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async createUser(attributes) {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n   */\n  async listUsers(params) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    try {\n      const pagination = {\n        nextPage: null,\n        lastPage: 0,\n        total: 0\n      };\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\n        headers: this.headers,\n        noResolveJson: true,\n        query: {\n          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',\n          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''\n        },\n        xform: _noResolveJsonResponse\n      });\n      if (response.error) throw response.error;\n      const users = await response.json();\n      const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;\n      const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];\n      if (links.length > 0) {\n        links.forEach(link => {\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));\n          const rel = JSON.parse(link.split(';')[1].split('=')[1]);\n          pagination[`${rel}Page`] = page;\n        });\n        pagination.total = parseInt(total);\n      }\n      return {\n        data: Object.assign(Object.assign({}, users), pagination),\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            users: []\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(uid) {\n    validateUUID(uid);\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(uid, attributes) {\n    validateUUID(uid);\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * @param id The user id you want to remove.\n   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n   * Defaults to false for backward compatibility.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async deleteUser(id, shouldSoftDelete = false) {\n    validateUUID(id);\n    try {\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n        headers: this.headers,\n        body: {\n          should_soft_delete: shouldSoftDelete\n        },\n        xform: _userResponse\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            user: null\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  async _listFactors(params) {\n    validateUUID(params.userId);\n    try {\n      const {\n        data,\n        error\n      } = await _request(this.fetch, 'GET', `${this.url}/admin/users/${params.userId}/factors`, {\n        headers: this.headers,\n        xform: factors => {\n          return {\n            data: {\n              factors\n            },\n            error: null\n          };\n        }\n      });\n      return {\n        data,\n        error\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  async _deleteFactor(params) {\n    validateUUID(params.userId);\n    validateUUID(params.id);\n    try {\n      const data = await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n        headers: this.headers\n      });\n      return {\n        data,\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Lists all OAuth clients with optional pagination.\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async _listOAuthClients(params) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    try {\n      const pagination = {\n        nextPage: null,\n        lastPage: 0,\n        total: 0\n      };\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/oauth/clients`, {\n        headers: this.headers,\n        noResolveJson: true,\n        query: {\n          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',\n          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''\n        },\n        xform: _noResolveJsonResponse\n      });\n      if (response.error) throw response.error;\n      const clients = await response.json();\n      const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;\n      const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];\n      if (links.length > 0) {\n        links.forEach(link => {\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));\n          const rel = JSON.parse(link.split(';')[1].split('=')[1]);\n          pagination[`${rel}Page`] = page;\n        });\n        pagination.total = parseInt(total);\n      }\n      return {\n        data: Object.assign(Object.assign({}, clients), pagination),\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            clients: []\n          },\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Creates a new OAuth client.\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async _createOAuthClient(params) {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/oauth/clients`, {\n        body: params,\n        headers: this.headers,\n        xform: client => {\n          return {\n            data: client,\n            error: null\n          };\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Gets details of a specific OAuth client.\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async _getOAuthClient(clientId) {\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/oauth/clients/${clientId}`, {\n        headers: this.headers,\n        xform: client => {\n          return {\n            data: client,\n            error: null\n          };\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Updates an existing OAuth client.\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async _updateOAuthClient(clientId, params) {\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/oauth/clients/${clientId}`, {\n        body: params,\n        headers: this.headers,\n        xform: client => {\n          return {\n            data: client,\n            error: null\n          };\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Deletes an OAuth client.\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async _deleteOAuthClient(clientId) {\n    try {\n      await _request(this.fetch, 'DELETE', `${this.url}/admin/oauth/clients/${clientId}`, {\n        headers: this.headers,\n        noResolveJson: true\n      });\n      return {\n        data: null,\n        error: null\n      };\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n  /**\n   * Regenerates the secret for an OAuth client.\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async _regenerateOAuthClientSecret(clientId) {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {\n        headers: this.headers,\n        xform: client => {\n          return {\n            data: client,\n            error: null\n          };\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      throw error;\n    }\n  }\n}\n//# sourceMappingURL=GoTrueAdminApi.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}