{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n\n    // Find the moov atom which contains chapter information\n    const moovOffset = findAtom(view, 'moov', 0);\n    if (moovOffset === -1) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n    console.log('Found moov atom at offset:', moovOffset);\n\n    // Method 1: Try to find userdata with chapter list (like VLC does)\n    const udatOffset = findAtom(view, 'udat', moovOffset);\n    if (udatOffset !== -1) {\n      console.log('Found udat atom at offset:', udatOffset);\n      const chplOffset = findAtom(view, 'chpl', udatOffset);\n      if (chplOffset !== -1) {\n        console.log('Found chpl atom in udat');\n        const chapters = parseChplAtom(view, chplOffset);\n        if (chapters.length > 0) return chapters;\n      }\n    }\n\n    // Method 2: Try to find chpl directly in moov\n    const chplInMoov = findAtom(view, 'chpl', moovOffset);\n    if (chplInMoov !== -1) {\n      console.log('Found chpl atom directly in moov');\n      const chapters = parseChplAtom(view, chplInMoov);\n      if (chapters.length > 0) return chapters;\n    }\n\n    // Method 3: Look for chapter track references (VLC method)\n    const chapters = parseChapterTrack(view, moovOffset);\n    if (chapters.length > 0) return chapters;\n\n    // Method 4: Try to find chapters in the general moov structure\n    return parseChaptersFromMoov(view, moovOffset);\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\nfunction findAtom(view, atomName, startOffset = 0) {\n  const atomCode = stringToByteArray(atomName);\n  const searchLimit = Math.min(view.byteLength, startOffset + 100000000); // Limit search to first 100MB\n\n  for (let i = startOffset; i < searchLimit - 3; i++) {\n    let found = true;\n    for (let j = 0; j < 4; j++) {\n      if (view.getUint8(i + 4 + j) !== atomCode[j]) {\n        found = false;\n        break;\n      }\n    }\n    if (found) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction stringToByteArray(str) {\n  const bytes = [];\n  for (let i = 0; i < str.length; i++) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nfunction parseChplAtom(view, offset) {\n  try {\n    // chpl atom structure:\n    // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\n    if (offset + 12 >= view.byteLength) return [];\n    const entryCount = view.getUint8(offset + 12);\n    const chapters = [];\n    let currentOffset = offset + 13;\n    for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\n      // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\n      if (currentOffset + 5 > view.byteLength) break;\n      const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\n      const titleLength = view.getUint8(currentOffset + 4);\n      currentOffset += 5;\n      if (currentOffset + titleLength > view.byteLength) break;\n      const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\n      const title = new TextDecoder().decode(titleBytes);\n      currentOffset += titleLength;\n      chapters.push({\n        title: title || `Chapter ${i + 1}`,\n        startTime: startTime,\n        duration: null\n      });\n    }\n    if (chapters.length > 0) {\n      console.log(`Extracted ${chapters.length} chapters from chpl atom`);\n    }\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\nfunction parseChaptersFromMoov(view, moovOffset) {\n  // This is a fallback parser that looks through the moov structure\n  // for chapter information in various formats\n  const chapters = [];\n  try {\n    // Get moov size to know search bounds\n    if (moovOffset < 4) return [];\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n\n    // Search for chapter markers within moov\n    for (let i = moovOffset; i < moovEnd - 100; i++) {\n      // Look for common chapter patterns\n      if (view.getUint32(i, false) === 0x6368706c ||\n      // 'chpl' in reverse endian\n      view.getUint32(i, false) === 0x6c706863) {\n        // 'lphc' \n        const chapterData = parseChplAtom(view, i);\n        if (chapterData.length > 0) {\n          return chapterData;\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing moov for chapters:', error);\n  }\n  return chapters;\n}\n\n// Parse chapter track (similar to VLC's method for chapter tracks)\nfunction parseChapterTrack(view, moovOffset) {\n  const chapters = [];\n  try {\n    // Look for trak atoms within moov\n    let searchOffset = moovOffset;\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n    while (searchOffset < moovEnd) {\n      const trakOffset = findAtom(view, 'trak', searchOffset);\n      if (trakOffset === -1 || trakOffset >= moovEnd) break;\n\n      // Check if this is a chapter track by looking for tref\n      const trefOffset = findAtom(view, 'tref', trakOffset);\n      if (trefOffset !== -1) {\n        const chapterEntries = parseChapterEntries(view, trakOffset);\n        if (chapterEntries.length > 0) {\n          return chapterEntries;\n        }\n      }\n      searchOffset = trakOffset + 100; // Move forward to find next trak\n    }\n  } catch (error) {\n    console.error('Error parsing chapter track:', error);\n  }\n  return chapters;\n}\nfunction parseChapterEntries(view, trakOffset) {\n  const chapters = [];\n  try {\n    // Look for stbl (sample table) which contains chapter info\n    const stblOffset = findAtom(view, 'stbl', trakOffset);\n    if (stblOffset === -1) return [];\n\n    // Look for stts (time-to-sample) and stsd (sample description)\n    const sttsOffset = findAtom(view, 'stts', stblOffset);\n    const stsdOffset = findAtom(view, 'stsd', stblOffset);\n    if (sttsOffset !== -1 && stsdOffset !== -1) {\n      // Parse sample times from stts\n      const sampleCount = view.getUint32(sttsOffset + 12, false);\n      let currentTime = 0;\n      for (let i = 0; i < Math.min(sampleCount, 100); i++) {\n        const entryOffset = sttsOffset + 16 + i * 8;\n        if (entryOffset + 8 > view.byteLength) break;\n        const sampleCount = view.getUint32(entryOffset, false);\n        const sampleDelta = view.getUint32(entryOffset + 4, false);\n        chapters.push({\n          title: `Chapter ${i + 1}`,\n          startTime: currentTime / 1000,\n          // Convert to seconds\n          duration: null\n        });\n        currentTime += sampleCount * sampleDelta;\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing chapter entries:', error);\n  }\n  return chapters;\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","moovOffset","findAtom","console","log","udatOffset","chplOffset","chapters","parseChplAtom","length","chplInMoov","parseChapterTrack","parseChaptersFromMoov","error","atomName","startOffset","atomCode","stringToByteArray","searchLimit","Math","min","byteLength","i","found","j","getUint8","str","bytes","push","charCodeAt","offset","entryCount","currentOffset","startTime","getUint32","titleLength","titleBytes","Uint8Array","title","TextDecoder","decode","duration","moovSize","moovEnd","chapterData","searchOffset","trakOffset","trefOffset","chapterEntries","parseChapterEntries","stblOffset","sttsOffset","stsdOffset","sampleCount","currentTime","entryOffset","sampleDelta","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        // Find the moov atom which contains chapter information\r\n        const moovOffset = findAtom(view, 'moov', 0);\r\n        if (moovOffset === -1) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        console.log('Found moov atom at offset:', moovOffset);\r\n        \r\n        // Method 1: Try to find userdata with chapter list (like VLC does)\r\n        const udatOffset = findAtom(view, 'udat', moovOffset);\r\n        if (udatOffset !== -1) {\r\n            console.log('Found udat atom at offset:', udatOffset);\r\n            const chplOffset = findAtom(view, 'chpl', udatOffset);\r\n            if (chplOffset !== -1) {\r\n                console.log('Found chpl atom in udat');\r\n                const chapters = parseChplAtom(view, chplOffset);\r\n                if (chapters.length > 0) return chapters;\r\n            }\r\n        }\r\n        \r\n        // Method 2: Try to find chpl directly in moov\r\n        const chplInMoov = findAtom(view, 'chpl', moovOffset);\r\n        if (chplInMoov !== -1) {\r\n            console.log('Found chpl atom directly in moov');\r\n            const chapters = parseChplAtom(view, chplInMoov);\r\n            if (chapters.length > 0) return chapters;\r\n        }\r\n        \r\n        // Method 3: Look for chapter track references (VLC method)\r\n        const chapters = parseChapterTrack(view, moovOffset);\r\n        if (chapters.length > 0) return chapters;\r\n        \r\n        // Method 4: Try to find chapters in the general moov structure\r\n        return parseChaptersFromMoov(view, moovOffset);\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    const atomCode = stringToByteArray(atomName);\r\n    const searchLimit = Math.min(view.byteLength, startOffset + 100000000); // Limit search to first 100MB\r\n    \r\n    for (let i = startOffset; i < searchLimit - 3; i++) {\r\n        let found = true;\r\n        for (let j = 0; j < 4; j++) {\r\n            if (view.getUint8(i + 4 + j) !== atomCode[j]) {\r\n                found = false;\r\n                break;\r\n            }\r\n        }\r\n        if (found) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction stringToByteArray(str) {\r\n    const bytes = [];\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes.push(str.charCodeAt(i));\r\n    }\r\n    return bytes;\r\n}\r\n\r\nfunction parseChplAtom(view, offset) {\r\n    try {\r\n        // chpl atom structure:\r\n        // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\r\n        if (offset + 12 >= view.byteLength) return [];\r\n        \r\n        const entryCount = view.getUint8(offset + 12);\r\n        \r\n        const chapters = [];\r\n        let currentOffset = offset + 13;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\r\n            // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\r\n            if (currentOffset + 5 > view.byteLength) break;\r\n            \r\n            const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\r\n            const titleLength = view.getUint8(currentOffset + 4);\r\n            currentOffset += 5;\r\n            \r\n            if (currentOffset + titleLength > view.byteLength) break;\r\n            \r\n            const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\r\n            const title = new TextDecoder().decode(titleBytes);\r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title || `Chapter ${i + 1}`,\r\n                startTime: startTime,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        if (chapters.length > 0) {\r\n            console.log(`Extracted ${chapters.length} chapters from chpl atom`);\r\n        }\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction parseChaptersFromMoov(view, moovOffset) {\r\n    // This is a fallback parser that looks through the moov structure\r\n    // for chapter information in various formats\r\n    const chapters = [];\r\n    \r\n    try {\r\n        // Get moov size to know search bounds\r\n        if (moovOffset < 4) return [];\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        // Search for chapter markers within moov\r\n        for (let i = moovOffset; i < moovEnd - 100; i++) {\r\n            // Look for common chapter patterns\r\n            if (view.getUint32(i, false) === 0x6368706c || // 'chpl' in reverse endian\r\n                view.getUint32(i, false) === 0x6c706863) {  // 'lphc' \r\n                const chapterData = parseChplAtom(view, i);\r\n                if (chapterData.length > 0) {\r\n                    return chapterData;\r\n                }\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing moov for chapters:', error);\r\n    }\r\n    \r\n    return chapters;\r\n}\r\n\r\n// Parse chapter track (similar to VLC's method for chapter tracks)\r\nfunction parseChapterTrack(view, moovOffset) {\r\n    const chapters = [];\r\n    try {\r\n        // Look for trak atoms within moov\r\n        let searchOffset = moovOffset;\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        while (searchOffset < moovEnd) {\r\n            const trakOffset = findAtom(view, 'trak', searchOffset);\r\n            if (trakOffset === -1 || trakOffset >= moovEnd) break;\r\n            \r\n            // Check if this is a chapter track by looking for tref\r\n            const trefOffset = findAtom(view, 'tref', trakOffset);\r\n            if (trefOffset !== -1) {\r\n                const chapterEntries = parseChapterEntries(view, trakOffset);\r\n                if (chapterEntries.length > 0) {\r\n                    return chapterEntries;\r\n                }\r\n            }\r\n            \r\n            searchOffset = trakOffset + 100; // Move forward to find next trak\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter track:', error);\r\n    }\r\n    return chapters;\r\n}\r\n\r\nfunction parseChapterEntries(view, trakOffset) {\r\n    const chapters = [];\r\n    try {\r\n        // Look for stbl (sample table) which contains chapter info\r\n        const stblOffset = findAtom(view, 'stbl', trakOffset);\r\n        if (stblOffset === -1) return [];\r\n        \r\n        // Look for stts (time-to-sample) and stsd (sample description)\r\n        const sttsOffset = findAtom(view, 'stts', stblOffset);\r\n        const stsdOffset = findAtom(view, 'stsd', stblOffset);\r\n        \r\n        if (sttsOffset !== -1 && stsdOffset !== -1) {\r\n            // Parse sample times from stts\r\n            const sampleCount = view.getUint32(sttsOffset + 12, false);\r\n            let currentTime = 0;\r\n            \r\n            for (let i = 0; i < Math.min(sampleCount, 100); i++) {\r\n                const entryOffset = sttsOffset + 16 + (i * 8);\r\n                if (entryOffset + 8 > view.byteLength) break;\r\n                \r\n                const sampleCount = view.getUint32(entryOffset, false);\r\n                const sampleDelta = view.getUint32(entryOffset + 4, false);\r\n                \r\n                chapters.push({\r\n                    title: `Chapter ${i + 1}`,\r\n                    startTime: currentTime / 1000, // Convert to seconds\r\n                    duration: null\r\n                });\r\n                \r\n                currentTime += sampleCount * sampleDelta;\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter entries:', error);\r\n    }\r\n    return chapters;\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}