{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gabby\\\\Documents\\\\Audiobook Listener\\\\src\\\\pages\\\\Audiobook.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { parseBlob } from 'music-metadata-browser';\nimport { extractM4BChapters, extractM4BMetadata } from '../utils/m4bParser';\nimport FileUploader from '../Components/audiobook/FileUploader';\nimport AudiobookPlayer from '../Components/audiobook/AudiobookPlayer';\nimport Library from '../Components/audiobook/Library';\nimport { uploadAudioFile, saveLibraryEntry, getLibrary, updatePlaybackState, getPlaybackState } from '../utils/supabaseClient';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst STORAGE_KEY = 'audiobook_player_state';\nexport default function AudiobookPage() {\n  _s();\n  const [currentFileId, setCurrentFileId] = useState(null);\n  const [audioFile, setAudioFile] = useState(null);\n  const [chapters, setChapters] = useState([]);\n  const [bookInfo, setBookInfo] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [savedState, setSavedState] = useState(null);\n\n  // Use ref to always have access to the latest currentFileId without recreating callbacks\n  const currentFileIdRef = useRef(null);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    currentFileIdRef.current = currentFileId;\n  }, [currentFileId]);\n\n  // Load saved state on mount\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY);\n    if (saved) {\n      try {\n        const state = JSON.parse(saved);\n        setSavedState(state);\n      } catch (error) {\n        console.error('Error loading saved state:', error);\n      }\n    }\n  }, []);\n  const parseM4BChapters = useCallback(async file => {\n    try {\n      const extractedChapters = [];\n      const info = {\n        title: null,\n        artist: null,\n        album: null,\n        cover: null,\n        duration: 0\n      };\n\n      // Extract metadata directly from MP4 atoms (like VLC)\n      console.log('Extracting metadata from M4B file using binary parser...');\n      const binaryMetadata = await extractM4BMetadata(file);\n      if (binaryMetadata) {\n        info.title = binaryMetadata.title;\n        info.artist = binaryMetadata.artist || binaryMetadata.albumArtist;\n        info.album = binaryMetadata.album;\n        info.cover = binaryMetadata.cover;\n        info.duration = binaryMetadata.duration;\n        console.log('Binary metadata extracted:', {\n          title: info.title,\n          artist: info.artist,\n          hasCover: !!info.cover,\n          duration: info.duration\n        });\n      }\n\n      // Extract chapters using binary parsing (like VLC)\n      console.log('Extracting chapters from M4B file...');\n      const binaryChapters = await extractM4BChapters(file);\n      if (binaryChapters.length > 0) {\n        console.log(`Successfully extracted ${binaryChapters.length} chapters from binary parsing`);\n        extractedChapters.push(...binaryChapters);\n      }\n\n      // Fallback to music-metadata-browser if binary parsing didn't get everything\n      let metadata;\n      try {\n        // Only use music-metadata if we're missing critical info\n        if (!info.title || !info.duration) {\n          metadata = await parseBlob(file, {\n            duration: true,\n            skipCovers: false,\n            native: false // Skip native parsing to avoid Buffer issues\n          });\n\n          // Fill in missing metadata from music-metadata\n          if (!info.title) {\n            info.title = metadata.common.title || file.name.replace(/\\.[^/.]+$/, '');\n          }\n          if (!info.artist) {\n            info.artist = metadata.common.artist || metadata.common.albumartist || null;\n          }\n          if (!info.album) {\n            info.album = metadata.common.album || null;\n          }\n          if (!info.duration || info.duration === 0) {\n            info.duration = metadata.format.duration || 0;\n          }\n\n          // Extract cover art from music-metadata if binary parser didn't find it\n          if (!info.cover && metadata.common.picture && metadata.common.picture.length > 0) {\n            const picture = metadata.common.picture[0];\n            const blob = new Blob([picture.data], {\n              type: picture.format\n            });\n            const coverUrl = URL.createObjectURL(blob);\n            console.log('Extracted cover art from music-metadata');\n            info.cover = coverUrl;\n          }\n        }\n      } catch (metadataError) {\n        console.warn('Music-metadata fallback failed (non-critical):', metadataError.message);\n        // Use binary metadata or filename as fallback\n        if (!info.title) {\n          info.title = file.name.replace(/\\.[^/.]+$/, '');\n        }\n      }\n\n      // Calculate chapter durations if chapters were found\n      if (extractedChapters.length > 0) {\n        extractedChapters.sort((a, b) => a.startTime - b.startTime);\n        extractedChapters.forEach((chapter, index) => {\n          const nextChapter = extractedChapters[index + 1];\n          chapter.duration = nextChapter ? nextChapter.startTime - chapter.startTime : info.duration - chapter.startTime;\n        });\n        console.log(`Successfully extracted ${extractedChapters.length} chapters`);\n      } else if (info.duration > 0) {\n        // Fallback: create time-based chapters\n        const chapterDuration = 600; // 10 minute segments\n        const numChapters = Math.ceil(info.duration / chapterDuration);\n        for (let i = 0; i < numChapters; i++) {\n          const startTime = i * chapterDuration;\n          extractedChapters.push({\n            title: `Part ${i + 1}`,\n            startTime: startTime,\n            duration: Math.min(chapterDuration, info.duration - startTime)\n          });\n        }\n        console.log(`No chapters found. Created ${extractedChapters.length} time-based segments`);\n      }\n      return {\n        chapters: extractedChapters,\n        info\n      };\n    } catch (error) {\n      console.error('Error parsing M4B file:', error);\n      return {\n        chapters: [],\n        info: {\n          title: file.name.replace(/\\.[^/.]+$/, ''),\n          artist: null,\n          album: null,\n          cover: null,\n          duration: 0\n        }\n      };\n    }\n  }, []);\n  const handleFileSelect = useCallback(async file => {\n    setIsLoading(true);\n    try {\n      const {\n        chapters: extractedChapters,\n        info\n      } = await parseM4BChapters(file);\n      setChapters(extractedChapters);\n      setBookInfo(info);\n      setAudioFile(file);\n\n      // Save file to library with metadata including chapters\n      try {\n        const fileId = await saveFile(file, {\n          title: info.title || file.name.replace(/\\.[^/.]+$/, ''),\n          artist: info.artist || 'Unknown Artist',\n          cover: info.cover || null,\n          duration: info.duration || 0,\n          chapters: extractedChapters || []\n        });\n        setCurrentFileId(fileId);\n        currentFileIdRef.current = fileId;\n      } catch (idbErr) {\n        console.warn('Failed to save file to library:', idbErr);\n      }\n    } catch (error) {\n      console.error('Error parsing audiobook:', error);\n      setAudioFile(file);\n      setChapters([]);\n      setBookInfo({\n        title: file.name.replace(/\\.[^/.]+$/, '')\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [parseM4BChapters]);\n  const handleClose = useCallback(() => {\n    setAudioFile(null);\n    setChapters([]);\n    setBookInfo(null);\n    setCurrentFileId(null);\n    setSavedState(null);\n    // Clear saved state\n    try {\n      localStorage.removeItem(STORAGE_KEY);\n    } catch (err) {\n      // ignore\n    }\n  }, []);\n  const handleLibrarySelect = useCallback(async (fileId, libraryEntry) => {\n    setIsLoading(true);\n    try {\n      // Load file from IndexedDB\n      const file = await getFile(fileId);\n      if (!file) {\n        throw new Error('File not found in storage');\n      }\n      console.log('Loading book from library:', libraryEntry.title, 'playback position:', libraryEntry.playbackPosition);\n\n      // Use stored chapters if available, otherwise parse\n      let chapters = libraryEntry.chapters || [];\n      if (chapters.length === 0) {\n        console.log('No stored chapters, parsing file...');\n        const {\n          chapters: extractedChapters\n        } = await parseM4BChapters(file);\n        chapters = extractedChapters;\n      }\n      setChapters(chapters);\n      setBookInfo({\n        title: libraryEntry.title || 'Unknown',\n        artist: libraryEntry.artist || 'Unknown Artist',\n        cover: libraryEntry.cover || null\n      });\n\n      // Force audio remount by creating new file object\n      // This ensures clean state when switching between library items\n      const newFile = new File([file], file.name, {\n        type: file.type\n      });\n      setAudioFile(newFile);\n      setCurrentFileId(fileId);\n      currentFileIdRef.current = fileId;\n\n      // Load saved playback position (ensure it's a valid number)\n      const playbackPosition = typeof libraryEntry.playbackPosition === 'number' ? libraryEntry.playbackPosition : 0;\n      console.log('Setting saved state with playbackPosition:', playbackPosition);\n      setSavedState({\n        playbackPosition: playbackPosition,\n        currentChapterIndex: 0,\n        volume: libraryEntry.volume !== undefined ? libraryEntry.volume : 1,\n        speed: libraryEntry.speed !== undefined ? libraryEntry.speed : 1\n      });\n    } catch (error) {\n      console.error('Error loading file from library:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [parseM4BChapters]);\n  const handleSaveState = useCallback(async state => {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n\n    // Also update library entry with playback position using ref to avoid stale closures\n    const fileId = currentFileIdRef.current;\n    if (fileId) {\n      try {\n        console.log('Saving playback state:', state.playbackPosition, 'for file:', fileId);\n        await updateLibraryEntry(fileId, {\n          playbackPosition: state.playbackPosition || 0,\n          volume: state.volume !== undefined ? state.volume : 1,\n          speed: state.speed !== undefined ? state.speed : 1,\n          lastPlayed: new Date().toISOString()\n        });\n      } catch (err) {\n        console.warn('Failed to update playback state in library:', err);\n      }\n    }\n  }, []); // Empty dependency array - callback is stable, uses ref for currentFileId\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\",\n    children: !audioFile ? /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(FileUploader, {\n        onFileSelect: handleFileSelect,\n        isLoading: isLoading\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 297,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"px-6 py-8\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          className: \"text-2xl font-bold text-white mb-6\",\n          children: \"Your Library\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 302,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(Library, {\n          onSelectFile: handleLibrarySelect,\n          onLoadingChange: setIsLoading\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 303,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 301,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"h-screen\",\n      children: /*#__PURE__*/_jsxDEV(AudiobookPlayer, {\n        file: audioFile,\n        chapters: chapters,\n        bookInfo: bookInfo,\n        onClose: handleClose,\n        savedState: savedState,\n        onSaveState: handleSaveState\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 311,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 310,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 294,\n    columnNumber: 9\n  }, this);\n}\n_s(AudiobookPage, \"/6L72I517ughzfsAYMO70D0OMOY=\");\n_c = AudiobookPage;\nvar _c;\n$RefreshReg$(_c, \"AudiobookPage\");","map":{"version":3,"names":["React","useState","useCallback","useEffect","useRef","parseBlob","extractM4BChapters","extractM4BMetadata","FileUploader","AudiobookPlayer","Library","uploadAudioFile","saveLibraryEntry","getLibrary","updatePlaybackState","getPlaybackState","jsxDEV","_jsxDEV","Fragment","_Fragment","STORAGE_KEY","AudiobookPage","_s","currentFileId","setCurrentFileId","audioFile","setAudioFile","chapters","setChapters","bookInfo","setBookInfo","isLoading","setIsLoading","savedState","setSavedState","currentFileIdRef","current","saved","localStorage","getItem","state","JSON","parse","error","console","parseM4BChapters","file","extractedChapters","info","title","artist","album","cover","duration","log","binaryMetadata","albumArtist","hasCover","binaryChapters","length","push","metadata","skipCovers","native","common","name","replace","albumartist","format","picture","blob","Blob","data","type","coverUrl","URL","createObjectURL","metadataError","warn","message","sort","a","b","startTime","forEach","chapter","index","nextChapter","chapterDuration","numChapters","Math","ceil","i","min","handleFileSelect","fileId","saveFile","idbErr","handleClose","removeItem","err","handleLibrarySelect","libraryEntry","getFile","Error","playbackPosition","newFile","File","currentChapterIndex","volume","undefined","speed","handleSaveState","setItem","stringify","updateLibraryEntry","lastPlayed","Date","toISOString","className","children","onFileSelect","fileName","_jsxFileName","lineNumber","columnNumber","onSelectFile","onLoadingChange","onClose","onSaveState","_c","$RefreshReg$"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/pages/Audiobook.jsx"],"sourcesContent":["import React, { useState, useCallback, useEffect, useRef } from 'react';\r\nimport { parseBlob } from 'music-metadata-browser';\r\nimport { extractM4BChapters, extractM4BMetadata } from '../utils/m4bParser';\r\nimport FileUploader from '../Components/audiobook/FileUploader';\r\nimport AudiobookPlayer from '../Components/audiobook/AudiobookPlayer';\r\nimport Library from '../Components/audiobook/Library';\r\nimport { \r\n  uploadAudioFile, \r\n  saveLibraryEntry, \r\n  getLibrary,\r\n  updatePlaybackState,\r\n  getPlaybackState\r\n} from '../utils/supabaseClient';\r\n\r\nconst STORAGE_KEY = 'audiobook_player_state';\r\n\r\nexport default function AudiobookPage() {\r\n    const [currentFileId, setCurrentFileId] = useState(null);\r\n    const [audioFile, setAudioFile] = useState(null);\r\n    const [chapters, setChapters] = useState([]);\r\n    const [bookInfo, setBookInfo] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [savedState, setSavedState] = useState(null);\r\n    \r\n    // Use ref to always have access to the latest currentFileId without recreating callbacks\r\n    const currentFileIdRef = useRef(null);\r\n    \r\n    // Keep ref in sync with state\r\n    useEffect(() => {\r\n        currentFileIdRef.current = currentFileId;\r\n    }, [currentFileId]);\r\n\r\n    // Load saved state on mount\r\n    useEffect(() => {\r\n        const saved = localStorage.getItem(STORAGE_KEY);\r\n        if (saved) {\r\n            try {\r\n                const state = JSON.parse(saved);\r\n                setSavedState(state);\r\n            } catch (error) {\r\n                console.error('Error loading saved state:', error);\r\n            }\r\n        }\r\n    }, []);\r\n    \r\n    const parseM4BChapters = useCallback(async (file) => {\r\n        try {\r\n            const extractedChapters = [];\r\n            const info = {\r\n                title: null,\r\n                artist: null,\r\n                album: null,\r\n                cover: null,\r\n                duration: 0\r\n            };\r\n            \r\n            // Extract metadata directly from MP4 atoms (like VLC)\r\n            console.log('Extracting metadata from M4B file using binary parser...');\r\n            const binaryMetadata = await extractM4BMetadata(file);\r\n            \r\n            if (binaryMetadata) {\r\n                info.title = binaryMetadata.title;\r\n                info.artist = binaryMetadata.artist || binaryMetadata.albumArtist;\r\n                info.album = binaryMetadata.album;\r\n                info.cover = binaryMetadata.cover;\r\n                info.duration = binaryMetadata.duration;\r\n                \r\n                console.log('Binary metadata extracted:', {\r\n                    title: info.title,\r\n                    artist: info.artist,\r\n                    hasCover: !!info.cover,\r\n                    duration: info.duration\r\n                });\r\n            }\r\n            \r\n            // Extract chapters using binary parsing (like VLC)\r\n            console.log('Extracting chapters from M4B file...');\r\n            const binaryChapters = await extractM4BChapters(file);\r\n            \r\n            if (binaryChapters.length > 0) {\r\n                console.log(`Successfully extracted ${binaryChapters.length} chapters from binary parsing`);\r\n                extractedChapters.push(...binaryChapters);\r\n            }\r\n            \r\n            // Fallback to music-metadata-browser if binary parsing didn't get everything\r\n            let metadata;\r\n            try {\r\n                // Only use music-metadata if we're missing critical info\r\n                if (!info.title || !info.duration) {\r\n                    metadata = await parseBlob(file, { \r\n                        duration: true,\r\n                        skipCovers: false,\r\n                        native: false  // Skip native parsing to avoid Buffer issues\r\n                    });\r\n                    \r\n                    // Fill in missing metadata from music-metadata\r\n                    if (!info.title) {\r\n                        info.title = metadata.common.title || file.name.replace(/\\.[^/.]+$/, '');\r\n                    }\r\n                    if (!info.artist) {\r\n                        info.artist = metadata.common.artist || metadata.common.albumartist || null;\r\n                    }\r\n                    if (!info.album) {\r\n                        info.album = metadata.common.album || null;\r\n                    }\r\n                    if (!info.duration || info.duration === 0) {\r\n                        info.duration = metadata.format.duration || 0;\r\n                    }\r\n                    \r\n                    // Extract cover art from music-metadata if binary parser didn't find it\r\n                    if (!info.cover && metadata.common.picture && metadata.common.picture.length > 0) {\r\n                        const picture = metadata.common.picture[0];\r\n                        const blob = new Blob([picture.data], { type: picture.format });\r\n                        const coverUrl = URL.createObjectURL(blob);\r\n                        console.log('Extracted cover art from music-metadata');\r\n                        info.cover = coverUrl;\r\n                    }\r\n                }\r\n                \r\n            } catch (metadataError) {\r\n                console.warn('Music-metadata fallback failed (non-critical):', metadataError.message);\r\n                // Use binary metadata or filename as fallback\r\n                if (!info.title) {\r\n                    info.title = file.name.replace(/\\.[^/.]+$/, '');\r\n                }\r\n            }\r\n            \r\n            // Calculate chapter durations if chapters were found\r\n            if (extractedChapters.length > 0) {\r\n                extractedChapters.sort((a, b) => a.startTime - b.startTime);\r\n                \r\n                extractedChapters.forEach((chapter, index) => {\r\n                    const nextChapter = extractedChapters[index + 1];\r\n                    chapter.duration = nextChapter \r\n                        ? nextChapter.startTime - chapter.startTime\r\n                        : info.duration - chapter.startTime;\r\n                });\r\n                \r\n                console.log(`Successfully extracted ${extractedChapters.length} chapters`);\r\n            } else if (info.duration > 0) {\r\n                // Fallback: create time-based chapters\r\n                const chapterDuration = 600; // 10 minute segments\r\n                const numChapters = Math.ceil(info.duration / chapterDuration);\r\n                \r\n                for (let i = 0; i < numChapters; i++) {\r\n                    const startTime = i * chapterDuration;\r\n                    extractedChapters.push({\r\n                        title: `Part ${i + 1}`,\r\n                        startTime: startTime,\r\n                        duration: Math.min(chapterDuration, info.duration - startTime)\r\n                    });\r\n                }\r\n                \r\n                console.log(`No chapters found. Created ${extractedChapters.length} time-based segments`);\r\n            }\r\n            \r\n            return { chapters: extractedChapters, info };\r\n            \r\n        } catch (error) {\r\n            console.error('Error parsing M4B file:', error);\r\n            return { \r\n                chapters: [], \r\n                info: { \r\n                    title: file.name.replace(/\\.[^/.]+$/, ''), \r\n                    artist: null, \r\n                    album: null,\r\n                    cover: null,\r\n                    duration: 0\r\n                } \r\n            };\r\n        }\r\n    }, []);\r\n\r\n    const handleFileSelect = useCallback(async (file) => {\r\n        setIsLoading(true);\r\n        \r\n        try {\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo(info);\r\n            setAudioFile(file);\r\n            \r\n            // Save file to library with metadata including chapters\r\n            try {\r\n                const fileId = await saveFile(file, {\r\n                    title: info.title || file.name.replace(/\\.[^/.]+$/, ''),\r\n                    artist: info.artist || 'Unknown Artist',\r\n                    cover: info.cover || null,\r\n                    duration: info.duration || 0,\r\n                    chapters: extractedChapters || [],\r\n                });\r\n                setCurrentFileId(fileId);\r\n                currentFileIdRef.current = fileId;\r\n            } catch (idbErr) {\r\n                console.warn('Failed to save file to library:', idbErr);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error parsing audiobook:', error);\r\n            setAudioFile(file);\r\n            setChapters([]);\r\n            setBookInfo({ title: file.name.replace(/\\.[^/.]+$/, '') });\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleClose = useCallback(() => {\r\n        setAudioFile(null);\r\n        setChapters([]);\r\n        setBookInfo(null);\r\n        setCurrentFileId(null);\r\n        setSavedState(null);\r\n        // Clear saved state\r\n        try {\r\n            localStorage.removeItem(STORAGE_KEY);\r\n        } catch (err) {\r\n            // ignore\r\n        }\r\n    }, []);\r\n\r\n    const handleLibrarySelect = useCallback(async (fileId, libraryEntry) => {\r\n        setIsLoading(true);\r\n        try {\r\n            // Load file from IndexedDB\r\n            const file = await getFile(fileId);\r\n            if (!file) {\r\n                throw new Error('File not found in storage');\r\n            }\r\n\r\n            console.log('Loading book from library:', libraryEntry.title, 'playback position:', libraryEntry.playbackPosition);\r\n\r\n            // Use stored chapters if available, otherwise parse\r\n            let chapters = libraryEntry.chapters || [];\r\n            if (chapters.length === 0) {\r\n                console.log('No stored chapters, parsing file...');\r\n                const { chapters: extractedChapters } = await parseM4BChapters(file);\r\n                chapters = extractedChapters;\r\n            }\r\n            \r\n            setChapters(chapters);\r\n            setBookInfo({\r\n                title: libraryEntry.title || 'Unknown',\r\n                artist: libraryEntry.artist || 'Unknown Artist',\r\n                cover: libraryEntry.cover || null,\r\n            });\r\n            \r\n            // Force audio remount by creating new file object\r\n            // This ensures clean state when switching between library items\r\n            const newFile = new File([file], file.name, { type: file.type });\r\n            setAudioFile(newFile);\r\n            setCurrentFileId(fileId);\r\n            currentFileIdRef.current = fileId;\r\n\r\n            // Load saved playback position (ensure it's a valid number)\r\n            const playbackPosition = typeof libraryEntry.playbackPosition === 'number' \r\n                ? libraryEntry.playbackPosition \r\n                : 0;\r\n            \r\n            console.log('Setting saved state with playbackPosition:', playbackPosition);\r\n            setSavedState({\r\n                playbackPosition: playbackPosition,\r\n                currentChapterIndex: 0,\r\n                volume: libraryEntry.volume !== undefined ? libraryEntry.volume : 1,\r\n                speed: libraryEntry.speed !== undefined ? libraryEntry.speed : 1,\r\n            });\r\n        } catch (error) {\r\n            console.error('Error loading file from library:', error);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleSaveState = useCallback(async (state) => {\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\r\n        \r\n        // Also update library entry with playback position using ref to avoid stale closures\r\n        const fileId = currentFileIdRef.current;\r\n        if (fileId) {\r\n            try {\r\n                console.log('Saving playback state:', state.playbackPosition, 'for file:', fileId);\r\n                await updateLibraryEntry(fileId, {\r\n                    playbackPosition: state.playbackPosition || 0,\r\n                    volume: state.volume !== undefined ? state.volume : 1,\r\n                    speed: state.speed !== undefined ? state.speed : 1,\r\n                    lastPlayed: new Date().toISOString(),\r\n                });\r\n            } catch (err) {\r\n                console.warn('Failed to update playback state in library:', err);\r\n            }\r\n        }\r\n    }, []); // Empty dependency array - callback is stable, uses ref for currentFileId\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\">\r\n            {!audioFile ? (\r\n                <>\r\n                    <FileUploader \r\n                        onFileSelect={handleFileSelect} \r\n                        isLoading={isLoading}\r\n                    />\r\n                    <div className=\"px-6 py-8\">\r\n                        <h2 className=\"text-2xl font-bold text-white mb-6\">Your Library</h2>\r\n                        <Library \r\n                            onSelectFile={handleLibrarySelect}\r\n                            onLoadingChange={setIsLoading}\r\n                        />\r\n                    </div>\r\n                </>\r\n            ) : (\r\n                <div className=\"h-screen\">\r\n                    <AudiobookPlayer\r\n                        file={audioFile}\r\n                        chapters={chapters}\r\n                        bookInfo={bookInfo}\r\n                        onClose={handleClose}\r\n                        savedState={savedState}\r\n                        onSaveState={handleSaveState}\r\n                    />\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}