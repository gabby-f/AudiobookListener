{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = exports.a2hex = exports.isBitSet = exports.getBitAllignedNumber = exports.stripNulls = exports.decodeString = exports.trimRightNull = exports.findZero = exports.getBit = void 0;\nfunction getBit(buf, off, bit) {\n  return (buf[off] & 1 << bit) !== 0;\n}\nexports.getBit = getBit;\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nfunction findZero(uint8Array, start, end, encoding) {\n  let i = start;\n  if (encoding === 'utf16le') {\n    while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n      if (i >= end) return end;\n      i += 2;\n    }\n    return i;\n  } else {\n    while (uint8Array[i] !== 0) {\n      if (i >= end) return end;\n      i++;\n    }\n    return i;\n  }\n}\nexports.findZero = findZero;\nfunction trimRightNull(x) {\n  const pos0 = x.indexOf('\\0');\n  return pos0 === -1 ? x : x.substr(0, pos0);\n}\nexports.trimRightNull = trimRightNull;\nfunction swapBytes(uint8Array) {\n  const l = uint8Array.length;\n  if ((l & 1) !== 0) throw new Error('Buffer length must be even');\n  for (let i = 0; i < l; i += 2) {\n    const a = uint8Array[i];\n    uint8Array[i] = uint8Array[i + 1];\n    uint8Array[i + 1] = a;\n  }\n  return uint8Array;\n}\n/**\n * Decode string\n */\nfunction decodeString(uint8Array, encoding) {\n  // annoying workaround for a double BOM issue\n  // https://github.com/leetreveil/musicmetadata/issues/84\n  if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {\n    // little endian\n    return decodeString(uint8Array.subarray(2), encoding);\n  } else if (encoding === 'utf16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n    // BOM, indicating big endian decoding\n    if ((uint8Array.length & 1) !== 0) throw new Error('Expected even number of octets for 16-bit unicode string');\n    return decodeString(swapBytes(uint8Array), encoding);\n  }\n  return Buffer.from(uint8Array).toString(encoding);\n}\nexports.decodeString = decodeString;\nfunction stripNulls(str) {\n  str = str.replace(/^\\x00+/g, '');\n  str = str.replace(/\\x00+$/g, '');\n  return str;\n}\nexports.stripNulls = stripNulls;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nfunction getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n  const byteOff = byteOffset + ~~(bitOffset / 8);\n  const bitOff = bitOffset % 8;\n  let value = source[byteOff];\n  value &= 0xff >> bitOff;\n  const bitsRead = 8 - bitOff;\n  const bitsLeft = len - bitsRead;\n  if (bitsLeft < 0) {\n    value >>= 8 - bitOff - len;\n  } else if (bitsLeft > 0) {\n    value <<= bitsLeft;\n    value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n  }\n  return value;\n}\nexports.getBitAllignedNumber = getBitAllignedNumber;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nfunction isBitSet(source, byteOffset, bitOffset) {\n  return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexports.isBitSet = isBitSet;\nfunction a2hex(str) {\n  const arr = [];\n  for (let i = 0, l = str.length; i < l; i++) {\n    const hex = Number(str.charCodeAt(i)).toString(16);\n    arr.push(hex.length === 1 ? '0' + hex : hex);\n  }\n  return arr.join(' ');\n}\nexports.a2hex = a2hex;\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nfunction ratioToDb(ratio) {\n  return 10 * Math.log10(ratio);\n}\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\nfunction dbToRatio(dB) {\n  return Math.pow(10, dB / 10);\n}\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nfunction toRatio(value) {\n  const ps = value.split(' ').map(p => p.trim().toLowerCase());\n  // @ts-ignore\n  if (ps.length >= 1) {\n    const v = parseFloat(ps[0]);\n    return ps.length === 2 && ps[1] === 'db' ? {\n      dB: v,\n      ratio: dbToRatio(v)\n    } : {\n      dB: ratioToDb(v),\n      ratio: v\n    };\n  }\n}\nexports.toRatio = toRatio;\n//# sourceMappingURL=Util.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}