{"ast":null,"code":"'use strict';\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\nvar _asyncIterator = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar _awaitAsyncGenerator = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\nvar _wrapAsyncGenerator = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_ARGS,\n    ERR_OUT_OF_RANGE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateAbortSignal,\n  validateInteger,\n  validateObject\n} = require('../validators');\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak');\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation');\nconst {\n  finished\n} = require('./end-of-stream');\nconst staticCompose = require('./compose');\nconst {\n  addAbortSignalNoValidate\n} = require('./add-abort-signal');\nconst {\n  isWritable,\n  isNodeStream\n} = require('./utils');\nconst {\n  deprecate\n} = require('../../ours/util');\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials');\nconst kEmpty = Symbol('kEmpty');\nconst kEof = Symbol('kEof');\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable');\n  }\n  const composedStream = staticCompose(this, stream);\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream);\n  }\n  return composedStream;\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let concurrency = 1;\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency);\n  }\n  let highWaterMark = concurrency - 1;\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark);\n  }\n  validateInteger(concurrency, 'options.concurrency', 1);\n  validateInteger(highWaterMark, 'options.highWaterMark', 0);\n  highWaterMark += concurrency;\n  return function () {\n    var _map = _wrapAsyncGenerator(function* () {\n      const signal = require('../../ours/util').AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean));\n      const stream = this;\n      const queue = [];\n      const signalOpt = {\n        signal\n      };\n      let next;\n      let resume;\n      let done = false;\n      let cnt = 0;\n      function onCatch() {\n        done = true;\n        afterItemProcessed();\n      }\n      function afterItemProcessed() {\n        cnt -= 1;\n        maybeResume();\n      }\n      function maybeResume() {\n        if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n          resume();\n          resume = null;\n        }\n      }\n      async function pump() {\n        try {\n          var _iteratorAbruptCompletion = false;\n          var _didIteratorError = false;\n          var _iteratorError;\n          try {\n            for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n              let val = _step.value;\n              {\n                if (done) {\n                  return;\n                }\n                if (signal.aborted) {\n                  throw new AbortError();\n                }\n                try {\n                  val = fn(val, signalOpt);\n                  if (val === kEmpty) {\n                    continue;\n                  }\n                  val = PromiseResolve(val);\n                } catch (err) {\n                  val = PromiseReject(err);\n                }\n                cnt += 1;\n                PromisePrototypeThen(val, afterItemProcessed, onCatch);\n                queue.push(val);\n                if (next) {\n                  next();\n                  next = null;\n                }\n                if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n                  await new Promise(resolve => {\n                    resume = resolve;\n                  });\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion && _iterator.return != null) {\n                await _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          queue.push(kEof);\n        } catch (err) {\n          const val = PromiseReject(err);\n          PromisePrototypeThen(val, afterItemProcessed, onCatch);\n          queue.push(val);\n        } finally {\n          done = true;\n          if (next) {\n            next();\n            next = null;\n          }\n        }\n      }\n      pump();\n      try {\n        while (true) {\n          while (queue.length > 0) {\n            const val = yield _awaitAsyncGenerator(queue[0]);\n            if (val === kEof) {\n              return;\n            }\n            if (signal.aborted) {\n              throw new AbortError();\n            }\n            if (val !== kEmpty) {\n              yield val;\n            }\n            queue.shift();\n            maybeResume();\n          }\n          yield _awaitAsyncGenerator(new Promise(resolve => {\n            next = resolve;\n          }));\n        }\n      } finally {\n        done = true;\n        if (resume) {\n          resume();\n          resume = null;\n        }\n      }\n    });\n    function map() {\n      return _map.apply(this, arguments);\n    }\n    return map;\n  }().call(this);\n}\nfunction asIndexedPairs() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  return function () {\n    var _asIndexedPairs = _wrapAsyncGenerator(function* () {\n      let index = 0;\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n      var _iteratorError2;\n      try {\n        for (var _iterator2 = _asyncIterator(this), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n          const val = _step2.value;\n          {\n            var _options$signal;\n            if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {\n              throw new AbortError({\n                cause: options.signal.reason\n              });\n            }\n            yield [index++, val];\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n    function asIndexedPairs() {\n      return _asIndexedPairs.apply(this, arguments);\n    }\n    return asIndexedPairs;\n  }().call(this);\n}\nasync function some(fn) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var _iteratorAbruptCompletion3 = false;\n  var _didIteratorError3 = false;\n  var _iteratorError3;\n  try {\n    for (var _iterator3 = _asyncIterator(filter.call(this, fn, options)), _step3; _iteratorAbruptCompletion3 = !(_step3 = await _iterator3.next()).done; _iteratorAbruptCompletion3 = false) {\n      const unused = _step3.value;\n      {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n        await _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n  return false;\n}\nasync function every(fn) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(this, async function () {\n    return !(await fn(...arguments));\n  }, options));\n}\nasync function find(fn, options) {\n  var _iteratorAbruptCompletion4 = false;\n  var _didIteratorError4 = false;\n  var _iteratorError4;\n  try {\n    for (var _iterator4 = _asyncIterator(filter.call(this, fn, options)), _step4; _iteratorAbruptCompletion4 = !(_step4 = await _iterator4.next()).done; _iteratorAbruptCompletion4 = false) {\n      const result = _step4.value;\n      {\n        return result;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (_iteratorAbruptCompletion4 && _iterator4.return != null) {\n        await _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n  return undefined;\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options);\n    return kEmpty;\n  }\n  // eslint-disable-next-line no-unused-vars\n  var _iteratorAbruptCompletion5 = false;\n  var _didIteratorError5 = false;\n  var _iteratorError5;\n  try {\n    for (var _iterator5 = _asyncIterator(map.call(this, forEachFn, options)), _step5; _iteratorAbruptCompletion5 = !(_step5 = await _iterator5.next()).done; _iteratorAbruptCompletion5 = false) {\n      const unused = _step5.value;\n      {\n        ;\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (_iteratorAbruptCompletion5 && _iterator5.return != null) {\n        await _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value;\n    }\n    return kEmpty;\n  }\n  return map.call(this, filterFn, options);\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce');\n    this.message = 'Reduce of an empty stream requires an initial value';\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2;\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let hasInitialValue = arguments.length > 1;\n  if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    });\n    this.once('error', () => {}); // The error is already propagated\n    await finished(this.destroy(err));\n    throw err;\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    };\n    options.signal.addEventListener('abort', () => ac.abort(), opts);\n  }\n  let gotAnyItemFromStream = false;\n  try {\n    var _iteratorAbruptCompletion6 = false;\n    var _didIteratorError6 = false;\n    var _iteratorError6;\n    try {\n      for (var _iterator6 = _asyncIterator(this), _step6; _iteratorAbruptCompletion6 = !(_step6 = await _iterator6.next()).done; _iteratorAbruptCompletion6 = false) {\n        const value = _step6.value;\n        {\n          var _options$signal3;\n          gotAnyItemFromStream = true;\n          if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {\n            throw new AbortError();\n          }\n          if (!hasInitialValue) {\n            initialValue = value;\n            hasInitialValue = true;\n          } else {\n            initialValue = await reducer(initialValue, value, {\n              signal\n            });\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion6 && _iterator6.return != null) {\n          await _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs();\n    }\n  } finally {\n    ac.abort();\n  }\n  return initialValue;\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  const result = [];\n  var _iteratorAbruptCompletion7 = false;\n  var _didIteratorError7 = false;\n  var _iteratorError7;\n  try {\n    for (var _iterator7 = _asyncIterator(this), _step7; _iteratorAbruptCompletion7 = !(_step7 = await _iterator7.next()).done; _iteratorAbruptCompletion7 = false) {\n      const val = _step7.value;\n      {\n        var _options$signal4;\n        if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {\n          throw new AbortError(undefined, {\n            cause: options.signal.reason\n          });\n        }\n        ArrayPrototypePush(result, val);\n      }\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (_iteratorAbruptCompletion7 && _iterator7.return != null) {\n        await _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n  return result;\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options);\n  return function () {\n    var _flatMap = _wrapAsyncGenerator(function* () {\n      var _iteratorAbruptCompletion8 = false;\n      var _didIteratorError8 = false;\n      var _iteratorError8;\n      try {\n        for (var _iterator8 = _asyncIterator(values), _step8; _iteratorAbruptCompletion8 = !(_step8 = yield _awaitAsyncGenerator(_iterator8.next())).done; _iteratorAbruptCompletion8 = false) {\n          const val = _step8.value;\n          {\n            yield* _asyncGeneratorDelegate(_asyncIterator(val), _awaitAsyncGenerator);\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion8 && _iterator8.return != null) {\n            yield _awaitAsyncGenerator(_iterator8.return());\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    });\n    function flatMap() {\n      return _flatMap.apply(this, arguments);\n    }\n    return flatMap;\n  }().call(this);\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number);\n  if (NumberIsNaN(number)) {\n    return 0;\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number);\n  }\n  return number;\n}\nfunction drop(number) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return function () {\n    var _drop = _wrapAsyncGenerator(function* () {\n      var _options$signal5;\n      if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {\n        throw new AbortError();\n      }\n      var _iteratorAbruptCompletion9 = false;\n      var _didIteratorError9 = false;\n      var _iteratorError9;\n      try {\n        for (var _iterator9 = _asyncIterator(this), _step9; _iteratorAbruptCompletion9 = !(_step9 = yield _awaitAsyncGenerator(_iterator9.next())).done; _iteratorAbruptCompletion9 = false) {\n          const val = _step9.value;\n          {\n            var _options$signal6;\n            if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {\n              throw new AbortError();\n            }\n            if (number-- <= 0) {\n              yield val;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion9 && _iterator9.return != null) {\n            yield _awaitAsyncGenerator(_iterator9.return());\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    });\n    function drop() {\n      return _drop.apply(this, arguments);\n    }\n    return drop;\n  }().call(this);\n}\nfunction take(number) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return function () {\n    var _take = _wrapAsyncGenerator(function* () {\n      var _options$signal7;\n      if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {\n        throw new AbortError();\n      }\n      var _iteratorAbruptCompletion0 = false;\n      var _didIteratorError0 = false;\n      var _iteratorError0;\n      try {\n        for (var _iterator0 = _asyncIterator(this), _step0; _iteratorAbruptCompletion0 = !(_step0 = yield _awaitAsyncGenerator(_iterator0.next())).done; _iteratorAbruptCompletion0 = false) {\n          const val = _step0.value;\n          {\n            var _options$signal8;\n            if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {\n              throw new AbortError();\n            }\n            if (number-- > 0) {\n              yield val;\n            }\n\n            // Don't get another item from iterator in case we reached the end\n            if (number <= 0) {\n              return;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError0 = true;\n        _iteratorError0 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion0 && _iterator0.return != null) {\n            yield _awaitAsyncGenerator(_iterator0.return());\n          }\n        } finally {\n          if (_didIteratorError0) {\n            throw _iteratorError0;\n          }\n        }\n      }\n    });\n    function take() {\n      return _take.apply(this, arguments);\n    }\n    return take;\n  }().call(this);\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n};\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n};","map":{"version":3,"names":["_asyncGeneratorDelegate","require","default","_asyncIterator","_awaitAsyncGenerator","_wrapAsyncGenerator","AbortController","globalThis","codes","ERR_INVALID_ARG_VALUE","ERR_INVALID_ARG_TYPE","ERR_MISSING_ARGS","ERR_OUT_OF_RANGE","AbortError","validateAbortSignal","validateInteger","validateObject","kWeakHandler","Symbol","kResistStopPropagation","finished","staticCompose","addAbortSignalNoValidate","isWritable","isNodeStream","deprecate","ArrayPrototypePush","Boolean","MathFloor","Number","NumberIsNaN","Promise","PromiseReject","PromiseResolve","PromisePrototypeThen","kEmpty","kEof","compose","stream","options","undefined","signal","composedStream","map","fn","concurrency","highWaterMark","_map","AbortSignalAny","filter","queue","signalOpt","next","resume","done","cnt","onCatch","afterItemProcessed","maybeResume","length","pump","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","val","value","aborted","err","push","resolve","return","shift","apply","arguments","call","asIndexedPairs","_asIndexedPairs","index","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_options$signal","cause","reason","some","_iteratorAbruptCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","unused","every","find","_iteratorAbruptCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","result","forEach","forEachFn","_iteratorAbruptCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","filterFn","ReduceAwareErrMissingArgs","constructor","message","reduce","reducer","initialValue","_options$signal2","hasInitialValue","once","destroy","ac","opts","addEventListener","abort","gotAnyItemFromStream","_iteratorAbruptCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_options$signal3","toArray","_iteratorAbruptCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","_options$signal4","flatMap","values","_flatMap","_iteratorAbruptCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","toIntegerOrInfinity","number","drop","_drop","_options$signal5","_iteratorAbruptCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_options$signal6","take","_take","_options$signal7","_iteratorAbruptCompletion0","_didIteratorError0","_iteratorError0","_iterator0","_step0","_options$signal8","module","exports","streamReturningOperators","promiseReturningOperators"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/operators.js"],"sourcesContent":["'use strict'\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = require('../../ours/errors')\nconst { validateAbortSignal, validateInteger, validateObject } = require('../validators')\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak')\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation')\nconst { finished } = require('./end-of-stream')\nconst staticCompose = require('./compose')\nconst { addAbortSignalNoValidate } = require('./add-abort-signal')\nconst { isWritable, isNodeStream } = require('./utils')\nconst { deprecate } = require('../../ours/util')\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials')\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}