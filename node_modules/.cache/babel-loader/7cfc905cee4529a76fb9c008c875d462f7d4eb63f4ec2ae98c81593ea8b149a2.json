{"ast":null,"code":"var _wrapAsyncGenerator = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\nvar _awaitAsyncGenerator = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\nvar _asyncGeneratorDelegate = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\nvar _asyncIterator = require(\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n'use strict';\nconst {\n  ArrayIsArray,\n  Promise,\n  SymbolAsyncIterator,\n  SymbolDispose\n} = require('../../ours/primordials');\nconst eos = require('./end-of-stream');\nconst {\n  once\n} = require('../../ours/util');\nconst destroyImpl = require('./destroy');\nconst Duplex = require('./duplex');\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateFunction,\n  validateAbortSignal\n} = require('../validators');\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = require('./utils');\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nlet PassThrough;\nlet Readable;\nlet addAbortListener;\nfunction destroyer(stream, reading, writing) {\n  let finished = false;\n  stream.on('close', () => {\n    finished = true;\n  });\n  const cleanup = eos(stream, {\n    readable: reading,\n    writable: writing\n  }, err => {\n    finished = !err;\n  });\n  return {\n    destroy: err => {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));\n    },\n    cleanup\n  };\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');\n  return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val);\n}\nfunction fromReadable(_x) {\n  return _fromReadable.apply(this, arguments);\n}\nfunction _fromReadable() {\n  _fromReadable = _wrapAsyncGenerator(function* (val) {\n    if (!Readable) {\n      Readable = require('./readable');\n    }\n    yield* _asyncGeneratorDelegate(_asyncIterator(Readable.prototype[SymbolAsyncIterator].call(val)), _awaitAsyncGenerator);\n  });\n  return _fromReadable.apply(this, arguments);\n}\nasync function pumpToNode(iterable, writable, finish, _ref) {\n  let {\n    end\n  } = _ref;\n  let error;\n  let onresolve = null;\n  const resume = err => {\n    if (err) {\n      error = err;\n    }\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n  const wait = () => new Promise((resolve, reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n  writable.on('drain', resume);\n  const cleanup = eos(writable, {\n    readable: false\n  }, resume);\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(iterable), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          if (!writable.write(chunk)) {\n            await wait();\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if (end) {\n      writable.end();\n      await wait();\n    }\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err);\n  } finally {\n    cleanup();\n    writable.off('drain', resume);\n  }\n}\nasync function pumpToWeb(readable, writable, finish, _ref2) {\n  let {\n    end\n  } = _ref2;\n  if (isTransformStream(writable)) {\n    writable = writable.writable;\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter();\n  try {\n    var _iteratorAbruptCompletion2 = false;\n    var _didIteratorError2 = false;\n    var _iteratorError2;\n    try {\n      for (var _iterator2 = _asyncIterator(readable), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n        const chunk = _step2.value;\n        {\n          await writer.ready;\n          writer.write(chunk).catch(() => {});\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n          await _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    await writer.ready;\n    if (end) {\n      await writer.close();\n    }\n    finish();\n  } catch (err) {\n    try {\n      await writer.abort(err);\n      finish(err);\n    } catch (err) {\n      finish(err);\n    }\n  }\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  return pipelineImpl(streams, once(popCallback(streams)));\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = [];\n  validateAbortSignal(outerSignal, 'options.signal');\n  function abort() {\n    finishImpl(new AbortError());\n  }\n  addAbortListener = addAbortListener || require('../../ours/util').addAbortListener;\n  let disposable;\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort);\n  }\n  let error;\n  let value;\n  const destroys = [];\n  let finishCount = 0;\n  function finish(err) {\n    finishImpl(err, --finishCount === 0);\n  }\n  function finishImpl(err, final) {\n    var _disposable;\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n    if (!error && !final) {\n      return;\n    }\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n    ;\n    (_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]();\n    ac.abort();\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach(fn => fn());\n      }\n      process.nextTick(callback, error, value);\n    }\n  }\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n    const isLastStream = i === streams.length - 1;\n    if (isNodeStream(stream)) {\n      if (end) {\n        const {\n          destroy,\n          cleanup\n        } = destroyer(stream, reading, writing);\n        destroys.push(destroy);\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err);\n        }\n      }\n      stream.on('error', onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError);\n        });\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret;\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);\n      } else {\n        ret = makeAsyncIterable(ret);\n      }\n      ret = stream(ret, {\n        signal\n      });\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', \"transform[\".concat(i - 1, \"]\"), ret);\n        }\n      } else {\n        var _ret2;\n        if (!PassThrough) {\n          PassThrough = require('./passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        });\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret, val => {\n            value = val;\n            if (val != null) {\n              pt.write(val);\n            }\n            if (end) {\n              pt.end();\n            }\n            process.nextTick(finish);\n          }, err => {\n            pt.destroy(err);\n            process.nextTick(finish, err);\n          });\n        } else if (isIterable(ret, true)) {\n          finishCount++;\n          pumpToNode(ret, pt, finish, {\n            end\n          });\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret;\n          finishCount++;\n          pumpToNode(toRead, pt, finish, {\n            end\n          });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret);\n        }\n        ret = pt;\n        const {\n          destroy,\n          cleanup\n        } = destroyer(ret, false, true);\n        destroys.push(destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret;\n        finishCount++;\n        pumpToNode(toRead, stream, finish, {\n          end\n        });\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pumpToNode(ret, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'], ret);\n      }\n      ret = stream;\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++;\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        });\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++;\n        pumpToWeb(ret, stream, finish, {\n          end\n        });\n      } else if (isTransformStream(ret)) {\n        finishCount++;\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'], ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n  if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {\n    process.nextTick(abort);\n  }\n  return ret;\n}\nfunction pipe(src, dst, finish, _ref3) {\n  let {\n    end\n  } = _ref3;\n  let ended = false;\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n  src.pipe(dst, {\n    end: false\n  }); // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true;\n      dst.end();\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn);\n    } else {\n      src.once('end', endFn);\n    }\n  } else {\n    finish();\n  }\n  eos(src, {\n    readable: true,\n    writable: false\n  }, err => {\n    const rState = src._readableState;\n    if (err && err.code === 'ERR_STREAM_PREMATURE_CLOSE' && rState && rState.ended && !rState.errored && !rState.errorEmitted) {\n      // Some readable streams will emit 'close' before 'end'. However, since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src.once('end', finish).once('error', finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst, {\n    readable: false,\n    writable: true\n  }, finish);\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n};","map":{"version":3,"names":["process","require","ArrayIsArray","Promise","SymbolAsyncIterator","SymbolDispose","eos","once","destroyImpl","Duplex","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_INVALID_RETURN_VALUE","ERR_MISSING_ARGS","ERR_STREAM_DESTROYED","ERR_STREAM_PREMATURE_CLOSE","AbortError","validateFunction","validateAbortSignal","isIterable","isReadable","isReadableNodeStream","isNodeStream","isTransformStream","isWebStream","isReadableStream","isReadableFinished","AbortController","globalThis","PassThrough","Readable","addAbortListener","destroyer","stream","reading","writing","finished","on","cleanup","readable","writable","err","destroy","popCallback","streams","length","pop","makeAsyncIterable","val","fromReadable","_x","_fromReadable","apply","arguments","_wrapAsyncGenerator","_asyncGeneratorDelegate","_asyncIterator","prototype","call","_awaitAsyncGenerator","pumpToNode","iterable","finish","_ref","end","error","onresolve","resume","callback","wait","resolve","reject","writableNeedDrain","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","chunk","value","write","return","off","pumpToWeb","_ref2","writer","getWriter","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","ready","catch","close","abort","pipeline","_len","Array","_key","pipelineImpl","opts","ac","signal","outerSignal","undefined","lastStreamCleanup","finishImpl","disposable","destroys","finishCount","final","_disposable","code","shift","forEach","fn","nextTick","ret","i","isLastStream","push","onError","name","removeListener","from","_ret","concat","_ret2","pt","objectMode","then","toRead","pipe","aborted","src","dst","_ref3","ended","endFn","rState","_readableState","errored","errorEmitted","module","exports"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nlet addAbortListener\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n      await wait()\n    }\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n  let disposable\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort)\n  }\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    var _disposable\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}