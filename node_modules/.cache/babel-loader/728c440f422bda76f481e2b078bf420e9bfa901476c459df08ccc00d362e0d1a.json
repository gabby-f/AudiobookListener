{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n\n    // Find the moov atom which contains chapter information\n    const moovOffset = findAtom(view, 'moov', 0);\n    if (moovOffset === -1) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n\n    // Look for the trak atom inside moov\n    const trakOffset = findAtom(view, 'trak', moovOffset);\n    if (trakOffset === -1) {\n      console.log('No trak atom found');\n      return [];\n    }\n\n    // Look for chapters in the file\n    // Chapters can be in the 'chpl' atom or in specific ilst atoms\n    const chapters = [];\n\n    // Method 1: Try to find userdata with chapter list\n    const udatOffset = findAtom(view, 'udat', moovOffset);\n    if (udatOffset !== -1) {\n      const chplOffset = findAtom(view, 'chpl', udatOffset);\n      if (chplOffset !== -1) {\n        return parseChplAtom(view, chplOffset);\n      }\n    }\n\n    // Method 2: Try to find chapters in the general moov structure\n    return parseChaptersFromMoov(view, moovOffset);\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\nfunction findAtom(view, atomName, startOffset = 0) {\n  const atomCode = stringToByteArray(atomName);\n  const searchLimit = Math.min(view.byteLength, startOffset + 100000000); // Limit search to first 100MB\n\n  for (let i = startOffset; i < searchLimit - 3; i++) {\n    let found = true;\n    for (let j = 0; j < 4; j++) {\n      if (view.getUint8(i + 4 + j) !== atomCode[j]) {\n        found = false;\n        break;\n      }\n    }\n    if (found) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction stringToByteArray(str) {\n  const bytes = [];\n  for (let i = 0; i < str.length; i++) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nfunction parseChplAtom(view, offset) {\n  try {\n    // chpl atom structure:\n    // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\n    if (offset + 12 >= view.byteLength) return [];\n    const version = view.getUint8(offset + 8);\n    const flags = view.getUint32(offset + 8);\n    const entryCount = view.getUint8(offset + 12);\n    const chapters = [];\n    let currentOffset = offset + 13;\n    for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\n      // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\n      if (currentOffset + 5 > view.byteLength) break;\n      const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\n      const titleLength = view.getUint8(currentOffset + 4);\n      currentOffset += 5;\n      if (currentOffset + titleLength > view.byteLength) break;\n      const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\n      const title = new TextDecoder().decode(titleBytes);\n      currentOffset += titleLength;\n      chapters.push({\n        title: title || `Chapter ${i + 1}`,\n        startTime: startTime,\n        duration: null\n      });\n    }\n    if (chapters.length > 0) {\n      console.log(`Extracted ${chapters.length} chapters from chpl atom`);\n    }\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\nfunction parseChaptersFromMoov(view, moovOffset) {\n  // This is a fallback parser that looks through the moov structure\n  // for chapter information in various formats\n  const chapters = [];\n  try {\n    // Get moov size to know search bounds\n    if (moovOffset < 4) return [];\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n\n    // Search for chapter markers within moov\n    for (let i = moovOffset; i < moovEnd - 100; i++) {\n      // Look for common chapter patterns\n      if (view.getUint32(i, false) === 0x6368706c ||\n      // 'chpl' in reverse endian\n      view.getUint32(i, false) === 0x6c706863) {\n        // 'lphc' \n        const chapterData = parseChplAtom(view, i);\n        if (chapterData.length > 0) {\n          return chapterData;\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing moov for chapters:', error);\n  }\n  return chapters;\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","moovOffset","findAtom","console","log","trakOffset","chapters","udatOffset","chplOffset","parseChplAtom","parseChaptersFromMoov","error","atomName","startOffset","atomCode","stringToByteArray","searchLimit","Math","min","byteLength","i","found","j","getUint8","str","bytes","length","push","charCodeAt","offset","version","flags","getUint32","entryCount","currentOffset","startTime","titleLength","titleBytes","Uint8Array","title","TextDecoder","decode","duration","moovSize","moovEnd","chapterData","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        // Find the moov atom which contains chapter information\r\n        const moovOffset = findAtom(view, 'moov', 0);\r\n        if (moovOffset === -1) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        // Look for the trak atom inside moov\r\n        const trakOffset = findAtom(view, 'trak', moovOffset);\r\n        if (trakOffset === -1) {\r\n            console.log('No trak atom found');\r\n            return [];\r\n        }\r\n        \r\n        // Look for chapters in the file\r\n        // Chapters can be in the 'chpl' atom or in specific ilst atoms\r\n        const chapters = [];\r\n        \r\n        // Method 1: Try to find userdata with chapter list\r\n        const udatOffset = findAtom(view, 'udat', moovOffset);\r\n        if (udatOffset !== -1) {\r\n            const chplOffset = findAtom(view, 'chpl', udatOffset);\r\n            if (chplOffset !== -1) {\r\n                return parseChplAtom(view, chplOffset);\r\n            }\r\n        }\r\n        \r\n        // Method 2: Try to find chapters in the general moov structure\r\n        return parseChaptersFromMoov(view, moovOffset);\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    const atomCode = stringToByteArray(atomName);\r\n    const searchLimit = Math.min(view.byteLength, startOffset + 100000000); // Limit search to first 100MB\r\n    \r\n    for (let i = startOffset; i < searchLimit - 3; i++) {\r\n        let found = true;\r\n        for (let j = 0; j < 4; j++) {\r\n            if (view.getUint8(i + 4 + j) !== atomCode[j]) {\r\n                found = false;\r\n                break;\r\n            }\r\n        }\r\n        if (found) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction stringToByteArray(str) {\r\n    const bytes = [];\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes.push(str.charCodeAt(i));\r\n    }\r\n    return bytes;\r\n}\r\n\r\nfunction parseChplAtom(view, offset) {\r\n    try {\r\n        // chpl atom structure:\r\n        // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\r\n        if (offset + 12 >= view.byteLength) return [];\r\n        \r\n        const version = view.getUint8(offset + 8);\r\n        const flags = view.getUint32(offset + 8);\r\n        const entryCount = view.getUint8(offset + 12);\r\n        \r\n        const chapters = [];\r\n        let currentOffset = offset + 13;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\r\n            // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\r\n            if (currentOffset + 5 > view.byteLength) break;\r\n            \r\n            const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\r\n            const titleLength = view.getUint8(currentOffset + 4);\r\n            currentOffset += 5;\r\n            \r\n            if (currentOffset + titleLength > view.byteLength) break;\r\n            \r\n            const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\r\n            const title = new TextDecoder().decode(titleBytes);\r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title || `Chapter ${i + 1}`,\r\n                startTime: startTime,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        if (chapters.length > 0) {\r\n            console.log(`Extracted ${chapters.length} chapters from chpl atom`);\r\n        }\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction parseChaptersFromMoov(view, moovOffset) {\r\n    // This is a fallback parser that looks through the moov structure\r\n    // for chapter information in various formats\r\n    const chapters = [];\r\n    \r\n    try {\r\n        // Get moov size to know search bounds\r\n        if (moovOffset < 4) return [];\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        // Search for chapter markers within moov\r\n        for (let i = moovOffset; i < moovEnd - 100; i++) {\r\n            // Look for common chapter patterns\r\n            if (view.getUint32(i, false) === 0x6368706c || // 'chpl' in reverse endian\r\n                view.getUint32(i, false) === 0x6c706863) {  // 'lphc' \r\n                const chapterData = parseChplAtom(view, i);\r\n                if (chapterData.length > 0) {\r\n                    return chapterData;\r\n                }\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing moov for chapters:', error);\r\n    }\r\n    \r\n    return chapters;\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}