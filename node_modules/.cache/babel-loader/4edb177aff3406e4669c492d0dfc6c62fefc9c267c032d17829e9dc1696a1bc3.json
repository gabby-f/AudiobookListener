{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.APEv2Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst token_types_1 = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst APEv2Token_1 = require(\"./APEv2Token\");\nconst debug = (0, debug_1.default)('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.ape = {};\n  }\n  static tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n  }\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n  static calculateDuration(ah) {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n  /**\n   * Calculates the APEv1 / APEv2 first field offset\n   * @param reader\n   * @param offset\n   */\n  static async findApeFooterOffset(reader, offset) {\n    // Search for APE footer header at the end of the file\n    const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n    await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n    const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n    if (tagFooter.ID === 'APETAGEX') {\n      debug(`APE footer header at offset=${offset}`);\n      return {\n        footer: tagFooter,\n        offset: offset - tagFooter.size\n      };\n    }\n  }\n  static parseTagFooter(metadata, buffer, options) {\n    const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n    if (footer.ID !== preamble) throw new Error('Unexpected APEv2 Footer ID preamble value.');\n    strtok3.fromBuffer(buffer);\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n    return apeParser.parseTags(footer);\n  }\n  /**\n   * Parse APEv1 / APEv2 header if header signature found\n   */\n  async tryParseApeHeader() {\n    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n      debug(`No APEv2 header found, end-of-file reached`);\n      return;\n    }\n    const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n    if (footer.ID === preamble) {\n      await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n      return this.parseTags(footer);\n    } else {\n      debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n      if (this.tokenizer.fileInfo.size) {\n        // Try to read the APEv2 header using just the footer-header\n        const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n        const buffer = Buffer.alloc(remaining);\n        await this.tokenizer.readBuffer(buffer);\n        return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n      }\n    }\n  }\n  async parse() {\n    const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n    if (descriptor.ID !== 'MAC ') throw new Error('Unexpected descriptor ID');\n    this.ape.descriptor = descriptor;\n    const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n    const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n    await this.tokenizer.ignore(header.forwardBytes);\n    return this.tryParseApeHeader();\n  }\n  async parseTags(footer) {\n    const keyBuffer = Buffer.alloc(256); // maximum tag key length\n    let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n    debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n    for (let i = 0; i < footer.fields; i++) {\n      if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n        this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n        break;\n      }\n      // Only APEv2 tag has tag item headers\n      const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n      bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n      await this.tokenizer.peekBuffer(keyBuffer, {\n        length: Math.min(keyBuffer.length, bytesRemaining)\n      });\n      let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n      const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n      await this.tokenizer.ignore(1);\n      bytesRemaining -= key.length + 1;\n      switch (tagItemHeader.flags.dataType) {\n        case APEv2Token_1.DataType.text_utf8:\n          {\n            // utf-8 text-string\n            const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n            const values = value.split(/\\x00/g);\n            for (const val of values) {\n              this.metadata.addTag(tagFormat, key, val);\n            }\n            break;\n          }\n        case APEv2Token_1.DataType.binary:\n          // binary (probably artwork)\n          if (this.options.skipCovers) {\n            await this.tokenizer.ignore(tagItemHeader.size);\n          } else {\n            const picData = Buffer.alloc(tagItemHeader.size);\n            await this.tokenizer.readBuffer(picData);\n            zero = util.findZero(picData, 0, picData.length);\n            const description = picData.toString('utf8', 0, zero);\n            const data = Buffer.from(picData.slice(zero + 1));\n            this.metadata.addTag(tagFormat, key, {\n              description,\n              data\n            });\n          }\n          break;\n        case APEv2Token_1.DataType.external_info:\n          debug(`Ignore external info ${key}`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n        case APEv2Token_1.DataType.reserved:\n          debug(`Ignore external info ${key}`);\n          this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n      }\n    }\n  }\n  async parseDescriptorExpansion(lenExp) {\n    await this.tokenizer.ignore(lenExp);\n    return this.parseHeader();\n  }\n  async parseHeader() {\n    const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n    // ToDo before\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('container', 'Monkey\\'s Audio');\n    this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n    this.metadata.setFormat('sampleRate', header.sampleRate);\n    this.metadata.setFormat('numberOfChannels', header.channel);\n    this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n    return {\n      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n    };\n  }\n}\nexports.APEv2Parser = APEv2Parser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}