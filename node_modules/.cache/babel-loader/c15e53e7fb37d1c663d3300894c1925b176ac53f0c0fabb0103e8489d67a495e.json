{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\n\n    // Find the moov atom which contains all metadata\n    const moov = findMoovAtom(view);\n    if (!moov) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n    console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\n\n    // Method 1: Look for udta (user data) -> chpl (chapter list)\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta atom at offset:', udta.offset);\n      const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\n      if (chpl) {\n        console.log('Found chpl atom in udta at offset:', chpl.offset);\n        const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\n        if (chapters.length > 0) {\n          console.log('Successfully extracted', chapters.length, 'chapters from chpl');\n          return chapters;\n        }\n      }\n    }\n\n    // Method 2: Look for chapter track (text track referenced as chapters)\n    const chapters = parseChapterTrack(view, moov.offset, moov.size);\n    if (chapters.length > 0) {\n      console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\n      return chapters;\n    }\n    console.log('No chapters found in file');\n    return [];\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\n\n/**\r\n * Extract metadata (title, artist, album, cover art) from M4B file\r\n * Reads directly from MP4 atoms like VLC does\r\n */\nexport async function extractM4BMetadata(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B metadata extraction');\n    const metadata = {\n      title: null,\n      artist: null,\n      album: null,\n      albumArtist: null,\n      cover: null,\n      duration: 0\n    };\n\n    // Find the moov atom\n    const moov = findAtom(view, 'moov', 0);\n    if (!moov) {\n      console.log('No moov atom found');\n      return metadata;\n    }\n\n    // Get duration from mvhd (movie header)\n    const mvhd = findAtomInParent(view, 'mvhd', moov.offset, moov.size);\n    if (mvhd) {\n      const version = view.getUint8(mvhd.offset + 8);\n      let duration, timescale;\n      if (version === 1) {\n        // 64-bit version\n        timescale = view.getUint32(mvhd.offset + 20, false);\n        const durationHigh = view.getUint32(mvhd.offset + 24, false);\n        const durationLow = view.getUint32(mvhd.offset + 28, false);\n        duration = (durationHigh * 0x100000000 + durationLow) / timescale;\n      } else {\n        // 32-bit version\n        timescale = view.getUint32(mvhd.offset + 12, false);\n        duration = view.getUint32(mvhd.offset + 16, false) / timescale;\n      }\n      metadata.duration = duration;\n      console.log('Duration:', duration, 'seconds');\n    }\n\n    // Look for metadata in udta -> meta -> ilst\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta at offset:', udta.offset, 'size:', udta.size);\n      const meta = findAtomInParent(view, 'meta', udta.offset, udta.size);\n      if (meta) {\n        console.log('Found meta at offset:', meta.offset, 'size:', meta.size);\n        // meta atom has version/flags (4 bytes) after size+name, skip them\n        const ilst = findAtomInParent(view, 'ilst', meta.offset + 4, meta.size - 4);\n        if (ilst) {\n          console.log('Found ilst (item list) at offset:', ilst.offset, 'size:', ilst.size);\n\n          // Parse all metadata items\n          const items = parseIlstAtom(view, ilst.offset, ilst.size);\n\n          // Extract specific metadata fields\n          metadata.title = items['©nam'] || items['title'] || null;\n          metadata.artist = items['©ART'] || items['artist'] || null;\n          metadata.album = items['©alb'] || items['album'] || null;\n          metadata.albumArtist = items['aART'] || null;\n          metadata.cover = items['covr'] || null;\n          console.log('Extracted metadata:', {\n            title: metadata.title,\n            artist: metadata.artist,\n            album: metadata.album,\n            hasCover: !!metadata.cover\n          });\n        } else {\n          console.log('No ilst atom found in meta');\n        }\n      } else {\n        console.log('No meta atom found in udta');\n      }\n    } else {\n      console.log('No udta atom found in moov');\n    }\n    return metadata;\n  } catch (error) {\n    console.error('Error extracting M4B metadata:', error);\n    return {\n      title: null,\n      artist: null,\n      album: null,\n      albumArtist: null,\n      cover: null,\n      duration: 0\n    };\n  }\n}\n\n/**\r\n * Parse ilst (item list) atom to extract all metadata tags\r\n */\nfunction parseIlstAtom(view, ilstOffset, ilstSize) {\n  const metadata = {};\n  let offset = ilstOffset + 8; // Skip ilst size and name\n  const endOffset = ilstOffset + ilstSize;\n  console.log('Parsing ilst from offset:', offset, 'to:', endOffset);\n  try {\n    while (offset < endOffset - 8) {\n      if (offset + 8 > view.byteLength) break;\n      const itemSize = view.getUint32(offset, false);\n      const itemName = readAtomName(view, offset + 4);\n      console.log(`Found item: ${itemName}, size: ${itemSize}`);\n      if (itemSize < 8 || itemSize > ilstSize || itemSize > endOffset - offset) {\n        console.log('Invalid item size, skipping');\n        offset += 8;\n        continue;\n      }\n\n      // Look for data atom inside this item\n      const dataAtom = findAtomInParent(view, 'data', offset, itemSize);\n      if (dataAtom) {\n        const value = parseDataAtom(view, dataAtom.offset, dataAtom.size, itemName);\n        if (value !== null) {\n          metadata[itemName] = value;\n          console.log(`Found metadata: ${itemName} =`, typeof value === 'string' ? value.substring(0, 50) : 'binary data');\n        }\n      }\n      offset += itemSize;\n    }\n  } catch (error) {\n    console.error('Error parsing ilst atom:', error);\n  }\n  return metadata;\n}\n\n/**\r\n * Parse data atom and extract the actual value\r\n */\nfunction parseDataAtom(view, dataOffset, dataSize, itemName) {\n  try {\n    if (dataSize < 16) {\n      console.log(`Data atom for ${itemName} too small:`, dataSize);\n      return null;\n    }\n\n    // data atom structure: size(4) + 'data'(4) + type(4) + locale(4) + value\n    const dataType = view.getUint32(dataOffset + 8, false);\n    const valueOffset = dataOffset + 16;\n    const valueSize = dataSize - 16;\n    console.log(`Parsing ${itemName}: type=${dataType}, valueSize=${valueSize}`);\n\n    // Type 1 = UTF-8 text\n    if (dataType === 1) {\n      const bytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\n      return new TextDecoder('utf-8').decode(bytes).trim();\n    }\n\n    // Type 13 = JPEG image\n    // Type 14 = PNG image\n    if (dataType === 13 || dataType === 14) {\n      if (itemName === 'covr') {\n        const imageBytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\n        const mimeType = dataType === 13 ? 'image/jpeg' : 'image/png';\n        const blob = new Blob([imageBytes], {\n          type: mimeType\n        });\n        return URL.createObjectURL(blob);\n      }\n    }\n\n    // Type 21 = signed integer\n    if (dataType === 21) {\n      if (valueSize === 1) return view.getInt8(valueOffset);\n      if (valueSize === 2) return view.getInt16(valueOffset, false);\n      if (valueSize === 4) return view.getInt32(valueOffset, false);\n    }\n\n    // Type 0 = binary data (also used for integers sometimes)\n    if (dataType === 0) {\n      if (valueSize === 1) return view.getUint8(valueOffset);\n      if (valueSize === 2) return view.getUint16(valueOffset, false);\n      if (valueSize === 4) return view.getUint32(valueOffset, false);\n    }\n    return null;\n  } catch (error) {\n    console.error('Error parsing data atom:', error);\n    return null;\n  }\n}\n\n// Find an atom starting from the beginning of the file\nfunction findAtom(view, atomName, startOffset = 0) {\n  let offset = startOffset;\n  // For large files, search first 10MB and last 10MB (moov is often at end in M4B files)\n  const searchSize = 10000000; // 10MB\n  const fileSize = view.byteLength;\n\n  // Search from start\n  const startSearchEnd = Math.min(fileSize, startOffset + searchSize);\n  while (offset < startSearchEnd - 8) {\n    const size = view.getUint32(offset, false); // Big-endian\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      console.log(`Found ${atomName} at offset ${offset} (from start)`);\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means atom extends to EOF\n    if (size === 1) {\n      // Extended size in next 8 bytes\n      const extSize = view.getBigUint64(offset + 8, false);\n      offset += Number(extSize);\n    } else if (size < 8) {\n      // Invalid size\n      offset += 1;\n    } else {\n      offset += size;\n    }\n  }\n\n  // If not found in first part, search last 10MB of file (common for M4B)\n  if (atomName === 'moov' && fileSize > searchSize * 2) {\n    console.log('Searching end of file for moov atom...');\n    offset = Math.max(startOffset, fileSize - searchSize);\n    while (offset < fileSize - 8) {\n      const size = view.getUint32(offset, false);\n      const name = readAtomName(view, offset + 4);\n      if (name === atomName) {\n        console.log(`Found ${atomName} at offset ${offset} (from end)`);\n        return {\n          offset,\n          size\n        };\n      }\n      if (size === 0 || size === 1 || size < 8) {\n        offset += 1;\n      } else {\n        offset += size;\n      }\n    }\n  }\n  return null;\n}\n\n// Find an atom within a parent atom's boundaries\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\n  let offset = parentOffset + 8; // Skip parent's size and name\n  const endOffset = parentOffset + parentSize;\n  while (offset < endOffset - 8 && offset < view.byteLength) {\n    if (offset + 8 > view.byteLength) break;\n    const size = view.getUint32(offset, false);\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means extends to end\n    if (size === 1) {\n      // Extended size (rarely used in nested atoms)\n      if (offset + 16 <= view.byteLength) {\n        const extSize = Number(view.getBigUint64(offset + 8, false));\n        offset += extSize;\n      } else {\n        break;\n      }\n    } else if (size < 8) {\n      // Invalid size, try to skip\n      offset += 1;\n    } else {\n      offset += size;\n    }\n\n    // Safety check to prevent infinite loops\n    if (offset >= endOffset || offset <= parentOffset + 8) break;\n  }\n  return null;\n}\n\n// Read 4-byte atom name as ASCII string\nfunction readAtomName(view, offset) {\n  if (offset + 4 > view.byteLength) return '';\n  let name = '';\n  for (let i = 0; i < 4; i++) {\n    name += String.fromCharCode(view.getUint8(offset + i));\n  }\n  return name;\n}\n\n// Parse the chpl (chapter list) atom\nfunction parseChplAtom(view, dataOffset, dataSize) {\n  try {\n    // chpl data structure:\n    // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\n    if (dataSize < 12) {\n      console.log('chpl atom too small:', dataSize);\n      return [];\n    }\n    const version = view.getUint8(dataOffset);\n    const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\n\n    console.log('chpl version:', version, 'entry count:', entryCount);\n    if (entryCount === 0 || entryCount > 1000) {\n      console.log('Invalid chapter count:', entryCount);\n      return [];\n    }\n    const chapters = [];\n    let currentOffset = dataOffset + 12;\n    const endOffset = dataOffset + dataSize;\n    for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\n      // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\n      if (currentOffset + 9 > endOffset) break;\n\n      // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\n      const timestampHigh = view.getUint32(currentOffset, false);\n      const timestampLow = view.getUint32(currentOffset + 4, false);\n      const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\n\n      const titleLength = view.getUint8(currentOffset + 8);\n      currentOffset += 9;\n      if (currentOffset + titleLength > endOffset) break;\n      let title = '';\n      if (titleLength > 0) {\n        const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\n        title = new TextDecoder('utf-8').decode(titleBytes);\n      }\n      currentOffset += titleLength;\n      chapters.push({\n        title: title.trim() || `Chapter ${i + 1}`,\n        startTime: timestamp,\n        duration: null\n      });\n    }\n\n    // Calculate durations\n    for (let i = 0; i < chapters.length - 1; i++) {\n      chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\n    }\n    console.log('Parsed chapters:', chapters);\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\n\n// Parse chapter track (text track with chapter markers)\nfunction parseChapterTrack(view, moovOffset, moovSize) {\n  try {\n    let offset = moovOffset + 8; // Skip moov size and name\n    const endOffset = moovOffset + moovSize;\n\n    // Find all trak atoms in moov\n    while (offset < endOffset - 8) {\n      const trak = findAtomInParent(view, 'trak', moovOffset, moovSize);\n      if (!trak) break;\n\n      // Look for text track with chapter references\n      const mdia = findAtomInParent(view, 'mdia', trak.offset, trak.size);\n      if (mdia) {\n        const minf = findAtomInParent(view, 'minf', mdia.offset, mdia.size);\n        if (minf) {\n          const stbl = findAtomInParent(view, 'stbl', minf.offset, minf.size);\n          if (stbl) {\n            const chapters = parseTextSamples(view, stbl.offset, stbl.size, mdia.offset, mdia.size);\n            if (chapters.length > 0) return chapters;\n          }\n        }\n      }\n      offset = trak.offset + trak.size;\n    }\n  } catch (error) {\n    console.error('Error parsing chapter track:', error);\n  }\n  return [];\n}\n\n// Parse text samples from stbl (sample table) atom\nfunction parseTextSamples(view, stblOffset, stblSize, mdiaOffset, mdiaSize) {\n  try {\n    // Get time scale from mdhd (media header)\n    const mdhd = findAtomInParent(view, 'mdhd', mdiaOffset, mdiaSize);\n    let timeScale = 1000; // Default\n\n    if (mdhd) {\n      const version = view.getUint8(mdhd.offset + 8);\n      const timeScaleOffset = version === 1 ? 20 : 12;\n      timeScale = view.getUint32(mdhd.offset + 8 + timeScaleOffset, false);\n      console.log('Time scale:', timeScale);\n    }\n\n    // Get sample times from stts (time-to-sample)\n    const stts = findAtomInParent(view, 'stts', stblOffset, stblSize);\n    if (!stts) return [];\n    const entryCount = view.getUint32(stts.offset + 12, false);\n    console.log('stts entry count:', entryCount);\n    const sampleTimes = [];\n    let currentTime = 0;\n    let dataOffset = stts.offset + 16;\n    for (let i = 0; i < entryCount && dataOffset + 8 <= stts.offset + stts.size; i++) {\n      const sampleCount = view.getUint32(dataOffset, false);\n      const sampleDelta = view.getUint32(dataOffset + 4, false);\n      for (let j = 0; j < sampleCount; j++) {\n        sampleTimes.push(currentTime / timeScale);\n        currentTime += sampleDelta;\n      }\n      dataOffset += 8;\n    }\n\n    // Get sample descriptions from stsd\n    const stsd = findAtomInParent(view, 'stsd', stblOffset, stblSize);\n    if (!stsd) return [];\n\n    // Check if this is a text track\n    const handlerType = readAtomName(view, stsd.offset + 20);\n    console.log('Handler type:', handlerType);\n\n    // Get sample sizes from stsz\n    const stsz = findAtomInParent(view, 'stsz', stblOffset, stblSize);\n    if (!stsz) return [];\n    const sampleCount = view.getUint32(stsz.offset + 16, false);\n    console.log('Sample count:', sampleCount);\n\n    // For now, create generic chapter markers based on sample times\n    const chapters = [];\n    for (let i = 0; i < Math.min(sampleTimes.length, 200); i++) {\n      chapters.push({\n        title: `Chapter ${i + 1}`,\n        startTime: sampleTimes[i],\n        duration: i < sampleTimes.length - 1 ? sampleTimes[i + 1] - sampleTimes[i] : null\n      });\n    }\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing text samples:', error);\n    return [];\n  }\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","console","log","byteLength","moov","findMoovAtom","offset","size","udta","findAtomInParent","chpl","chapters","parseChplAtom","length","parseChapterTrack","error","extractM4BMetadata","metadata","title","artist","album","albumArtist","cover","duration","findAtom","mvhd","version","getUint8","timescale","getUint32","durationHigh","durationLow","meta","ilst","items","parseIlstAtom","hasCover","ilstOffset","ilstSize","endOffset","itemSize","itemName","readAtomName","dataAtom","value","parseDataAtom","substring","dataOffset","dataSize","dataType","valueOffset","valueSize","bytes","Uint8Array","byteOffset","TextDecoder","decode","trim","imageBytes","mimeType","blob","Blob","type","URL","createObjectURL","getInt8","getInt16","getInt32","getUint16","atomName","startOffset","searchSize","fileSize","startSearchEnd","Math","min","name","extSize","getBigUint64","Number","max","parentOffset","parentSize","i","String","fromCharCode","entryCount","currentOffset","timestampHigh","timestampLow","timestamp","titleLength","titleBytes","push","startTime","moovOffset","moovSize","trak","mdia","minf","stbl","parseTextSamples","stblOffset","stblSize","mdiaOffset","mdiaSize","mdhd","timeScale","timeScaleOffset","stts","sampleTimes","currentTime","sampleCount","sampleDelta","j","stsd","handlerType","stsz","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\r\n        \r\n        // Find the moov atom which contains all metadata\r\n        const moov = findMoovAtom(view);\r\n        if (!moov) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\r\n        \r\n        // Method 1: Look for udta (user data) -> chpl (chapter list)\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta atom at offset:', udta.offset);\r\n            const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\r\n            if (chpl) {\r\n                console.log('Found chpl atom in udta at offset:', chpl.offset);\r\n                const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\r\n                if (chapters.length > 0) {\r\n                    console.log('Successfully extracted', chapters.length, 'chapters from chpl');\r\n                    return chapters;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Method 2: Look for chapter track (text track referenced as chapters)\r\n        const chapters = parseChapterTrack(view, moov.offset, moov.size);\r\n        if (chapters.length > 0) {\r\n            console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\r\n            return chapters;\r\n        }\r\n        \r\n        console.log('No chapters found in file');\r\n        return [];\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Extract metadata (title, artist, album, cover art) from M4B file\r\n * Reads directly from MP4 atoms like VLC does\r\n */\r\nexport async function extractM4BMetadata(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B metadata extraction');\r\n        \r\n        const metadata = {\r\n            title: null,\r\n            artist: null,\r\n            album: null,\r\n            albumArtist: null,\r\n            cover: null,\r\n            duration: 0\r\n        };\r\n        \r\n        // Find the moov atom\r\n        const moov = findAtom(view, 'moov', 0);\r\n        if (!moov) {\r\n            console.log('No moov atom found');\r\n            return metadata;\r\n        }\r\n        \r\n        // Get duration from mvhd (movie header)\r\n        const mvhd = findAtomInParent(view, 'mvhd', moov.offset, moov.size);\r\n        if (mvhd) {\r\n            const version = view.getUint8(mvhd.offset + 8);\r\n            let duration, timescale;\r\n            \r\n            if (version === 1) {\r\n                // 64-bit version\r\n                timescale = view.getUint32(mvhd.offset + 20, false);\r\n                const durationHigh = view.getUint32(mvhd.offset + 24, false);\r\n                const durationLow = view.getUint32(mvhd.offset + 28, false);\r\n                duration = (durationHigh * 0x100000000 + durationLow) / timescale;\r\n            } else {\r\n                // 32-bit version\r\n                timescale = view.getUint32(mvhd.offset + 12, false);\r\n                duration = view.getUint32(mvhd.offset + 16, false) / timescale;\r\n            }\r\n            \r\n            metadata.duration = duration;\r\n            console.log('Duration:', duration, 'seconds');\r\n        }\r\n        \r\n        // Look for metadata in udta -> meta -> ilst\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta at offset:', udta.offset, 'size:', udta.size);\r\n            const meta = findAtomInParent(view, 'meta', udta.offset, udta.size);\r\n            if (meta) {\r\n                console.log('Found meta at offset:', meta.offset, 'size:', meta.size);\r\n                // meta atom has version/flags (4 bytes) after size+name, skip them\r\n                const ilst = findAtomInParent(view, 'ilst', meta.offset + 4, meta.size - 4);\r\n                if (ilst) {\r\n                    console.log('Found ilst (item list) at offset:', ilst.offset, 'size:', ilst.size);\r\n                    \r\n                    // Parse all metadata items\r\n                    const items = parseIlstAtom(view, ilst.offset, ilst.size);\r\n                    \r\n                    // Extract specific metadata fields\r\n                    metadata.title = items['©nam'] || items['title'] || null;\r\n                    metadata.artist = items['©ART'] || items['artist'] || null;\r\n                    metadata.album = items['©alb'] || items['album'] || null;\r\n                    metadata.albumArtist = items['aART'] || null;\r\n                    metadata.cover = items['covr'] || null;\r\n                    \r\n                    console.log('Extracted metadata:', {\r\n                        title: metadata.title,\r\n                        artist: metadata.artist,\r\n                        album: metadata.album,\r\n                        hasCover: !!metadata.cover\r\n                    });\r\n                } else {\r\n                    console.log('No ilst atom found in meta');\r\n                }\r\n            } else {\r\n                console.log('No meta atom found in udta');\r\n            }\r\n        } else {\r\n            console.log('No udta atom found in moov');\r\n        }\r\n        \r\n        return metadata;\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B metadata:', error);\r\n        return {\r\n            title: null,\r\n            artist: null,\r\n            album: null,\r\n            albumArtist: null,\r\n            cover: null,\r\n            duration: 0\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Parse ilst (item list) atom to extract all metadata tags\r\n */\r\nfunction parseIlstAtom(view, ilstOffset, ilstSize) {\r\n    const metadata = {};\r\n    let offset = ilstOffset + 8; // Skip ilst size and name\r\n    const endOffset = ilstOffset + ilstSize;\r\n    \r\n    console.log('Parsing ilst from offset:', offset, 'to:', endOffset);\r\n    \r\n    try {\r\n        while (offset < endOffset - 8) {\r\n            if (offset + 8 > view.byteLength) break;\r\n            \r\n            const itemSize = view.getUint32(offset, false);\r\n            const itemName = readAtomName(view, offset + 4);\r\n            \r\n            console.log(`Found item: ${itemName}, size: ${itemSize}`);\r\n            \r\n            if (itemSize < 8 || itemSize > ilstSize || itemSize > (endOffset - offset)) {\r\n                console.log('Invalid item size, skipping');\r\n                offset += 8;\r\n                continue;\r\n            }\r\n            \r\n            // Look for data atom inside this item\r\n            const dataAtom = findAtomInParent(view, 'data', offset, itemSize);\r\n            if (dataAtom) {\r\n                const value = parseDataAtom(view, dataAtom.offset, dataAtom.size, itemName);\r\n                if (value !== null) {\r\n                    metadata[itemName] = value;\r\n                    console.log(`Found metadata: ${itemName} =`, \r\n                        typeof value === 'string' ? value.substring(0, 50) : 'binary data');\r\n                }\r\n            }\r\n            \r\n            offset += itemSize;\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing ilst atom:', error);\r\n    }\r\n    \r\n    return metadata;\r\n}\r\n\r\n/**\r\n * Parse data atom and extract the actual value\r\n */\r\nfunction parseDataAtom(view, dataOffset, dataSize, itemName) {\r\n    try {\r\n        if (dataSize < 16) {\r\n            console.log(`Data atom for ${itemName} too small:`, dataSize);\r\n            return null;\r\n        }\r\n        \r\n        // data atom structure: size(4) + 'data'(4) + type(4) + locale(4) + value\r\n        const dataType = view.getUint32(dataOffset + 8, false);\r\n        const valueOffset = dataOffset + 16;\r\n        const valueSize = dataSize - 16;\r\n        \r\n        console.log(`Parsing ${itemName}: type=${dataType}, valueSize=${valueSize}`);\r\n        \r\n        // Type 1 = UTF-8 text\r\n        if (dataType === 1) {\r\n            const bytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\r\n            return new TextDecoder('utf-8').decode(bytes).trim();\r\n        }\r\n        \r\n        // Type 13 = JPEG image\r\n        // Type 14 = PNG image\r\n        if (dataType === 13 || dataType === 14) {\r\n            if (itemName === 'covr') {\r\n                const imageBytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\r\n                const mimeType = dataType === 13 ? 'image/jpeg' : 'image/png';\r\n                const blob = new Blob([imageBytes], { type: mimeType });\r\n                return URL.createObjectURL(blob);\r\n            }\r\n        }\r\n        \r\n        // Type 21 = signed integer\r\n        if (dataType === 21) {\r\n            if (valueSize === 1) return view.getInt8(valueOffset);\r\n            if (valueSize === 2) return view.getInt16(valueOffset, false);\r\n            if (valueSize === 4) return view.getInt32(valueOffset, false);\r\n        }\r\n        \r\n        // Type 0 = binary data (also used for integers sometimes)\r\n        if (dataType === 0) {\r\n            if (valueSize === 1) return view.getUint8(valueOffset);\r\n            if (valueSize === 2) return view.getUint16(valueOffset, false);\r\n            if (valueSize === 4) return view.getUint32(valueOffset, false);\r\n        }\r\n        \r\n        return null;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing data atom:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Find an atom starting from the beginning of the file\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    let offset = startOffset;\r\n    // For large files, search first 10MB and last 10MB (moov is often at end in M4B files)\r\n    const searchSize = 10000000; // 10MB\r\n    const fileSize = view.byteLength;\r\n    \r\n    // Search from start\r\n    const startSearchEnd = Math.min(fileSize, startOffset + searchSize);\r\n    while (offset < startSearchEnd - 8) {\r\n        const size = view.getUint32(offset, false); // Big-endian\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            console.log(`Found ${atomName} at offset ${offset} (from start)`);\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means atom extends to EOF\r\n        if (size === 1) {\r\n            // Extended size in next 8 bytes\r\n            const extSize = view.getBigUint64(offset + 8, false);\r\n            offset += Number(extSize);\r\n        } else if (size < 8) {\r\n            // Invalid size\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n    }\r\n    \r\n    // If not found in first part, search last 10MB of file (common for M4B)\r\n    if (atomName === 'moov' && fileSize > searchSize * 2) {\r\n        console.log('Searching end of file for moov atom...');\r\n        offset = Math.max(startOffset, fileSize - searchSize);\r\n        while (offset < fileSize - 8) {\r\n            const size = view.getUint32(offset, false);\r\n            const name = readAtomName(view, offset + 4);\r\n            \r\n            if (name === atomName) {\r\n                console.log(`Found ${atomName} at offset ${offset} (from end)`);\r\n                return { offset, size };\r\n            }\r\n            \r\n            if (size === 0 || size === 1 || size < 8) {\r\n                offset += 1;\r\n            } else {\r\n                offset += size;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Find an atom within a parent atom's boundaries\r\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\r\n    let offset = parentOffset + 8; // Skip parent's size and name\r\n    const endOffset = parentOffset + parentSize;\r\n    \r\n    while (offset < endOffset - 8 && offset < view.byteLength) {\r\n        if (offset + 8 > view.byteLength) break;\r\n        \r\n        const size = view.getUint32(offset, false);\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means extends to end\r\n        if (size === 1) {\r\n            // Extended size (rarely used in nested atoms)\r\n            if (offset + 16 <= view.byteLength) {\r\n                const extSize = Number(view.getBigUint64(offset + 8, false));\r\n                offset += extSize;\r\n            } else {\r\n                break;\r\n            }\r\n        } else if (size < 8) {\r\n            // Invalid size, try to skip\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n        \r\n        // Safety check to prevent infinite loops\r\n        if (offset >= endOffset || offset <= parentOffset + 8) break;\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Read 4-byte atom name as ASCII string\r\nfunction readAtomName(view, offset) {\r\n    if (offset + 4 > view.byteLength) return '';\r\n    let name = '';\r\n    for (let i = 0; i < 4; i++) {\r\n        name += String.fromCharCode(view.getUint8(offset + i));\r\n    }\r\n    return name;\r\n}\r\n\r\n// Parse the chpl (chapter list) atom\r\nfunction parseChplAtom(view, dataOffset, dataSize) {\r\n    try {\r\n        // chpl data structure:\r\n        // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\r\n        if (dataSize < 12) {\r\n            console.log('chpl atom too small:', dataSize);\r\n            return [];\r\n        }\r\n        \r\n        const version = view.getUint8(dataOffset);\r\n        const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\r\n        \r\n        console.log('chpl version:', version, 'entry count:', entryCount);\r\n        \r\n        if (entryCount === 0 || entryCount > 1000) {\r\n            console.log('Invalid chapter count:', entryCount);\r\n            return [];\r\n        }\r\n        \r\n        const chapters = [];\r\n        let currentOffset = dataOffset + 12;\r\n        const endOffset = dataOffset + dataSize;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\r\n            // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\r\n            if (currentOffset + 9 > endOffset) break;\r\n            \r\n            // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\r\n            const timestampHigh = view.getUint32(currentOffset, false);\r\n            const timestampLow = view.getUint32(currentOffset + 4, false);\r\n            const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\r\n            \r\n            const titleLength = view.getUint8(currentOffset + 8);\r\n            currentOffset += 9;\r\n            \r\n            if (currentOffset + titleLength > endOffset) break;\r\n            \r\n            let title = '';\r\n            if (titleLength > 0) {\r\n                const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\r\n                title = new TextDecoder('utf-8').decode(titleBytes);\r\n            }\r\n            \r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title.trim() || `Chapter ${i + 1}`,\r\n                startTime: timestamp,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        // Calculate durations\r\n        for (let i = 0; i < chapters.length - 1; i++) {\r\n            chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\r\n        }\r\n        \r\n        console.log('Parsed chapters:', chapters);\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Parse chapter track (text track with chapter markers)\r\nfunction parseChapterTrack(view, moovOffset, moovSize) {\r\n    try {\r\n        let offset = moovOffset + 8; // Skip moov size and name\r\n        const endOffset = moovOffset + moovSize;\r\n        \r\n        // Find all trak atoms in moov\r\n        while (offset < endOffset - 8) {\r\n            const trak = findAtomInParent(view, 'trak', moovOffset, moovSize);\r\n            if (!trak) break;\r\n            \r\n            // Look for text track with chapter references\r\n            const mdia = findAtomInParent(view, 'mdia', trak.offset, trak.size);\r\n            if (mdia) {\r\n                const minf = findAtomInParent(view, 'minf', mdia.offset, mdia.size);\r\n                if (minf) {\r\n                    const stbl = findAtomInParent(view, 'stbl', minf.offset, minf.size);\r\n                    if (stbl) {\r\n                        const chapters = parseTextSamples(view, stbl.offset, stbl.size, mdia.offset, mdia.size);\r\n                        if (chapters.length > 0) return chapters;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            offset = trak.offset + trak.size;\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter track:', error);\r\n    }\r\n    return [];\r\n}\r\n\r\n// Parse text samples from stbl (sample table) atom\r\nfunction parseTextSamples(view, stblOffset, stblSize, mdiaOffset, mdiaSize) {\r\n    try {\r\n        // Get time scale from mdhd (media header)\r\n        const mdhd = findAtomInParent(view, 'mdhd', mdiaOffset, mdiaSize);\r\n        let timeScale = 1000; // Default\r\n        \r\n        if (mdhd) {\r\n            const version = view.getUint8(mdhd.offset + 8);\r\n            const timeScaleOffset = version === 1 ? 20 : 12;\r\n            timeScale = view.getUint32(mdhd.offset + 8 + timeScaleOffset, false);\r\n            console.log('Time scale:', timeScale);\r\n        }\r\n        \r\n        // Get sample times from stts (time-to-sample)\r\n        const stts = findAtomInParent(view, 'stts', stblOffset, stblSize);\r\n        if (!stts) return [];\r\n        \r\n        const entryCount = view.getUint32(stts.offset + 12, false);\r\n        console.log('stts entry count:', entryCount);\r\n        \r\n        const sampleTimes = [];\r\n        let currentTime = 0;\r\n        let dataOffset = stts.offset + 16;\r\n        \r\n        for (let i = 0; i < entryCount && dataOffset + 8 <= stts.offset + stts.size; i++) {\r\n            const sampleCount = view.getUint32(dataOffset, false);\r\n            const sampleDelta = view.getUint32(dataOffset + 4, false);\r\n            \r\n            for (let j = 0; j < sampleCount; j++) {\r\n                sampleTimes.push(currentTime / timeScale);\r\n                currentTime += sampleDelta;\r\n            }\r\n            \r\n            dataOffset += 8;\r\n        }\r\n        \r\n        // Get sample descriptions from stsd\r\n        const stsd = findAtomInParent(view, 'stsd', stblOffset, stblSize);\r\n        if (!stsd) return [];\r\n        \r\n        // Check if this is a text track\r\n        const handlerType = readAtomName(view, stsd.offset + 20);\r\n        console.log('Handler type:', handlerType);\r\n        \r\n        // Get sample sizes from stsz\r\n        const stsz = findAtomInParent(view, 'stsz', stblOffset, stblSize);\r\n        if (!stsz) return [];\r\n        \r\n        const sampleCount = view.getUint32(stsz.offset + 16, false);\r\n        console.log('Sample count:', sampleCount);\r\n        \r\n        // For now, create generic chapter markers based on sample times\r\n        const chapters = [];\r\n        for (let i = 0; i < Math.min(sampleTimes.length, 200); i++) {\r\n            chapters.push({\r\n                title: `Chapter ${i + 1}`,\r\n                startTime: sampleTimes[i],\r\n                duration: i < sampleTimes.length - 1 ? sampleTimes[i + 1] - sampleTimes[i] : null\r\n            });\r\n        }\r\n        \r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing text samples:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}