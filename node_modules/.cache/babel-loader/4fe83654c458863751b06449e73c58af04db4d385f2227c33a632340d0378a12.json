{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\n\n    // Find the moov atom which contains all metadata\n    const moov = findAtom(view, 'moov', 0);\n    if (!moov) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n    console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\n\n    // Method 1: Look for udta (user data) -> chpl (chapter list)\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta atom at offset:', udta.offset);\n      const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\n      if (chpl) {\n        console.log('Found chpl atom in udta at offset:', chpl.offset);\n        const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\n        if (chapters.length > 0) {\n          console.log('Successfully extracted', chapters.length, 'chapters from chpl');\n          return chapters;\n        }\n      }\n    }\n\n    // Method 2: Look for chapter track (text track referenced as chapters)\n    const chapters = parseChapterTrack(view, moov.offset, moov.size);\n    if (chapters.length > 0) {\n      console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\n      return chapters;\n    }\n    console.log('No chapters found in file');\n    return [];\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\n\n// Find an atom starting from the beginning of the file\nfunction findAtom(view, atomName, startOffset = 0) {\n  let offset = startOffset;\n  const maxSearch = Math.min(view.byteLength, startOffset + 50000000); // Search up to 50MB\n\n  while (offset < maxSearch - 8) {\n    const size = view.getUint32(offset, false); // Big-endian\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means atom extends to EOF\n    if (size === 1) {\n      // Extended size in next 8 bytes\n      const extSize = view.getBigUint64(offset + 8, false);\n      offset += Number(extSize);\n    } else if (size < 8) {\n      // Invalid size\n      offset += 1;\n    } else {\n      offset += size;\n    }\n  }\n  return null;\n}\n\n// Find an atom within a parent atom's boundaries\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\n  let offset = parentOffset + 8; // Skip parent's size and name\n  const endOffset = parentOffset + parentSize;\n  while (offset < endOffset - 8 && offset < view.byteLength) {\n    const size = view.getUint32(offset, false);\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0 || size === 1) break; // Extended size not common in nested atoms\n    if (size < 8) {\n      offset += 1;\n      continue;\n    }\n    offset += size;\n  }\n  return null;\n}\n\n// Read 4-byte atom name as ASCII string\nfunction readAtomName(view, offset) {\n  if (offset + 4 > view.byteLength) return '';\n  let name = '';\n  for (let i = 0; i < 4; i++) {\n    name += String.fromCharCode(view.getUint8(offset + i));\n  }\n  return name;\n}\n\n// Parse the chpl (chapter list) atom\nfunction parseChplAtom(view, dataOffset, dataSize) {\n  try {\n    // chpl data structure:\n    // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\n    if (dataSize < 12) {\n      console.log('chpl atom too small:', dataSize);\n      return [];\n    }\n    const version = view.getUint8(dataOffset);\n    const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\n\n    console.log('chpl version:', version, 'entry count:', entryCount);\n    if (entryCount === 0 || entryCount > 1000) {\n      console.log('Invalid chapter count:', entryCount);\n      return [];\n    }\n    const chapters = [];\n    let currentOffset = dataOffset + 12;\n    const endOffset = dataOffset + dataSize;\n    for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\n      // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\n      if (currentOffset + 9 > endOffset) break;\n\n      // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\n      const timestampHigh = view.getUint32(currentOffset, false);\n      const timestampLow = view.getUint32(currentOffset + 4, false);\n      const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\n\n      const titleLength = view.getUint8(currentOffset + 8);\n      currentOffset += 9;\n      if (currentOffset + titleLength > endOffset) break;\n      let title = '';\n      if (titleLength > 0) {\n        const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\n        title = new TextDecoder('utf-8').decode(titleBytes);\n      }\n      currentOffset += titleLength;\n      chapters.push({\n        title: title.trim() || `Chapter ${i + 1}`,\n        startTime: timestamp,\n        duration: null\n      });\n    }\n\n    // Calculate durations\n    for (let i = 0; i < chapters.length - 1; i++) {\n      chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\n    }\n    console.log('Parsed chapters:', chapters);\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\n\n// Parse chapter track (text track with chapter markers)\nfunction parseChapterTrack(view, moovOffset, moovSize) {\n  try {\n    let offset = moovOffset + 8; // Skip moov size and name\n    const endOffset = moovOffset + moovSize;\n\n    // Find all trak atoms in moov\n    while (offset < endOffset - 8) {\n      const trak = findAtomInParent(view, 'trak', moovOffset, moovSize);\n      if (!trak) break;\n\n      // Look for text track with chapter references\n      const mdia = findAtomInParent(view, 'mdia', trak.offset, trak.size);\n      if (mdia) {\n        const minf = findAtomInParent(view, 'minf', mdia.offset, mdia.size);\n        if (minf) {\n          const stbl = findAtomInParent(view, 'stbl', minf.offset, minf.size);\n          if (stbl) {\n            const chapters = parseTextSamples(view, stbl.offset, stbl.size, mdia.offset, mdia.size);\n            if (chapters.length > 0) return chapters;\n          }\n        }\n      }\n      offset = trak.offset + trak.size;\n    }\n  } catch (error) {\n    console.error('Error parsing chapter track:', error);\n  }\n  return [];\n}\n\n// Parse text samples from stbl (sample table) atom\nfunction parseTextSamples(view, stblOffset, stblSize, mdiaOffset, mdiaSize) {\n  try {\n    // Get time scale from mdhd (media header)\n    const mdhd = findAtomInParent(view, 'mdhd', mdiaOffset, mdiaSize);\n    let timeScale = 1000; // Default\n\n    if (mdhd) {\n      const version = view.getUint8(mdhd.offset + 8);\n      const timeScaleOffset = version === 1 ? 20 : 12;\n      timeScale = view.getUint32(mdhd.offset + 8 + timeScaleOffset, false);\n      console.log('Time scale:', timeScale);\n    }\n\n    // Get sample times from stts (time-to-sample)\n    const stts = findAtomInParent(view, 'stts', stblOffset, stblSize);\n    if (!stts) return [];\n    const entryCount = view.getUint32(stts.offset + 12, false);\n    console.log('stts entry count:', entryCount);\n    const sampleTimes = [];\n    let currentTime = 0;\n    let dataOffset = stts.offset + 16;\n    for (let i = 0; i < entryCount && dataOffset + 8 <= stts.offset + stts.size; i++) {\n      const sampleCount = view.getUint32(dataOffset, false);\n      const sampleDelta = view.getUint32(dataOffset + 4, false);\n      for (let j = 0; j < sampleCount; j++) {\n        sampleTimes.push(currentTime / timeScale);\n        currentTime += sampleDelta;\n      }\n      dataOffset += 8;\n    }\n\n    // Get sample descriptions from stsd\n    const stsd = findAtomInParent(view, 'stsd', stblOffset, stblSize);\n    if (!stsd) return [];\n\n    // Check if this is a text track\n    const handlerType = readAtomName(view, stsd.offset + 20);\n    console.log('Handler type:', handlerType);\n\n    // Get sample sizes from stsz\n    const stsz = findAtomInParent(view, 'stsz', stblOffset, stblSize);\n    if (!stsz) return [];\n    const sampleCount = view.getUint32(stsz.offset + 16, false);\n    console.log('Sample count:', sampleCount);\n\n    // For now, create generic chapter markers based on sample times\n    const chapters = [];\n    for (let i = 0; i < Math.min(sampleTimes.length, 200); i++) {\n      chapters.push({\n        title: `Chapter ${i + 1}`,\n        startTime: sampleTimes[i],\n        duration: i < sampleTimes.length - 1 ? sampleTimes[i + 1] - sampleTimes[i] : null\n      });\n    }\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing text samples:', error);\n    return [];\n  }\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","console","log","byteLength","moov","findAtom","offset","size","udta","findAtomInParent","chpl","chapters","parseChplAtom","length","parseChapterTrack","error","atomName","startOffset","maxSearch","Math","min","getUint32","name","readAtomName","extSize","getBigUint64","Number","parentOffset","parentSize","endOffset","i","String","fromCharCode","getUint8","dataOffset","dataSize","version","entryCount","currentOffset","timestampHigh","timestampLow","timestamp","titleLength","title","titleBytes","Uint8Array","byteOffset","TextDecoder","decode","push","trim","startTime","duration","moovOffset","moovSize","trak","mdia","minf","stbl","parseTextSamples","stblOffset","stblSize","mdiaOffset","mdiaSize","mdhd","timeScale","timeScaleOffset","stts","sampleTimes","currentTime","sampleCount","sampleDelta","j","stsd","handlerType","stsz","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\r\n        \r\n        // Find the moov atom which contains all metadata\r\n        const moov = findAtom(view, 'moov', 0);\r\n        if (!moov) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\r\n        \r\n        // Method 1: Look for udta (user data) -> chpl (chapter list)\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta atom at offset:', udta.offset);\r\n            const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\r\n            if (chpl) {\r\n                console.log('Found chpl atom in udta at offset:', chpl.offset);\r\n                const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\r\n                if (chapters.length > 0) {\r\n                    console.log('Successfully extracted', chapters.length, 'chapters from chpl');\r\n                    return chapters;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Method 2: Look for chapter track (text track referenced as chapters)\r\n        const chapters = parseChapterTrack(view, moov.offset, moov.size);\r\n        if (chapters.length > 0) {\r\n            console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\r\n            return chapters;\r\n        }\r\n        \r\n        console.log('No chapters found in file');\r\n        return [];\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Find an atom starting from the beginning of the file\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    let offset = startOffset;\r\n    const maxSearch = Math.min(view.byteLength, startOffset + 50000000); // Search up to 50MB\r\n    \r\n    while (offset < maxSearch - 8) {\r\n        const size = view.getUint32(offset, false); // Big-endian\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means atom extends to EOF\r\n        if (size === 1) {\r\n            // Extended size in next 8 bytes\r\n            const extSize = view.getBigUint64(offset + 8, false);\r\n            offset += Number(extSize);\r\n        } else if (size < 8) {\r\n            // Invalid size\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Find an atom within a parent atom's boundaries\r\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\r\n    let offset = parentOffset + 8; // Skip parent's size and name\r\n    const endOffset = parentOffset + parentSize;\r\n    \r\n    while (offset < endOffset - 8 && offset < view.byteLength) {\r\n        const size = view.getUint32(offset, false);\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0 || size === 1) break; // Extended size not common in nested atoms\r\n        if (size < 8) {\r\n            offset += 1;\r\n            continue;\r\n        }\r\n        \r\n        offset += size;\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Read 4-byte atom name as ASCII string\r\nfunction readAtomName(view, offset) {\r\n    if (offset + 4 > view.byteLength) return '';\r\n    let name = '';\r\n    for (let i = 0; i < 4; i++) {\r\n        name += String.fromCharCode(view.getUint8(offset + i));\r\n    }\r\n    return name;\r\n}\r\n\r\n// Parse the chpl (chapter list) atom\r\nfunction parseChplAtom(view, dataOffset, dataSize) {\r\n    try {\r\n        // chpl data structure:\r\n        // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\r\n        if (dataSize < 12) {\r\n            console.log('chpl atom too small:', dataSize);\r\n            return [];\r\n        }\r\n        \r\n        const version = view.getUint8(dataOffset);\r\n        const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\r\n        \r\n        console.log('chpl version:', version, 'entry count:', entryCount);\r\n        \r\n        if (entryCount === 0 || entryCount > 1000) {\r\n            console.log('Invalid chapter count:', entryCount);\r\n            return [];\r\n        }\r\n        \r\n        const chapters = [];\r\n        let currentOffset = dataOffset + 12;\r\n        const endOffset = dataOffset + dataSize;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\r\n            // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\r\n            if (currentOffset + 9 > endOffset) break;\r\n            \r\n            // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\r\n            const timestampHigh = view.getUint32(currentOffset, false);\r\n            const timestampLow = view.getUint32(currentOffset + 4, false);\r\n            const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\r\n            \r\n            const titleLength = view.getUint8(currentOffset + 8);\r\n            currentOffset += 9;\r\n            \r\n            if (currentOffset + titleLength > endOffset) break;\r\n            \r\n            let title = '';\r\n            if (titleLength > 0) {\r\n                const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\r\n                title = new TextDecoder('utf-8').decode(titleBytes);\r\n            }\r\n            \r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title.trim() || `Chapter ${i + 1}`,\r\n                startTime: timestamp,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        // Calculate durations\r\n        for (let i = 0; i < chapters.length - 1; i++) {\r\n            chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\r\n        }\r\n        \r\n        console.log('Parsed chapters:', chapters);\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Parse chapter track (text track with chapter markers)\r\nfunction parseChapterTrack(view, moovOffset, moovSize) {\r\n    try {\r\n        let offset = moovOffset + 8; // Skip moov size and name\r\n        const endOffset = moovOffset + moovSize;\r\n        \r\n        // Find all trak atoms in moov\r\n        while (offset < endOffset - 8) {\r\n            const trak = findAtomInParent(view, 'trak', moovOffset, moovSize);\r\n            if (!trak) break;\r\n            \r\n            // Look for text track with chapter references\r\n            const mdia = findAtomInParent(view, 'mdia', trak.offset, trak.size);\r\n            if (mdia) {\r\n                const minf = findAtomInParent(view, 'minf', mdia.offset, mdia.size);\r\n                if (minf) {\r\n                    const stbl = findAtomInParent(view, 'stbl', minf.offset, minf.size);\r\n                    if (stbl) {\r\n                        const chapters = parseTextSamples(view, stbl.offset, stbl.size, mdia.offset, mdia.size);\r\n                        if (chapters.length > 0) return chapters;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            offset = trak.offset + trak.size;\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter track:', error);\r\n    }\r\n    return [];\r\n}\r\n\r\n// Parse text samples from stbl (sample table) atom\r\nfunction parseTextSamples(view, stblOffset, stblSize, mdiaOffset, mdiaSize) {\r\n    try {\r\n        // Get time scale from mdhd (media header)\r\n        const mdhd = findAtomInParent(view, 'mdhd', mdiaOffset, mdiaSize);\r\n        let timeScale = 1000; // Default\r\n        \r\n        if (mdhd) {\r\n            const version = view.getUint8(mdhd.offset + 8);\r\n            const timeScaleOffset = version === 1 ? 20 : 12;\r\n            timeScale = view.getUint32(mdhd.offset + 8 + timeScaleOffset, false);\r\n            console.log('Time scale:', timeScale);\r\n        }\r\n        \r\n        // Get sample times from stts (time-to-sample)\r\n        const stts = findAtomInParent(view, 'stts', stblOffset, stblSize);\r\n        if (!stts) return [];\r\n        \r\n        const entryCount = view.getUint32(stts.offset + 12, false);\r\n        console.log('stts entry count:', entryCount);\r\n        \r\n        const sampleTimes = [];\r\n        let currentTime = 0;\r\n        let dataOffset = stts.offset + 16;\r\n        \r\n        for (let i = 0; i < entryCount && dataOffset + 8 <= stts.offset + stts.size; i++) {\r\n            const sampleCount = view.getUint32(dataOffset, false);\r\n            const sampleDelta = view.getUint32(dataOffset + 4, false);\r\n            \r\n            for (let j = 0; j < sampleCount; j++) {\r\n                sampleTimes.push(currentTime / timeScale);\r\n                currentTime += sampleDelta;\r\n            }\r\n            \r\n            dataOffset += 8;\r\n        }\r\n        \r\n        // Get sample descriptions from stsd\r\n        const stsd = findAtomInParent(view, 'stsd', stblOffset, stblSize);\r\n        if (!stsd) return [];\r\n        \r\n        // Check if this is a text track\r\n        const handlerType = readAtomName(view, stsd.offset + 20);\r\n        console.log('Handler type:', handlerType);\r\n        \r\n        // Get sample sizes from stsz\r\n        const stsz = findAtomInParent(view, 'stsz', stblOffset, stblSize);\r\n        if (!stsz) return [];\r\n        \r\n        const sampleCount = view.getUint32(stsz.offset + 16, false);\r\n        console.log('Sample count:', sampleCount);\r\n        \r\n        // For now, create generic chapter markers based on sample times\r\n        const chapters = [];\r\n        for (let i = 0; i < Math.min(sampleTimes.length, 200); i++) {\r\n            chapters.push({\r\n                title: `Chapter ${i + 1}`,\r\n                startTime: sampleTimes[i],\r\n                duration: i < sampleTimes.length - 1 ? sampleTimes[i + 1] - sampleTimes[i] : null\r\n            });\r\n        }\r\n        \r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing text samples:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}