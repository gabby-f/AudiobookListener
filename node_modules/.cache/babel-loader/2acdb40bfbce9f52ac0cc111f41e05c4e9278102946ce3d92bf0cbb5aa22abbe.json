{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatroskaParser = void 0;\nconst token_types_1 = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst types_1 = require(\"./types\");\nconst matroskaDtd = require(\"./MatroskaDtd\");\nconst debug = (0, debug_1.default)('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\nclass MatroskaParser extends BasicParser_1.BasicParser {\n  constructor() {\n    super();\n    this.padding = 0;\n    this.parserMap = new Map();\n    this.ebmlMaxIDLength = 4;\n    this.ebmlMaxSizeLength = 8;\n    this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n    this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n    this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n    this.parserMap.set(types_1.DataType.uid, async e => (await this.readUint(e)) === 1);\n    this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n    this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n  }\n  /**\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n   * @param {INativeMetadataCollector} metadata Output\n   * @param {ITokenizer} tokenizer Input\n   * @param {IOptions} options Parsing options\n   */\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    return this;\n  }\n  async parse() {\n    const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n    this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n    if (matroska.segment) {\n      const info = matroska.segment.info;\n      if (info) {\n        const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n        if (typeof info.duration === 'number') {\n          const duration = info.duration * timecodeScale / 1000000000;\n          this.addTag('segment:title', info.title);\n          this.metadata.setFormat('duration', duration);\n        }\n      }\n      const audioTracks = matroska.segment.tracks;\n      if (audioTracks && audioTracks.entries) {\n        audioTracks.entries.forEach(entry => {\n          const stream = {\n            codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n            codecSettings: entry.codecSettings,\n            flagDefault: entry.flagDefault,\n            flagLacing: entry.flagLacing,\n            flagEnabled: entry.flagEnabled,\n            language: entry.language,\n            name: entry.name,\n            type: entry.trackType,\n            audio: entry.audio,\n            video: entry.video\n          };\n          this.metadata.addStreamInfo(stream);\n        });\n        const audioTrack = audioTracks.entries.filter(entry => {\n          return entry.trackType === types_1.TrackType.audio.valueOf();\n        }).reduce((acc, cur) => {\n          if (!acc) {\n            return cur;\n          }\n          if (!acc.flagDefault && cur.flagDefault) {\n            return cur;\n          }\n          if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n            return cur;\n          }\n          return acc;\n        }, null);\n        if (audioTrack) {\n          this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n          this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n          this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n        }\n        if (matroska.segment.tags) {\n          matroska.segment.tags.tag.forEach(tag => {\n            const target = tag.target;\n            const targetType = (target === null || target === void 0 ? void 0 : target.targetTypeValue) ? types_1.TargetType[target.targetTypeValue] : (target === null || target === void 0 ? void 0 : target.targetType) ? target.targetType : 'track';\n            tag.simpleTags.forEach(simpleTag => {\n              const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n              this.addTag(`${targetType}:${simpleTag.name}`, value);\n            });\n          });\n        }\n        if (matroska.segment.attachments) {\n          matroska.segment.attachments.attachedFiles.filter(file => file.mimeType.startsWith('image/')).map(file => {\n            return {\n              data: file.data,\n              format: file.mimeType,\n              description: file.description,\n              name: file.name\n            };\n          }).forEach(picture => {\n            this.addTag('picture', picture);\n          });\n        }\n      }\n    }\n  }\n  async parseContainer(container, posDone, path) {\n    const tree = {};\n    while (this.tokenizer.position < posDone) {\n      let element;\n      try {\n        element = await this.readElement();\n      } catch (error) {\n        if (error.message === 'End-Of-Stream') {\n          break;\n        }\n        throw error;\n      }\n      const type = container[element.id];\n      if (type) {\n        debug(`Element: name=${type.name}, container=${!!type.container}`);\n        if (type.container) {\n          const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\n          if (type.multiple) {\n            if (!tree[type.name]) {\n              tree[type.name] = [];\n            }\n            tree[type.name].push(res);\n          } else {\n            tree[type.name] = res;\n          }\n        } else {\n          tree[type.name] = await this.parserMap.get(type.value)(element);\n        }\n      } else {\n        switch (element.id) {\n          case 0xec:\n            // void\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n            break;\n          default:\n            debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n        }\n      }\n    }\n    return tree;\n  }\n  async readVintData(maxLength) {\n    const msb = await this.tokenizer.peekNumber(token_types_1.UINT8);\n    let mask = 0x80;\n    let oc = 1;\n    // Calculate VINT_WIDTH\n    while ((msb & mask) === 0) {\n      if (oc > maxLength) {\n        throw new Error('VINT value exceeding maximum size');\n      }\n      ++oc;\n      mask >>= 1;\n    }\n    const id = Buffer.alloc(oc);\n    await this.tokenizer.readBuffer(id);\n    return id;\n  }\n  async readElement() {\n    const id = await this.readVintData(this.ebmlMaxIDLength);\n    const lenField = await this.readVintData(this.ebmlMaxSizeLength);\n    lenField[0] ^= 0x80 >> lenField.length - 1;\n    const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n    return {\n      id: id.readUIntBE(0, id.length),\n      len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n    };\n  }\n  isMaxValue(vintData) {\n    if (vintData.length === this.ebmlMaxSizeLength) {\n      for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\n        if (vintData[n] !== 0xff) return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  async readFloat(e) {\n    switch (e.len) {\n      case 0:\n        return 0.0;\n      case 4:\n        return this.tokenizer.readNumber(token_types_1.Float32_BE);\n      case 8:\n        return this.tokenizer.readNumber(token_types_1.Float64_BE);\n      case 10:\n        return this.tokenizer.readNumber(token_types_1.Float64_BE);\n      default:\n        throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n    }\n  }\n  async readFlag(e) {\n    return (await this.readUint(e)) === 1;\n  }\n  async readUint(e) {\n    const buf = await this.readBuffer(e);\n    const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n    return buf.readUIntBE(e.len - nrLen, nrLen);\n  }\n  async readString(e) {\n    const rawString = await this.tokenizer.readToken(new token_types_1.StringType(e.len, 'utf-8'));\n    return rawString.replace(/\\00.*$/g, '');\n  }\n  async readBuffer(e) {\n    const buf = Buffer.alloc(e.len);\n    await this.tokenizer.readBuffer(buf);\n    return buf;\n  }\n  addTag(tagId, value) {\n    this.metadata.addTag('matroska', tagId, value);\n  }\n}\nexports.MatroskaParser = MatroskaParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}