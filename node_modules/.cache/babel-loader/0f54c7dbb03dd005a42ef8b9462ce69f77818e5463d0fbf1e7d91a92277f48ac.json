{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n */export async function extractM4BChapters(file){try{const buffer=await file.arrayBuffer();const view=new DataView(buffer);// Find the moov atom which contains chapter information\nconst moovOffset=findAtom(view,'moov',0);if(moovOffset===-1){console.log('No moov atom found in file');return[];}// Look for the trak atom inside moov\nconst trakOffset=findAtom(view,'trak',moovOffset);if(trakOffset===-1){console.log('No trak atom found');return[];}// Look for chapters in the file\n// Chapters can be in the 'chpl' atom or in specific ilst atoms\nconst chapters=[];// Method 1: Try to find userdata with chapter list\nconst udatOffset=findAtom(view,'udat',moovOffset);if(udatOffset!==-1){const chplOffset=findAtom(view,'chpl',udatOffset);if(chplOffset!==-1){return parseChplAtom(view,chplOffset);}}// Method 2: Try to find chapters in the general moov structure\nreturn parseChaptersFromMoov(view,moovOffset);}catch(error){console.error('Error extracting M4B chapters:',error);return[];}}function findAtom(view,atomName){let startOffset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;const atomCode=stringToByteArray(atomName);const searchLimit=Math.min(view.byteLength,startOffset+100000000);// Limit search to first 100MB\nfor(let i=startOffset;i<searchLimit-3;i++){let found=true;for(let j=0;j<4;j++){if(view.getUint8(i+4+j)!==atomCode[j]){found=false;break;}}if(found){return i;}}return-1;}function stringToByteArray(str){const bytes=[];for(let i=0;i<str.length;i++){bytes.push(str.charCodeAt(i));}return bytes;}function parseChplAtom(view,offset){try{// chpl atom structure:\n// size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\nif(offset+12>=view.byteLength)return[];const version=view.getUint8(offset+8);const flags=view.getUint32(offset+8);const entryCount=view.getUint8(offset+12);const chapters=[];let currentOffset=offset+13;for(let i=0;i<entryCount&&currentOffset<view.byteLength;i++){// Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\nif(currentOffset+5>view.byteLength)break;const startTime=view.getUint32(currentOffset,false)/1000;// Convert to seconds\nconst titleLength=view.getUint8(currentOffset+4);currentOffset+=5;if(currentOffset+titleLength>view.byteLength)break;const titleBytes=new Uint8Array(view.buffer,currentOffset,titleLength);const title=new TextDecoder().decode(titleBytes);currentOffset+=titleLength;chapters.push({title:title||\"Chapter \".concat(i+1),startTime:startTime,duration:null});}if(chapters.length>0){console.log(\"Extracted \".concat(chapters.length,\" chapters from chpl atom\"));}return chapters;}catch(error){console.error('Error parsing chpl atom:',error);return[];}}function parseChaptersFromMoov(view,moovOffset){// This is a fallback parser that looks through the moov structure\n// for chapter information in various formats\nconst chapters=[];try{// Get moov size to know search bounds\nif(moovOffset<4)return[];const moovSize=view.getUint32(moovOffset-4,false);const moovEnd=moovOffset+moovSize;// Search for chapter markers within moov\nfor(let i=moovOffset;i<moovEnd-100;i++){// Look for common chapter patterns\nif(view.getUint32(i,false)===0x6368706c||// 'chpl' in reverse endian\nview.getUint32(i,false)===0x6c706863){// 'lphc' \nconst chapterData=parseChplAtom(view,i);if(chapterData.length>0){return chapterData;}}}}catch(error){console.error('Error parsing moov for chapters:',error);}return chapters;}export function formatTime(seconds){if(!seconds||isNaN(seconds))return'0:00';const hrs=Math.floor(seconds/3600);const mins=Math.floor(seconds%3600/60);const secs=Math.floor(seconds%60);if(hrs>0){return\"\".concat(hrs,\":\").concat(mins.toString().padStart(2,'0'),\":\").concat(secs.toString().padStart(2,'0'));}return\"\".concat(mins,\":\").concat(secs.toString().padStart(2,'0'));}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","moovOffset","findAtom","console","log","trakOffset","chapters","udatOffset","chplOffset","parseChplAtom","parseChaptersFromMoov","error","atomName","startOffset","arguments","length","undefined","atomCode","stringToByteArray","searchLimit","Math","min","byteLength","i","found","j","getUint8","str","bytes","push","charCodeAt","offset","version","flags","getUint32","entryCount","currentOffset","startTime","titleLength","titleBytes","Uint8Array","title","TextDecoder","decode","concat","duration","moovSize","moovEnd","chapterData","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        // Find the moov atom which contains chapter information\r\n        const moovOffset = findAtom(view, 'moov', 0);\r\n        if (moovOffset === -1) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        // Look for the trak atom inside moov\r\n        const trakOffset = findAtom(view, 'trak', moovOffset);\r\n        if (trakOffset === -1) {\r\n            console.log('No trak atom found');\r\n            return [];\r\n        }\r\n        \r\n        // Look for chapters in the file\r\n        // Chapters can be in the 'chpl' atom or in specific ilst atoms\r\n        const chapters = [];\r\n        \r\n        // Method 1: Try to find userdata with chapter list\r\n        const udatOffset = findAtom(view, 'udat', moovOffset);\r\n        if (udatOffset !== -1) {\r\n            const chplOffset = findAtom(view, 'chpl', udatOffset);\r\n            if (chplOffset !== -1) {\r\n                return parseChplAtom(view, chplOffset);\r\n            }\r\n        }\r\n        \r\n        // Method 2: Try to find chapters in the general moov structure\r\n        return parseChaptersFromMoov(view, moovOffset);\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    const atomCode = stringToByteArray(atomName);\r\n    const searchLimit = Math.min(view.byteLength, startOffset + 100000000); // Limit search to first 100MB\r\n    \r\n    for (let i = startOffset; i < searchLimit - 3; i++) {\r\n        let found = true;\r\n        for (let j = 0; j < 4; j++) {\r\n            if (view.getUint8(i + 4 + j) !== atomCode[j]) {\r\n                found = false;\r\n                break;\r\n            }\r\n        }\r\n        if (found) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction stringToByteArray(str) {\r\n    const bytes = [];\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes.push(str.charCodeAt(i));\r\n    }\r\n    return bytes;\r\n}\r\n\r\nfunction parseChplAtom(view, offset) {\r\n    try {\r\n        // chpl atom structure:\r\n        // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\r\n        if (offset + 12 >= view.byteLength) return [];\r\n        \r\n        const version = view.getUint8(offset + 8);\r\n        const flags = view.getUint32(offset + 8);\r\n        const entryCount = view.getUint8(offset + 12);\r\n        \r\n        const chapters = [];\r\n        let currentOffset = offset + 13;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\r\n            // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\r\n            if (currentOffset + 5 > view.byteLength) break;\r\n            \r\n            const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\r\n            const titleLength = view.getUint8(currentOffset + 4);\r\n            currentOffset += 5;\r\n            \r\n            if (currentOffset + titleLength > view.byteLength) break;\r\n            \r\n            const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\r\n            const title = new TextDecoder().decode(titleBytes);\r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title || `Chapter ${i + 1}`,\r\n                startTime: startTime,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        if (chapters.length > 0) {\r\n            console.log(`Extracted ${chapters.length} chapters from chpl atom`);\r\n        }\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction parseChaptersFromMoov(view, moovOffset) {\r\n    // This is a fallback parser that looks through the moov structure\r\n    // for chapter information in various formats\r\n    const chapters = [];\r\n    \r\n    try {\r\n        // Get moov size to know search bounds\r\n        if (moovOffset < 4) return [];\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        // Search for chapter markers within moov\r\n        for (let i = moovOffset; i < moovEnd - 100; i++) {\r\n            // Look for common chapter patterns\r\n            if (view.getUint32(i, false) === 0x6368706c || // 'chpl' in reverse endian\r\n                view.getUint32(i, false) === 0x6c706863) {  // 'lphc' \r\n                const chapterData = parseChplAtom(view, i);\r\n                if (chapterData.length > 0) {\r\n                    return chapterData;\r\n                }\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing moov for chapters:', error);\r\n    }\r\n    \r\n    return chapters;\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}