{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\n\n    // Find the moov atom which contains all metadata\n    const moov = findMoovAtom(view);\n    if (!moov) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n    console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\n\n    // Method 1: Look for udta (user data) -> chpl (chapter list) - HIGHEST PRIORITY\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta atom at offset:', udta.offset);\n\n      // Look directly for chpl in udta (not in meta)\n      const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\n      if (chpl) {\n        console.log('Found chpl atom in udta at offset:', chpl.offset, 'size:', chpl.size);\n        const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\n        if (chapters.length > 0) {\n          console.log('Successfully extracted', chapters.length, 'chapters from chpl');\n          return chapters;\n        }\n      } else {\n        console.log('No chpl atom found in udta');\n      }\n    }\n\n    // Method 2: Look for chapter track (text track referenced as chapters) - FALLBACK ONLY\n    const chapters = parseChapterTrack(view, moov.offset, moov.size);\n    if (chapters.length > 0) {\n      console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\n      return chapters;\n    }\n    console.log('No chapters found in file');\n    return [];\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\n\n/**\r\n * Extract metadata (title, artist, album, cover art) from M4B file\r\n * Reads directly from MP4 atoms like VLC does\r\n */\nexport async function extractM4BMetadata(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B metadata extraction');\n    const metadata = {\n      title: null,\n      artist: null,\n      album: null,\n      albumArtist: null,\n      cover: null,\n      duration: 0\n    };\n\n    // Find the moov atom\n    const moov = findMoovAtom(view);\n    if (!moov) {\n      console.log('No moov atom found');\n      return metadata;\n    }\n\n    // Get duration from mvhd (movie header)\n    const mvhd = findAtomInParent(view, 'mvhd', moov.offset, moov.size);\n    if (mvhd) {\n      const version = view.getUint8(mvhd.offset + 8);\n      let duration, timescale;\n      if (version === 1) {\n        // 64-bit version: skip size(4) + name(4) + version(1) + flags(3) + creation(8) + modification(8) = 28\n        timescale = view.getUint32(mvhd.offset + 28, false);\n        const durationHigh = view.getUint32(mvhd.offset + 32, false);\n        const durationLow = view.getUint32(mvhd.offset + 36, false);\n        duration = (durationHigh * 0x100000000 + durationLow) / timescale;\n      } else {\n        // 32-bit version: skip size(4) + name(4) + version(1) + flags(3) + creation(4) + modification(4) = 20\n        timescale = view.getUint32(mvhd.offset + 20, false);\n        duration = view.getUint32(mvhd.offset + 24, false) / timescale;\n      }\n      metadata.duration = duration;\n      console.log('Duration:', duration, 'seconds', '(', Math.floor(duration / 3600), 'hours', Math.floor(duration % 3600 / 60), 'minutes )');\n    }\n\n    // Look for metadata in udta -> meta -> ilst\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta at offset:', udta.offset, 'size:', udta.size);\n      const meta = findAtomInParent(view, 'meta', udta.offset, udta.size);\n      if (meta) {\n        console.log('Found meta at offset:', meta.offset, 'size:', meta.size);\n        // meta atom has version/flags (4 bytes) after size+name, skip them\n        const ilst = findAtomInParent(view, 'ilst', meta.offset + 4, meta.size - 4);\n        if (ilst) {\n          console.log('Found ilst (item list) at offset:', ilst.offset, 'size:', ilst.size);\n\n          // Parse all metadata items\n          const items = parseIlstAtom(view, ilst.offset, ilst.size);\n\n          // Extract specific metadata fields\n          metadata.title = items['©nam'] || items['title'] || null;\n          metadata.artist = items['©ART'] || items['artist'] || null;\n          metadata.album = items['©alb'] || items['album'] || null;\n          metadata.albumArtist = items['aART'] || null;\n          metadata.cover = items['covr'] || null;\n          console.log('Extracted metadata:', {\n            title: metadata.title,\n            artist: metadata.artist,\n            album: metadata.album,\n            hasCover: !!metadata.cover\n          });\n        } else {\n          console.log('No ilst atom found in meta');\n        }\n      } else {\n        console.log('No meta atom found in udta');\n      }\n    } else {\n      console.log('No udta atom found in moov');\n    }\n    return metadata;\n  } catch (error) {\n    console.error('Error extracting M4B metadata:', error);\n    return {\n      title: null,\n      artist: null,\n      album: null,\n      albumArtist: null,\n      cover: null,\n      duration: 0\n    };\n  }\n}\n\n/**\r\n * Parse ilst (item list) atom to extract all metadata tags\r\n */\nfunction parseIlstAtom(view, ilstOffset, ilstSize) {\n  const metadata = {};\n  let offset = ilstOffset + 8; // Skip ilst size and name\n  const endOffset = ilstOffset + ilstSize;\n  console.log('Parsing ilst from offset:', offset, 'to:', endOffset);\n  try {\n    while (offset < endOffset - 8) {\n      if (offset + 8 > view.byteLength) break;\n      const itemSize = view.getUint32(offset, false);\n      const itemName = readAtomName(view, offset + 4);\n      console.log(`Found item: ${itemName}, size: ${itemSize}`);\n      if (itemSize < 8 || itemSize > ilstSize || itemSize > endOffset - offset) {\n        console.log('Invalid item size, skipping');\n        offset += 8;\n        continue;\n      }\n\n      // Look for data atom inside this item\n      const dataAtom = findAtomInParent(view, 'data', offset, itemSize);\n      if (dataAtom) {\n        const value = parseDataAtom(view, dataAtom.offset, dataAtom.size, itemName);\n        if (value !== null) {\n          metadata[itemName] = value;\n          console.log(`Found metadata: ${itemName} =`, typeof value === 'string' ? value.substring(0, 50) : 'binary data');\n        }\n      }\n      offset += itemSize;\n    }\n  } catch (error) {\n    console.error('Error parsing ilst atom:', error);\n  }\n  return metadata;\n}\n\n/**\r\n * Parse data atom and extract the actual value\r\n */\nfunction parseDataAtom(view, dataOffset, dataSize, itemName) {\n  try {\n    if (dataSize < 16) {\n      console.log(`Data atom for ${itemName} too small:`, dataSize);\n      return null;\n    }\n\n    // data atom structure: size(4) + 'data'(4) + type(4) + locale(4) + value\n    const dataType = view.getUint32(dataOffset + 8, false);\n    const valueOffset = dataOffset + 16;\n    const valueSize = dataSize - 16;\n    console.log(`Parsing ${itemName}: type=${dataType}, valueSize=${valueSize}`);\n\n    // Type 1 = UTF-8 text\n    if (dataType === 1) {\n      const bytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\n      return new TextDecoder('utf-8').decode(bytes).trim();\n    }\n\n    // Type 13 = JPEG image\n    // Type 14 = PNG image\n    if (dataType === 13 || dataType === 14) {\n      if (itemName === 'covr') {\n        const imageBytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\n        const mimeType = dataType === 13 ? 'image/jpeg' : 'image/png';\n        const blob = new Blob([imageBytes], {\n          type: mimeType\n        });\n        return URL.createObjectURL(blob);\n      }\n    }\n\n    // Type 21 = signed integer\n    if (dataType === 21) {\n      if (valueSize === 1) return view.getInt8(valueOffset);\n      if (valueSize === 2) return view.getInt16(valueOffset, false);\n      if (valueSize === 4) return view.getInt32(valueOffset, false);\n    }\n\n    // Type 0 = binary data (also used for integers sometimes)\n    if (dataType === 0) {\n      if (valueSize === 1) return view.getUint8(valueOffset);\n      if (valueSize === 2) return view.getUint16(valueOffset, false);\n      if (valueSize === 4) return view.getUint32(valueOffset, false);\n    }\n    return null;\n  } catch (error) {\n    console.error('Error parsing data atom:', error);\n    return null;\n  }\n}\n\n// Specialized function to find moov atom by scanning top-level atoms\nfunction findMoovAtom(view) {\n  let offset = 0;\n  const fileSize = view.byteLength;\n  console.log('Scanning file for moov atom...');\n\n  // Scan through top-level atoms\n  while (offset < fileSize - 8) {\n    if (offset + 8 > fileSize) break;\n    const size = view.getUint32(offset, false); // Big-endian\n    const name = readAtomName(view, offset + 4);\n    console.log(`Found atom: ${name} at offset ${offset}, size: ${size}`);\n    if (name === 'moov') {\n      console.log('Found moov atom!');\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Handle size edge cases\n    if (size === 0) {\n      // Size 0 means atom extends to EOF\n      console.log('Atom extends to EOF, stopping scan');\n      break;\n    }\n    if (size === 1) {\n      // Extended 64-bit size\n      if (offset + 16 > fileSize) break;\n      const extSize = Number(view.getBigUint64(offset + 8, false));\n      console.log('Extended size:', extSize);\n      offset += extSize;\n    } else if (size < 8) {\n      // Invalid size, skip 1 byte and continue\n      offset += 1;\n    } else {\n      // Normal size\n      offset += size;\n    }\n\n    // Safety: don't infinite loop\n    if (size < 1 && size !== 0) {\n      offset += 8;\n    }\n  }\n  console.log('Finished scanning file, no moov found');\n  return null;\n}\n\n// Find an atom starting from the beginning of the file\nfunction findAtom(view, atomName, startOffset = 0) {\n  let offset = startOffset;\n  // For large files, search first 10MB and last 10MB (moov is often at end in M4B files)\n  const searchSize = 10000000; // 10MB\n  const fileSize = view.byteLength;\n\n  // Search from start\n  const startSearchEnd = Math.min(fileSize, startOffset + searchSize);\n  while (offset < startSearchEnd - 8) {\n    const size = view.getUint32(offset, false); // Big-endian\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      console.log(`Found ${atomName} at offset ${offset} (from start)`);\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means atom extends to EOF\n    if (size === 1) {\n      // Extended size in next 8 bytes\n      const extSize = view.getBigUint64(offset + 8, false);\n      offset += Number(extSize);\n    } else if (size < 8) {\n      // Invalid size\n      offset += 1;\n    } else {\n      offset += size;\n    }\n  }\n\n  // If not found in first part, search last 10MB of file (common for M4B)\n  if (atomName === 'moov' && fileSize > searchSize * 2) {\n    console.log('Searching end of file for moov atom...');\n    offset = Math.max(startOffset, fileSize - searchSize);\n    while (offset < fileSize - 8) {\n      const size = view.getUint32(offset, false);\n      const name = readAtomName(view, offset + 4);\n      if (name === atomName) {\n        console.log(`Found ${atomName} at offset ${offset} (from end)`);\n        return {\n          offset,\n          size\n        };\n      }\n      if (size === 0 || size === 1 || size < 8) {\n        offset += 1;\n      } else {\n        offset += size;\n      }\n    }\n  }\n  return null;\n}\n\n// Find an atom within a parent atom's boundaries\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\n  let offset = parentOffset + 8; // Skip parent's size and name\n  const endOffset = parentOffset + parentSize;\n  while (offset < endOffset - 8 && offset < view.byteLength) {\n    if (offset + 8 > view.byteLength) break;\n    const size = view.getUint32(offset, false);\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means extends to end\n    if (size === 1) {\n      // Extended size (rarely used in nested atoms)\n      if (offset + 16 <= view.byteLength) {\n        const extSize = Number(view.getBigUint64(offset + 8, false));\n        offset += extSize;\n      } else {\n        break;\n      }\n    } else if (size < 8) {\n      // Invalid size, try to skip\n      offset += 1;\n    } else {\n      offset += size;\n    }\n\n    // Safety check to prevent infinite loops\n    if (offset >= endOffset || offset <= parentOffset + 8) break;\n  }\n  return null;\n}\n\n// Read 4-byte atom name as ASCII string\nfunction readAtomName(view, offset) {\n  if (offset + 4 > view.byteLength) return '';\n  let name = '';\n  for (let i = 0; i < 4; i++) {\n    name += String.fromCharCode(view.getUint8(offset + i));\n  }\n  return name;\n}\n\n// Parse the chpl (chapter list) atom\nfunction parseChplAtom(view, dataOffset, dataSize) {\n  try {\n    // chpl data structure:\n    // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\n    if (dataSize < 12) {\n      console.log('chpl atom too small:', dataSize);\n      return [];\n    }\n    const version = view.getUint8(dataOffset);\n    const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\n\n    console.log('chpl version:', version, 'entry count:', entryCount);\n    if (entryCount === 0 || entryCount > 1000) {\n      console.log('Invalid chapter count:', entryCount);\n      return [];\n    }\n    const chapters = [];\n    let currentOffset = dataOffset + 12;\n    const endOffset = dataOffset + dataSize;\n    for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\n      // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\n      if (currentOffset + 9 > endOffset) break;\n\n      // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\n      const timestampHigh = view.getUint32(currentOffset, false);\n      const timestampLow = view.getUint32(currentOffset + 4, false);\n      const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\n\n      const titleLength = view.getUint8(currentOffset + 8);\n      currentOffset += 9;\n      if (currentOffset + titleLength > endOffset) break;\n      let title = '';\n      if (titleLength > 0) {\n        const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\n        title = new TextDecoder('utf-8').decode(titleBytes);\n      }\n      currentOffset += titleLength;\n      chapters.push({\n        title: title.trim() || `Chapter ${i + 1}`,\n        startTime: timestamp,\n        duration: null\n      });\n    }\n\n    // Calculate durations\n    for (let i = 0; i < chapters.length - 1; i++) {\n      chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\n    }\n    console.log('Parsed chapters:', chapters);\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\n\n// Parse chapter track (text track with chapter markers)\nfunction parseChapterTrack(view, moovOffset, moovSize) {\n  try {\n    let offset = moovOffset + 8; // Skip moov size and name\n    const endOffset = moovOffset + moovSize;\n\n    // Find all trak atoms in moov\n    while (offset < endOffset - 8) {\n      const trak = findAtomInParent(view, 'trak', moovOffset, moovSize);\n      if (!trak) break;\n\n      // Look for text track with chapter references\n      const mdia = findAtomInParent(view, 'mdia', trak.offset, trak.size);\n      if (mdia) {\n        const minf = findAtomInParent(view, 'minf', mdia.offset, mdia.size);\n        if (minf) {\n          const stbl = findAtomInParent(view, 'stbl', minf.offset, minf.size);\n          if (stbl) {\n            const chapters = parseTextSamples(view, stbl.offset, stbl.size, mdia.offset, mdia.size);\n            if (chapters.length > 0) return chapters;\n          }\n        }\n      }\n      offset = trak.offset + trak.size;\n    }\n  } catch (error) {\n    console.error('Error parsing chapter track:', error);\n  }\n  return [];\n}\n\n// Parse text samples from stbl (sample table) atom\nfunction parseTextSamples(view, stblOffset, stblSize, mdiaOffset, mdiaSize) {\n  try {\n    // Get time scale from mdhd (media header)\n    const mdhd = findAtomInParent(view, 'mdhd', mdiaOffset, mdiaSize);\n    let timeScale = 1000; // Default\n\n    if (mdhd) {\n      const version = view.getUint8(mdhd.offset + 8);\n      const timeScaleOffset = version === 1 ? 20 : 12;\n      timeScale = view.getUint32(mdhd.offset + 8 + timeScaleOffset, false);\n      console.log('Time scale:', timeScale);\n    }\n\n    // Get sample times from stts (time-to-sample)\n    const stts = findAtomInParent(view, 'stts', stblOffset, stblSize);\n    if (!stts) return [];\n    const entryCount = view.getUint32(stts.offset + 12, false);\n    console.log('stts entry count:', entryCount);\n    const sampleTimes = [];\n    let currentTime = 0;\n    let dataOffset = stts.offset + 16;\n    for (let i = 0; i < entryCount && dataOffset + 8 <= stts.offset + stts.size; i++) {\n      const sampleCount = view.getUint32(dataOffset, false);\n      const sampleDelta = view.getUint32(dataOffset + 4, false);\n      for (let j = 0; j < sampleCount; j++) {\n        sampleTimes.push(currentTime / timeScale);\n        currentTime += sampleDelta;\n      }\n      dataOffset += 8;\n    }\n\n    // Get sample descriptions from stsd\n    const stsd = findAtomInParent(view, 'stsd', stblOffset, stblSize);\n    if (!stsd) return [];\n\n    // Check if this is a text track\n    const handlerType = readAtomName(view, stsd.offset + 20);\n    console.log('Handler type:', handlerType);\n\n    // Only process if this is actually a text track (tx3g, text), not audio (mp4a)\n    if (handlerType !== 'tx3g' && handlerType !== 'text') {\n      console.log('Not a text track, skipping');\n      return [];\n    }\n\n    // Get sample sizes from stsz\n    const stsz = findAtomInParent(view, 'stsz', stblOffset, stblSize);\n    if (!stsz) return [];\n    const sampleCount = view.getUint32(stsz.offset + 16, false);\n    console.log('Sample count:', sampleCount);\n\n    // For text tracks with reasonable sample counts, create chapter markers\n    const chapters = [];\n    const maxChapters = Math.min(sampleTimes.length, 100); // Limit to 100 chapters max\n\n    for (let i = 0; i < maxChapters; i++) {\n      chapters.push({\n        title: `Chapter ${i + 1}`,\n        startTime: sampleTimes[i],\n        duration: i < sampleTimes.length - 1 ? sampleTimes[i + 1] - sampleTimes[i] : null\n      });\n    }\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing text samples:', error);\n    return [];\n  }\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","console","log","byteLength","moov","findMoovAtom","offset","size","udta","findAtomInParent","chpl","chapters","parseChplAtom","length","parseChapterTrack","error","extractM4BMetadata","metadata","title","artist","album","albumArtist","cover","duration","mvhd","version","getUint8","timescale","getUint32","durationHigh","durationLow","Math","floor","meta","ilst","items","parseIlstAtom","hasCover","ilstOffset","ilstSize","endOffset","itemSize","itemName","readAtomName","dataAtom","value","parseDataAtom","substring","dataOffset","dataSize","dataType","valueOffset","valueSize","bytes","Uint8Array","byteOffset","TextDecoder","decode","trim","imageBytes","mimeType","blob","Blob","type","URL","createObjectURL","getInt8","getInt16","getInt32","getUint16","fileSize","name","extSize","Number","getBigUint64","findAtom","atomName","startOffset","searchSize","startSearchEnd","min","max","parentOffset","parentSize","i","String","fromCharCode","entryCount","currentOffset","timestampHigh","timestampLow","timestamp","titleLength","titleBytes","push","startTime","moovOffset","moovSize","trak","mdia","minf","stbl","parseTextSamples","stblOffset","stblSize","mdiaOffset","mdiaSize","mdhd","timeScale","timeScaleOffset","stts","sampleTimes","currentTime","sampleCount","sampleDelta","j","stsd","handlerType","stsz","maxChapters","formatTime","seconds","isNaN","hrs","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\r\n        \r\n        // Find the moov atom which contains all metadata\r\n        const moov = findMoovAtom(view);\r\n        if (!moov) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\r\n        \r\n        // Method 1: Look for udta (user data) -> chpl (chapter list) - HIGHEST PRIORITY\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta atom at offset:', udta.offset);\r\n            \r\n            // Look directly for chpl in udta (not in meta)\r\n            const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\r\n            if (chpl) {\r\n                console.log('Found chpl atom in udta at offset:', chpl.offset, 'size:', chpl.size);\r\n                const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\r\n                if (chapters.length > 0) {\r\n                    console.log('Successfully extracted', chapters.length, 'chapters from chpl');\r\n                    return chapters;\r\n                }\r\n            } else {\r\n                console.log('No chpl atom found in udta');\r\n            }\r\n        }\r\n        \r\n        // Method 2: Look for chapter track (text track referenced as chapters) - FALLBACK ONLY\r\n        const chapters = parseChapterTrack(view, moov.offset, moov.size);\r\n        if (chapters.length > 0) {\r\n            console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\r\n            return chapters;\r\n        }\r\n        \r\n        console.log('No chapters found in file');\r\n        return [];\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Extract metadata (title, artist, album, cover art) from M4B file\r\n * Reads directly from MP4 atoms like VLC does\r\n */\r\nexport async function extractM4BMetadata(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B metadata extraction');\r\n        \r\n        const metadata = {\r\n            title: null,\r\n            artist: null,\r\n            album: null,\r\n            albumArtist: null,\r\n            cover: null,\r\n            duration: 0\r\n        };\r\n        \r\n        // Find the moov atom\r\n        const moov = findMoovAtom(view);\r\n        if (!moov) {\r\n            console.log('No moov atom found');\r\n            return metadata;\r\n        }\r\n        \r\n        // Get duration from mvhd (movie header)\r\n        const mvhd = findAtomInParent(view, 'mvhd', moov.offset, moov.size);\r\n        if (mvhd) {\r\n            const version = view.getUint8(mvhd.offset + 8);\r\n            let duration, timescale;\r\n            \r\n            if (version === 1) {\r\n                // 64-bit version: skip size(4) + name(4) + version(1) + flags(3) + creation(8) + modification(8) = 28\r\n                timescale = view.getUint32(mvhd.offset + 28, false);\r\n                const durationHigh = view.getUint32(mvhd.offset + 32, false);\r\n                const durationLow = view.getUint32(mvhd.offset + 36, false);\r\n                duration = (durationHigh * 0x100000000 + durationLow) / timescale;\r\n            } else {\r\n                // 32-bit version: skip size(4) + name(4) + version(1) + flags(3) + creation(4) + modification(4) = 20\r\n                timescale = view.getUint32(mvhd.offset + 20, false);\r\n                duration = view.getUint32(mvhd.offset + 24, false) / timescale;\r\n            }\r\n            \r\n            metadata.duration = duration;\r\n            console.log('Duration:', duration, 'seconds', '(', Math.floor(duration / 3600), 'hours', Math.floor((duration % 3600) / 60), 'minutes )');\r\n        }\r\n        \r\n        // Look for metadata in udta -> meta -> ilst\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta at offset:', udta.offset, 'size:', udta.size);\r\n            const meta = findAtomInParent(view, 'meta', udta.offset, udta.size);\r\n            if (meta) {\r\n                console.log('Found meta at offset:', meta.offset, 'size:', meta.size);\r\n                // meta atom has version/flags (4 bytes) after size+name, skip them\r\n                const ilst = findAtomInParent(view, 'ilst', meta.offset + 4, meta.size - 4);\r\n                if (ilst) {\r\n                    console.log('Found ilst (item list) at offset:', ilst.offset, 'size:', ilst.size);\r\n                    \r\n                    // Parse all metadata items\r\n                    const items = parseIlstAtom(view, ilst.offset, ilst.size);\r\n                    \r\n                    // Extract specific metadata fields\r\n                    metadata.title = items['©nam'] || items['title'] || null;\r\n                    metadata.artist = items['©ART'] || items['artist'] || null;\r\n                    metadata.album = items['©alb'] || items['album'] || null;\r\n                    metadata.albumArtist = items['aART'] || null;\r\n                    metadata.cover = items['covr'] || null;\r\n                    \r\n                    console.log('Extracted metadata:', {\r\n                        title: metadata.title,\r\n                        artist: metadata.artist,\r\n                        album: metadata.album,\r\n                        hasCover: !!metadata.cover\r\n                    });\r\n                } else {\r\n                    console.log('No ilst atom found in meta');\r\n                }\r\n            } else {\r\n                console.log('No meta atom found in udta');\r\n            }\r\n        } else {\r\n            console.log('No udta atom found in moov');\r\n        }\r\n        \r\n        return metadata;\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B metadata:', error);\r\n        return {\r\n            title: null,\r\n            artist: null,\r\n            album: null,\r\n            albumArtist: null,\r\n            cover: null,\r\n            duration: 0\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Parse ilst (item list) atom to extract all metadata tags\r\n */\r\nfunction parseIlstAtom(view, ilstOffset, ilstSize) {\r\n    const metadata = {};\r\n    let offset = ilstOffset + 8; // Skip ilst size and name\r\n    const endOffset = ilstOffset + ilstSize;\r\n    \r\n    console.log('Parsing ilst from offset:', offset, 'to:', endOffset);\r\n    \r\n    try {\r\n        while (offset < endOffset - 8) {\r\n            if (offset + 8 > view.byteLength) break;\r\n            \r\n            const itemSize = view.getUint32(offset, false);\r\n            const itemName = readAtomName(view, offset + 4);\r\n            \r\n            console.log(`Found item: ${itemName}, size: ${itemSize}`);\r\n            \r\n            if (itemSize < 8 || itemSize > ilstSize || itemSize > (endOffset - offset)) {\r\n                console.log('Invalid item size, skipping');\r\n                offset += 8;\r\n                continue;\r\n            }\r\n            \r\n            // Look for data atom inside this item\r\n            const dataAtom = findAtomInParent(view, 'data', offset, itemSize);\r\n            if (dataAtom) {\r\n                const value = parseDataAtom(view, dataAtom.offset, dataAtom.size, itemName);\r\n                if (value !== null) {\r\n                    metadata[itemName] = value;\r\n                    console.log(`Found metadata: ${itemName} =`, \r\n                        typeof value === 'string' ? value.substring(0, 50) : 'binary data');\r\n                }\r\n            }\r\n            \r\n            offset += itemSize;\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing ilst atom:', error);\r\n    }\r\n    \r\n    return metadata;\r\n}\r\n\r\n/**\r\n * Parse data atom and extract the actual value\r\n */\r\nfunction parseDataAtom(view, dataOffset, dataSize, itemName) {\r\n    try {\r\n        if (dataSize < 16) {\r\n            console.log(`Data atom for ${itemName} too small:`, dataSize);\r\n            return null;\r\n        }\r\n        \r\n        // data atom structure: size(4) + 'data'(4) + type(4) + locale(4) + value\r\n        const dataType = view.getUint32(dataOffset + 8, false);\r\n        const valueOffset = dataOffset + 16;\r\n        const valueSize = dataSize - 16;\r\n        \r\n        console.log(`Parsing ${itemName}: type=${dataType}, valueSize=${valueSize}`);\r\n        \r\n        // Type 1 = UTF-8 text\r\n        if (dataType === 1) {\r\n            const bytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\r\n            return new TextDecoder('utf-8').decode(bytes).trim();\r\n        }\r\n        \r\n        // Type 13 = JPEG image\r\n        // Type 14 = PNG image\r\n        if (dataType === 13 || dataType === 14) {\r\n            if (itemName === 'covr') {\r\n                const imageBytes = new Uint8Array(view.buffer, view.byteOffset + valueOffset, valueSize);\r\n                const mimeType = dataType === 13 ? 'image/jpeg' : 'image/png';\r\n                const blob = new Blob([imageBytes], { type: mimeType });\r\n                return URL.createObjectURL(blob);\r\n            }\r\n        }\r\n        \r\n        // Type 21 = signed integer\r\n        if (dataType === 21) {\r\n            if (valueSize === 1) return view.getInt8(valueOffset);\r\n            if (valueSize === 2) return view.getInt16(valueOffset, false);\r\n            if (valueSize === 4) return view.getInt32(valueOffset, false);\r\n        }\r\n        \r\n        // Type 0 = binary data (also used for integers sometimes)\r\n        if (dataType === 0) {\r\n            if (valueSize === 1) return view.getUint8(valueOffset);\r\n            if (valueSize === 2) return view.getUint16(valueOffset, false);\r\n            if (valueSize === 4) return view.getUint32(valueOffset, false);\r\n        }\r\n        \r\n        return null;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing data atom:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Specialized function to find moov atom by scanning top-level atoms\r\nfunction findMoovAtom(view) {\r\n    let offset = 0;\r\n    const fileSize = view.byteLength;\r\n    \r\n    console.log('Scanning file for moov atom...');\r\n    \r\n    // Scan through top-level atoms\r\n    while (offset < fileSize - 8) {\r\n        if (offset + 8 > fileSize) break;\r\n        \r\n        const size = view.getUint32(offset, false); // Big-endian\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        console.log(`Found atom: ${name} at offset ${offset}, size: ${size}`);\r\n        \r\n        if (name === 'moov') {\r\n            console.log('Found moov atom!');\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Handle size edge cases\r\n        if (size === 0) {\r\n            // Size 0 means atom extends to EOF\r\n            console.log('Atom extends to EOF, stopping scan');\r\n            break;\r\n        }\r\n        \r\n        if (size === 1) {\r\n            // Extended 64-bit size\r\n            if (offset + 16 > fileSize) break;\r\n            const extSize = Number(view.getBigUint64(offset + 8, false));\r\n            console.log('Extended size:', extSize);\r\n            offset += extSize;\r\n        } else if (size < 8) {\r\n            // Invalid size, skip 1 byte and continue\r\n            offset += 1;\r\n        } else {\r\n            // Normal size\r\n            offset += size;\r\n        }\r\n        \r\n        // Safety: don't infinite loop\r\n        if (size < 1 && size !== 0) {\r\n            offset += 8;\r\n        }\r\n    }\r\n    \r\n    console.log('Finished scanning file, no moov found');\r\n    return null;\r\n}\r\n\r\n// Find an atom starting from the beginning of the file\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    let offset = startOffset;\r\n    // For large files, search first 10MB and last 10MB (moov is often at end in M4B files)\r\n    const searchSize = 10000000; // 10MB\r\n    const fileSize = view.byteLength;\r\n    \r\n    // Search from start\r\n    const startSearchEnd = Math.min(fileSize, startOffset + searchSize);\r\n    while (offset < startSearchEnd - 8) {\r\n        const size = view.getUint32(offset, false); // Big-endian\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            console.log(`Found ${atomName} at offset ${offset} (from start)`);\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means atom extends to EOF\r\n        if (size === 1) {\r\n            // Extended size in next 8 bytes\r\n            const extSize = view.getBigUint64(offset + 8, false);\r\n            offset += Number(extSize);\r\n        } else if (size < 8) {\r\n            // Invalid size\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n    }\r\n    \r\n    // If not found in first part, search last 10MB of file (common for M4B)\r\n    if (atomName === 'moov' && fileSize > searchSize * 2) {\r\n        console.log('Searching end of file for moov atom...');\r\n        offset = Math.max(startOffset, fileSize - searchSize);\r\n        while (offset < fileSize - 8) {\r\n            const size = view.getUint32(offset, false);\r\n            const name = readAtomName(view, offset + 4);\r\n            \r\n            if (name === atomName) {\r\n                console.log(`Found ${atomName} at offset ${offset} (from end)`);\r\n                return { offset, size };\r\n            }\r\n            \r\n            if (size === 0 || size === 1 || size < 8) {\r\n                offset += 1;\r\n            } else {\r\n                offset += size;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Find an atom within a parent atom's boundaries\r\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\r\n    let offset = parentOffset + 8; // Skip parent's size and name\r\n    const endOffset = parentOffset + parentSize;\r\n    \r\n    while (offset < endOffset - 8 && offset < view.byteLength) {\r\n        if (offset + 8 > view.byteLength) break;\r\n        \r\n        const size = view.getUint32(offset, false);\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means extends to end\r\n        if (size === 1) {\r\n            // Extended size (rarely used in nested atoms)\r\n            if (offset + 16 <= view.byteLength) {\r\n                const extSize = Number(view.getBigUint64(offset + 8, false));\r\n                offset += extSize;\r\n            } else {\r\n                break;\r\n            }\r\n        } else if (size < 8) {\r\n            // Invalid size, try to skip\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n        \r\n        // Safety check to prevent infinite loops\r\n        if (offset >= endOffset || offset <= parentOffset + 8) break;\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Read 4-byte atom name as ASCII string\r\nfunction readAtomName(view, offset) {\r\n    if (offset + 4 > view.byteLength) return '';\r\n    let name = '';\r\n    for (let i = 0; i < 4; i++) {\r\n        name += String.fromCharCode(view.getUint8(offset + i));\r\n    }\r\n    return name;\r\n}\r\n\r\n// Parse the chpl (chapter list) atom\r\nfunction parseChplAtom(view, dataOffset, dataSize) {\r\n    try {\r\n        // chpl data structure:\r\n        // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\r\n        if (dataSize < 12) {\r\n            console.log('chpl atom too small:', dataSize);\r\n            return [];\r\n        }\r\n        \r\n        const version = view.getUint8(dataOffset);\r\n        const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\r\n        \r\n        console.log('chpl version:', version, 'entry count:', entryCount);\r\n        \r\n        if (entryCount === 0 || entryCount > 1000) {\r\n            console.log('Invalid chapter count:', entryCount);\r\n            return [];\r\n        }\r\n        \r\n        const chapters = [];\r\n        let currentOffset = dataOffset + 12;\r\n        const endOffset = dataOffset + dataSize;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\r\n            // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\r\n            if (currentOffset + 9 > endOffset) break;\r\n            \r\n            // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\r\n            const timestampHigh = view.getUint32(currentOffset, false);\r\n            const timestampLow = view.getUint32(currentOffset + 4, false);\r\n            const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\r\n            \r\n            const titleLength = view.getUint8(currentOffset + 8);\r\n            currentOffset += 9;\r\n            \r\n            if (currentOffset + titleLength > endOffset) break;\r\n            \r\n            let title = '';\r\n            if (titleLength > 0) {\r\n                const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\r\n                title = new TextDecoder('utf-8').decode(titleBytes);\r\n            }\r\n            \r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title.trim() || `Chapter ${i + 1}`,\r\n                startTime: timestamp,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        // Calculate durations\r\n        for (let i = 0; i < chapters.length - 1; i++) {\r\n            chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\r\n        }\r\n        \r\n        console.log('Parsed chapters:', chapters);\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Parse chapter track (text track with chapter markers)\r\nfunction parseChapterTrack(view, moovOffset, moovSize) {\r\n    try {\r\n        let offset = moovOffset + 8; // Skip moov size and name\r\n        const endOffset = moovOffset + moovSize;\r\n        \r\n        // Find all trak atoms in moov\r\n        while (offset < endOffset - 8) {\r\n            const trak = findAtomInParent(view, 'trak', moovOffset, moovSize);\r\n            if (!trak) break;\r\n            \r\n            // Look for text track with chapter references\r\n            const mdia = findAtomInParent(view, 'mdia', trak.offset, trak.size);\r\n            if (mdia) {\r\n                const minf = findAtomInParent(view, 'minf', mdia.offset, mdia.size);\r\n                if (minf) {\r\n                    const stbl = findAtomInParent(view, 'stbl', minf.offset, minf.size);\r\n                    if (stbl) {\r\n                        const chapters = parseTextSamples(view, stbl.offset, stbl.size, mdia.offset, mdia.size);\r\n                        if (chapters.length > 0) return chapters;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            offset = trak.offset + trak.size;\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter track:', error);\r\n    }\r\n    return [];\r\n}\r\n\r\n// Parse text samples from stbl (sample table) atom\r\nfunction parseTextSamples(view, stblOffset, stblSize, mdiaOffset, mdiaSize) {\r\n    try {\r\n        // Get time scale from mdhd (media header)\r\n        const mdhd = findAtomInParent(view, 'mdhd', mdiaOffset, mdiaSize);\r\n        let timeScale = 1000; // Default\r\n        \r\n        if (mdhd) {\r\n            const version = view.getUint8(mdhd.offset + 8);\r\n            const timeScaleOffset = version === 1 ? 20 : 12;\r\n            timeScale = view.getUint32(mdhd.offset + 8 + timeScaleOffset, false);\r\n            console.log('Time scale:', timeScale);\r\n        }\r\n        \r\n        // Get sample times from stts (time-to-sample)\r\n        const stts = findAtomInParent(view, 'stts', stblOffset, stblSize);\r\n        if (!stts) return [];\r\n        \r\n        const entryCount = view.getUint32(stts.offset + 12, false);\r\n        console.log('stts entry count:', entryCount);\r\n        \r\n        const sampleTimes = [];\r\n        let currentTime = 0;\r\n        let dataOffset = stts.offset + 16;\r\n        \r\n        for (let i = 0; i < entryCount && dataOffset + 8 <= stts.offset + stts.size; i++) {\r\n            const sampleCount = view.getUint32(dataOffset, false);\r\n            const sampleDelta = view.getUint32(dataOffset + 4, false);\r\n            \r\n            for (let j = 0; j < sampleCount; j++) {\r\n                sampleTimes.push(currentTime / timeScale);\r\n                currentTime += sampleDelta;\r\n            }\r\n            \r\n            dataOffset += 8;\r\n        }\r\n        \r\n        // Get sample descriptions from stsd\r\n        const stsd = findAtomInParent(view, 'stsd', stblOffset, stblSize);\r\n        if (!stsd) return [];\r\n        \r\n        // Check if this is a text track\r\n        const handlerType = readAtomName(view, stsd.offset + 20);\r\n        console.log('Handler type:', handlerType);\r\n        \r\n        // Only process if this is actually a text track (tx3g, text), not audio (mp4a)\r\n        if (handlerType !== 'tx3g' && handlerType !== 'text') {\r\n            console.log('Not a text track, skipping');\r\n            return [];\r\n        }\r\n        \r\n        // Get sample sizes from stsz\r\n        const stsz = findAtomInParent(view, 'stsz', stblOffset, stblSize);\r\n        if (!stsz) return [];\r\n        \r\n        const sampleCount = view.getUint32(stsz.offset + 16, false);\r\n        console.log('Sample count:', sampleCount);\r\n        \r\n        // For text tracks with reasonable sample counts, create chapter markers\r\n        const chapters = [];\r\n        const maxChapters = Math.min(sampleTimes.length, 100); // Limit to 100 chapters max\r\n        \r\n        for (let i = 0; i < maxChapters; i++) {\r\n            chapters.push({\r\n                title: `Chapter ${i + 1}`,\r\n                startTime: sampleTimes[i],\r\n                duration: i < sampleTimes.length - 1 ? sampleTimes[i + 1] - sampleTimes[i] : null\r\n            });\r\n        }\r\n        \r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing text samples:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}