{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { resolveFetch } from './helper';\nimport { FunctionRegion, FunctionsFetchError, FunctionsHttpError, FunctionsRelayError } from './types';\n/**\n * Client for invoking Supabase Edge Functions.\n */\nexport class FunctionsClient {\n  /**\n   * Creates a new Functions client bound to an Edge Functions URL.\n   *\n   * @example\n   * ```ts\n   * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'\n   *\n   * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {\n   *   headers: { apikey: 'public-anon-key' },\n   *   region: FunctionRegion.UsEast1,\n   * })\n   * ```\n   */\n  constructor(url, {\n    headers = {},\n    customFetch,\n    region = FunctionRegion.Any\n  } = {}) {\n    this.url = url;\n    this.headers = headers;\n    this.region = region;\n    this.fetch = resolveFetch(customFetch);\n  }\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   * @example\n   * ```ts\n   * functions.setAuth(session.access_token)\n   * ```\n   */\n  setAuth(token) {\n    this.headers.Authorization = `Bearer ${token}`;\n  }\n  /**\n   * Invokes a function\n   * @param functionName - The name of the Function to invoke.\n   * @param options - Options for invoking the Function.\n   * @example\n   * ```ts\n   * const { data, error } = await functions.invoke('hello-world', {\n   *   body: { name: 'Ada' },\n   * })\n   * ```\n   */\n  invoke(functionName_1) {\n    return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {\n      var _a;\n      let timeoutId;\n      let timeoutController;\n      try {\n        const {\n          headers,\n          method,\n          body: functionArgs,\n          signal,\n          timeout\n        } = options;\n        let _headers = {};\n        let {\n          region\n        } = options;\n        if (!region) {\n          region = this.region;\n        }\n        // Add region as query parameter using URL API\n        const url = new URL(`${this.url}/${functionName}`);\n        if (region && region !== 'any') {\n          _headers['x-region'] = region;\n          url.searchParams.set('forceFunctionRegion', region);\n        }\n        let body;\n        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {\n          if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n            // will work for File as File inherits Blob\n            // also works for ArrayBuffer as it is the same underlying structure as a Blob\n            _headers['Content-Type'] = 'application/octet-stream';\n            body = functionArgs;\n          } else if (typeof functionArgs === 'string') {\n            // plain string\n            _headers['Content-Type'] = 'text/plain';\n            body = functionArgs;\n          } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n            // don't set content-type headers\n            // Request will automatically add the right boundary value\n            body = functionArgs;\n          } else {\n            // default, assume this is JSON\n            _headers['Content-Type'] = 'application/json';\n            body = JSON.stringify(functionArgs);\n          }\n        } else {\n          // if the Content-Type was supplied, simply set the body\n          body = functionArgs;\n        }\n        // Handle timeout by creating an AbortController\n        let effectiveSignal = signal;\n        if (timeout) {\n          timeoutController = new AbortController();\n          timeoutId = setTimeout(() => timeoutController.abort(), timeout);\n          // If user provided their own signal, we need to respect both\n          if (signal) {\n            effectiveSignal = timeoutController.signal;\n            // If the user's signal is aborted, abort our timeout controller too\n            signal.addEventListener('abort', () => timeoutController.abort());\n          } else {\n            effectiveSignal = timeoutController.signal;\n          }\n        }\n        const response = yield this.fetch(url.toString(), {\n          method: method || 'POST',\n          // headers priority is (high to low):\n          // 1. invoke-level headers\n          // 2. client-level headers\n          // 3. default Content-Type header\n          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n          body,\n          signal: effectiveSignal\n        }).catch(fetchError => {\n          throw new FunctionsFetchError(fetchError);\n        });\n        const isRelayError = response.headers.get('x-relay-error');\n        if (isRelayError && isRelayError === 'true') {\n          throw new FunctionsRelayError(response);\n        }\n        if (!response.ok) {\n          throw new FunctionsHttpError(response);\n        }\n        let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n        let data;\n        if (responseType === 'application/json') {\n          data = yield response.json();\n        } else if (responseType === 'application/octet-stream' || responseType === 'application/pdf') {\n          data = yield response.blob();\n        } else if (responseType === 'text/event-stream') {\n          data = response;\n        } else if (responseType === 'multipart/form-data') {\n          data = yield response.formData();\n        } else {\n          // default to text\n          data = yield response.text();\n        }\n        return {\n          data,\n          error: null,\n          response\n        };\n      } catch (error) {\n        return {\n          data: null,\n          error,\n          response: error instanceof FunctionsHttpError || error instanceof FunctionsRelayError ? error.context : undefined\n        };\n      } finally {\n        // Clear the timeout if it was set\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      }\n    });\n  }\n}\n//# sourceMappingURL=FunctionsClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}