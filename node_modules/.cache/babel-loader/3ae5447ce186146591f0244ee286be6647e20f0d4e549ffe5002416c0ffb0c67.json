{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadStreamTokenizer = void 0;\nconst AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\nconst peek_readable_1 = require(\"peek-readable\");\nconst maxBufferSize = 256000;\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\n  constructor(stream, fileInfo) {\n    super(fileInfo);\n    this.streamReader = new peek_readable_1.StreamReader(stream);\n  }\n  /**\r\n   * Get file information, an HTTP-client may implement this doing a HEAD request\r\n   * @return Promise with file information\r\n   */\n  async getFileInfo() {\n    return this.fileInfo;\n  }\n  /**\r\n   * Read buffer from tokenizer\r\n   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n   * @param options - Read behaviour options\r\n   * @returns Promise with number of bytes read\r\n   */\n  async readBuffer(uint8Array, options) {\n    const normOptions = this.normalizeOptions(uint8Array, options);\n    const skipBytes = normOptions.position - this.position;\n    if (skipBytes > 0) {\n      await this.ignore(skipBytes);\n      return this.readBuffer(uint8Array, options);\n    } else if (skipBytes < 0) {\n      throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n    }\n    if (normOptions.length === 0) {\n      return 0;\n    }\n    const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);\n    this.position += bytesRead;\n    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\n      throw new peek_readable_1.EndOfStreamError();\n    }\n    return bytesRead;\n  }\n  /**\r\n   * Peek (read ahead) buffer from tokenizer\r\n   * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n   * @param options - Read behaviour options\r\n   * @returns Promise with number of bytes peeked\r\n   */\n  async peekBuffer(uint8Array, options) {\n    const normOptions = this.normalizeOptions(uint8Array, options);\n    let bytesRead = 0;\n    if (normOptions.position) {\n      const skipBytes = normOptions.position - this.position;\n      if (skipBytes > 0) {\n        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\n        bytesRead = await this.peekBuffer(skipBuffer, {\n          mayBeLess: normOptions.mayBeLess\n        });\n        uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);\n        return bytesRead - skipBytes;\n      } else if (skipBytes < 0) {\n        throw new Error('Cannot peek from a negative offset in a stream');\n      }\n    }\n    if (normOptions.length > 0) {\n      try {\n        bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);\n      } catch (err) {\n        if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\n          return 0;\n        }\n        throw err;\n      }\n      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {\n        throw new peek_readable_1.EndOfStreamError();\n      }\n    }\n    return bytesRead;\n  }\n  async ignore(length) {\n    // debug(`ignore ${this.position}...${this.position + length - 1}`);\n    const bufSize = Math.min(maxBufferSize, length);\n    const buf = new Uint8Array(bufSize);\n    let totBytesRead = 0;\n    while (totBytesRead < length) {\n      const remaining = length - totBytesRead;\n      const bytesRead = await this.readBuffer(buf, {\n        length: Math.min(bufSize, remaining)\n      });\n      if (bytesRead < 0) {\n        return bytesRead;\n      }\n      totBytesRead += bytesRead;\n    }\n    return totBytesRead;\n  }\n}\nexports.ReadStreamTokenizer = ReadStreamTokenizer;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}