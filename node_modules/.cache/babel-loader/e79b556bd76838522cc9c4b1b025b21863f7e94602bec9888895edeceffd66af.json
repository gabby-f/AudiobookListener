{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\n\n    // Find the moov atom which contains all metadata\n    const moov = findAtom(view, 'moov', 0);\n    if (!moov) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n    console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\n\n    // Method 1: Look for udta (user data) -> chpl (chapter list)\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta atom at offset:', udta.offset);\n      const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\n      if (chpl) {\n        console.log('Found chpl atom in udta at offset:', chpl.offset);\n        const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\n        if (chapters.length > 0) {\n          console.log('Successfully extracted', chapters.length, 'chapters from chpl');\n          return chapters;\n        }\n      }\n    }\n\n    // Method 2: Look for chapter track (text track referenced as chapters)\n    const chapters = parseChapterTrack(view, moov.offset, moov.size);\n    if (chapters.length > 0) {\n      console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\n      return chapters;\n    }\n    console.log('No chapters found in file');\n    return [];\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\n\n// Find an atom starting from the beginning of the file\nfunction findAtom(view, atomName, startOffset = 0) {\n  let offset = startOffset;\n  const maxSearch = Math.min(view.byteLength, startOffset + 50000000); // Search up to 50MB\n\n  while (offset < maxSearch - 8) {\n    const size = view.getUint32(offset, false); // Big-endian\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means atom extends to EOF\n    if (size === 1) {\n      // Extended size in next 8 bytes\n      const extSize = view.getBigUint64(offset + 8, false);\n      offset += Number(extSize);\n    } else if (size < 8) {\n      // Invalid size\n      offset += 1;\n    } else {\n      offset += size;\n    }\n  }\n  return null;\n}\n\n// Find an atom within a parent atom's boundaries\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\n  let offset = parentOffset + 8; // Skip parent's size and name\n  const endOffset = parentOffset + parentSize;\n  while (offset < endOffset - 8 && offset < view.byteLength) {\n    const size = view.getUint32(offset, false);\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0 || size === 1) break; // Extended size not common in nested atoms\n    if (size < 8) {\n      offset += 1;\n      continue;\n    }\n    offset += size;\n  }\n  return null;\n}\n\n// Read 4-byte atom name as ASCII string\nfunction readAtomName(view, offset) {\n  if (offset + 4 > view.byteLength) return '';\n  let name = '';\n  for (let i = 0; i < 4; i++) {\n    name += String.fromCharCode(view.getUint8(offset + i));\n  }\n  return name;\n}\nfunction parseChplAtom(view, offset) {\n  try {\n    // chpl atom structure:\n    // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\n    if (offset + 12 >= view.byteLength) return [];\n    const entryCount = view.getUint8(offset + 12);\n    const chapters = [];\n    let currentOffset = offset + 13;\n    for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\n      // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\n      if (currentOffset + 5 > view.byteLength) break;\n      const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\n      const titleLength = view.getUint8(currentOffset + 4);\n      currentOffset += 5;\n      if (currentOffset + titleLength > view.byteLength) break;\n      const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\n      const title = new TextDecoder().decode(titleBytes);\n      currentOffset += titleLength;\n      chapters.push({\n        title: title || `Chapter ${i + 1}`,\n        startTime: startTime,\n        duration: null\n      });\n    }\n    if (chapters.length > 0) {\n      console.log(`Extracted ${chapters.length} chapters from chpl atom`);\n    }\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\nfunction parseChaptersFromMoov(view, moovOffset) {\n  // This is a fallback parser that looks through the moov structure\n  // for chapter information in various formats\n  const chapters = [];\n  try {\n    // Get moov size to know search bounds\n    if (moovOffset < 4) return [];\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n\n    // Search for chapter markers within moov\n    for (let i = moovOffset; i < moovEnd - 100; i++) {\n      // Look for common chapter patterns\n      if (view.getUint32(i, false) === 0x6368706c ||\n      // 'chpl' in reverse endian\n      view.getUint32(i, false) === 0x6c706863) {\n        // 'lphc' \n        const chapterData = parseChplAtom(view, i);\n        if (chapterData.length > 0) {\n          return chapterData;\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing moov for chapters:', error);\n  }\n  return chapters;\n}\n\n// Parse chapter track (similar to VLC's method for chapter tracks)\nfunction parseChapterTrack(view, moovOffset) {\n  const chapters = [];\n  try {\n    // Look for trak atoms within moov\n    let searchOffset = moovOffset;\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n    while (searchOffset < moovEnd) {\n      const trakOffset = findAtom(view, 'trak', searchOffset);\n      if (trakOffset === -1 || trakOffset >= moovEnd) break;\n\n      // Check if this is a chapter track by looking for tref\n      const trefOffset = findAtom(view, 'tref', trakOffset);\n      if (trefOffset !== -1) {\n        const chapterEntries = parseChapterEntries(view, trakOffset);\n        if (chapterEntries.length > 0) {\n          return chapterEntries;\n        }\n      }\n      searchOffset = trakOffset + 100; // Move forward to find next trak\n    }\n  } catch (error) {\n    console.error('Error parsing chapter track:', error);\n  }\n  return chapters;\n}\nfunction parseChapterEntries(view, trakOffset) {\n  const chapters = [];\n  try {\n    // Look for stbl (sample table) which contains chapter info\n    const stblOffset = findAtom(view, 'stbl', trakOffset);\n    if (stblOffset === -1) return [];\n\n    // Look for stts (time-to-sample) and stsd (sample description)\n    const sttsOffset = findAtom(view, 'stts', stblOffset);\n    const stsdOffset = findAtom(view, 'stsd', stblOffset);\n    if (sttsOffset !== -1 && stsdOffset !== -1) {\n      // Parse sample times from stts\n      const sampleCount = view.getUint32(sttsOffset + 12, false);\n      let currentTime = 0;\n      for (let i = 0; i < Math.min(sampleCount, 100); i++) {\n        const entryOffset = sttsOffset + 16 + i * 8;\n        if (entryOffset + 8 > view.byteLength) break;\n        const sampleCount = view.getUint32(entryOffset, false);\n        const sampleDelta = view.getUint32(entryOffset + 4, false);\n        chapters.push({\n          title: `Chapter ${i + 1}`,\n          startTime: currentTime / 1000,\n          // Convert to seconds\n          duration: null\n        });\n        currentTime += sampleCount * sampleDelta;\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing chapter entries:', error);\n  }\n  return chapters;\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","console","log","byteLength","moov","findAtom","offset","size","udta","findAtomInParent","chpl","chapters","parseChplAtom","length","parseChapterTrack","error","atomName","startOffset","maxSearch","Math","min","getUint32","name","readAtomName","extSize","getBigUint64","Number","parentOffset","parentSize","endOffset","i","String","fromCharCode","getUint8","entryCount","currentOffset","startTime","titleLength","titleBytes","Uint8Array","title","TextDecoder","decode","push","duration","parseChaptersFromMoov","moovOffset","moovSize","moovEnd","chapterData","searchOffset","trakOffset","trefOffset","chapterEntries","parseChapterEntries","stblOffset","sttsOffset","stsdOffset","sampleCount","currentTime","entryOffset","sampleDelta","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\r\n        \r\n        // Find the moov atom which contains all metadata\r\n        const moov = findAtom(view, 'moov', 0);\r\n        if (!moov) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\r\n        \r\n        // Method 1: Look for udta (user data) -> chpl (chapter list)\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta atom at offset:', udta.offset);\r\n            const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\r\n            if (chpl) {\r\n                console.log('Found chpl atom in udta at offset:', chpl.offset);\r\n                const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\r\n                if (chapters.length > 0) {\r\n                    console.log('Successfully extracted', chapters.length, 'chapters from chpl');\r\n                    return chapters;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Method 2: Look for chapter track (text track referenced as chapters)\r\n        const chapters = parseChapterTrack(view, moov.offset, moov.size);\r\n        if (chapters.length > 0) {\r\n            console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\r\n            return chapters;\r\n        }\r\n        \r\n        console.log('No chapters found in file');\r\n        return [];\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Find an atom starting from the beginning of the file\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    let offset = startOffset;\r\n    const maxSearch = Math.min(view.byteLength, startOffset + 50000000); // Search up to 50MB\r\n    \r\n    while (offset < maxSearch - 8) {\r\n        const size = view.getUint32(offset, false); // Big-endian\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means atom extends to EOF\r\n        if (size === 1) {\r\n            // Extended size in next 8 bytes\r\n            const extSize = view.getBigUint64(offset + 8, false);\r\n            offset += Number(extSize);\r\n        } else if (size < 8) {\r\n            // Invalid size\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Find an atom within a parent atom's boundaries\r\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\r\n    let offset = parentOffset + 8; // Skip parent's size and name\r\n    const endOffset = parentOffset + parentSize;\r\n    \r\n    while (offset < endOffset - 8 && offset < view.byteLength) {\r\n        const size = view.getUint32(offset, false);\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0 || size === 1) break; // Extended size not common in nested atoms\r\n        if (size < 8) {\r\n            offset += 1;\r\n            continue;\r\n        }\r\n        \r\n        offset += size;\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Read 4-byte atom name as ASCII string\r\nfunction readAtomName(view, offset) {\r\n    if (offset + 4 > view.byteLength) return '';\r\n    let name = '';\r\n    for (let i = 0; i < 4; i++) {\r\n        name += String.fromCharCode(view.getUint8(offset + i));\r\n    }\r\n    return name;\r\n}\r\n\r\nfunction parseChplAtom(view, offset) {\r\n    try {\r\n        // chpl atom structure:\r\n        // size (4 bytes) + 'chpl' (4 bytes) + version (1 byte) + flags (3 bytes) + entry count (1 byte)\r\n        if (offset + 12 >= view.byteLength) return [];\r\n        \r\n        const entryCount = view.getUint8(offset + 12);\r\n        \r\n        const chapters = [];\r\n        let currentOffset = offset + 13;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < view.byteLength; i++) {\r\n            // Each chapter entry: start time (4 bytes) + title length (1 byte) + title (variable)\r\n            if (currentOffset + 5 > view.byteLength) break;\r\n            \r\n            const startTime = view.getUint32(currentOffset, false) / 1000; // Convert to seconds\r\n            const titleLength = view.getUint8(currentOffset + 4);\r\n            currentOffset += 5;\r\n            \r\n            if (currentOffset + titleLength > view.byteLength) break;\r\n            \r\n            const titleBytes = new Uint8Array(view.buffer, currentOffset, titleLength);\r\n            const title = new TextDecoder().decode(titleBytes);\r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title || `Chapter ${i + 1}`,\r\n                startTime: startTime,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        if (chapters.length > 0) {\r\n            console.log(`Extracted ${chapters.length} chapters from chpl atom`);\r\n        }\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction parseChaptersFromMoov(view, moovOffset) {\r\n    // This is a fallback parser that looks through the moov structure\r\n    // for chapter information in various formats\r\n    const chapters = [];\r\n    \r\n    try {\r\n        // Get moov size to know search bounds\r\n        if (moovOffset < 4) return [];\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        // Search for chapter markers within moov\r\n        for (let i = moovOffset; i < moovEnd - 100; i++) {\r\n            // Look for common chapter patterns\r\n            if (view.getUint32(i, false) === 0x6368706c || // 'chpl' in reverse endian\r\n                view.getUint32(i, false) === 0x6c706863) {  // 'lphc' \r\n                const chapterData = parseChplAtom(view, i);\r\n                if (chapterData.length > 0) {\r\n                    return chapterData;\r\n                }\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing moov for chapters:', error);\r\n    }\r\n    \r\n    return chapters;\r\n}\r\n\r\n// Parse chapter track (similar to VLC's method for chapter tracks)\r\nfunction parseChapterTrack(view, moovOffset) {\r\n    const chapters = [];\r\n    try {\r\n        // Look for trak atoms within moov\r\n        let searchOffset = moovOffset;\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        while (searchOffset < moovEnd) {\r\n            const trakOffset = findAtom(view, 'trak', searchOffset);\r\n            if (trakOffset === -1 || trakOffset >= moovEnd) break;\r\n            \r\n            // Check if this is a chapter track by looking for tref\r\n            const trefOffset = findAtom(view, 'tref', trakOffset);\r\n            if (trefOffset !== -1) {\r\n                const chapterEntries = parseChapterEntries(view, trakOffset);\r\n                if (chapterEntries.length > 0) {\r\n                    return chapterEntries;\r\n                }\r\n            }\r\n            \r\n            searchOffset = trakOffset + 100; // Move forward to find next trak\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter track:', error);\r\n    }\r\n    return chapters;\r\n}\r\n\r\nfunction parseChapterEntries(view, trakOffset) {\r\n    const chapters = [];\r\n    try {\r\n        // Look for stbl (sample table) which contains chapter info\r\n        const stblOffset = findAtom(view, 'stbl', trakOffset);\r\n        if (stblOffset === -1) return [];\r\n        \r\n        // Look for stts (time-to-sample) and stsd (sample description)\r\n        const sttsOffset = findAtom(view, 'stts', stblOffset);\r\n        const stsdOffset = findAtom(view, 'stsd', stblOffset);\r\n        \r\n        if (sttsOffset !== -1 && stsdOffset !== -1) {\r\n            // Parse sample times from stts\r\n            const sampleCount = view.getUint32(sttsOffset + 12, false);\r\n            let currentTime = 0;\r\n            \r\n            for (let i = 0; i < Math.min(sampleCount, 100); i++) {\r\n                const entryOffset = sttsOffset + 16 + (i * 8);\r\n                if (entryOffset + 8 > view.byteLength) break;\r\n                \r\n                const sampleCount = view.getUint32(entryOffset, false);\r\n                const sampleDelta = view.getUint32(entryOffset + 4, false);\r\n                \r\n                chapters.push({\r\n                    title: `Chapter ${i + 1}`,\r\n                    startTime: currentTime / 1000, // Convert to seconds\r\n                    duration: null\r\n                });\r\n                \r\n                currentTime += sampleCount * sampleDelta;\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter entries:', error);\r\n    }\r\n    return chapters;\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAeA,kBAAkBA,CAACC,IAAI,EAAE;EAC3C,IAAI;IACA,MAAMC,MAAM,GAAG,MAAMD,IAAI,CAACE,WAAW,CAAC,CAAC;IACvC,MAAMC,IAAI,GAAG,IAAIC,QAAQ,CAACH,MAAM,CAAC;IAEjCI,OAAO,CAACC,GAAG,CAAC,6CAA6C,EAAEL,MAAM,CAACM,UAAU,CAAC;;IAE7E;IACA,MAAMC,IAAI,GAAGC,QAAQ,CAACN,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;IACtC,IAAI,CAACK,IAAI,EAAE;MACPH,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;MACzC,OAAO,EAAE;IACb;IAEAD,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEE,IAAI,CAACE,MAAM,EAAE,OAAO,EAAEF,IAAI,CAACG,IAAI,CAAC;;IAE1E;IACA,MAAMC,IAAI,GAAGC,gBAAgB,CAACV,IAAI,EAAE,MAAM,EAAEK,IAAI,CAACE,MAAM,EAAEF,IAAI,CAACG,IAAI,CAAC;IACnE,IAAIC,IAAI,EAAE;MACNP,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEM,IAAI,CAACF,MAAM,CAAC;MACtD,MAAMI,IAAI,GAAGD,gBAAgB,CAACV,IAAI,EAAE,MAAM,EAAES,IAAI,CAACF,MAAM,EAAEE,IAAI,CAACD,IAAI,CAAC;MACnE,IAAIG,IAAI,EAAE;QACNT,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAEQ,IAAI,CAACJ,MAAM,CAAC;QAC9D,MAAMK,QAAQ,GAAGC,aAAa,CAACb,IAAI,EAAEW,IAAI,CAACJ,MAAM,GAAG,CAAC,EAAEI,IAAI,CAACH,IAAI,GAAG,CAAC,CAAC;QACpE,IAAII,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;UACrBZ,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAES,QAAQ,CAACE,MAAM,EAAE,oBAAoB,CAAC;UAC5E,OAAOF,QAAQ;QACnB;MACJ;IACJ;;IAEA;IACA,MAAMA,QAAQ,GAAGG,iBAAiB,CAACf,IAAI,EAAEK,IAAI,CAACE,MAAM,EAAEF,IAAI,CAACG,IAAI,CAAC;IAChE,IAAII,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACrBZ,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAES,QAAQ,CAACE,MAAM,EAAE,6BAA6B,CAAC;MACrF,OAAOF,QAAQ;IACnB;IAEAV,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;IACxC,OAAO,EAAE;EAEb,CAAC,CAAC,OAAOa,KAAK,EAAE;IACZd,OAAO,CAACc,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACtD,OAAO,EAAE;EACb;AACJ;;AAEA;AACA,SAASV,QAAQA,CAACN,IAAI,EAAEiB,QAAQ,EAAEC,WAAW,GAAG,CAAC,EAAE;EAC/C,IAAIX,MAAM,GAAGW,WAAW;EACxB,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACrB,IAAI,CAACI,UAAU,EAAEc,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAC;;EAErE,OAAOX,MAAM,GAAGY,SAAS,GAAG,CAAC,EAAE;IAC3B,MAAMX,IAAI,GAAGR,IAAI,CAACsB,SAAS,CAACf,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IAC5C,MAAMgB,IAAI,GAAGC,YAAY,CAACxB,IAAI,EAAEO,MAAM,GAAG,CAAC,CAAC;IAE3C,IAAIgB,IAAI,KAAKN,QAAQ,EAAE;MACnB,OAAO;QAAEV,MAAM;QAAEC;MAAK,CAAC;IAC3B;;IAEA;IACA,IAAIA,IAAI,KAAK,CAAC,EAAE,MAAM,CAAC;IACvB,IAAIA,IAAI,KAAK,CAAC,EAAE;MACZ;MACA,MAAMiB,OAAO,GAAGzB,IAAI,CAAC0B,YAAY,CAACnB,MAAM,GAAG,CAAC,EAAE,KAAK,CAAC;MACpDA,MAAM,IAAIoB,MAAM,CAACF,OAAO,CAAC;IAC7B,CAAC,MAAM,IAAIjB,IAAI,GAAG,CAAC,EAAE;MACjB;MACAD,MAAM,IAAI,CAAC;IACf,CAAC,MAAM;MACHA,MAAM,IAAIC,IAAI;IAClB;EACJ;EAEA,OAAO,IAAI;AACf;;AAEA;AACA,SAASE,gBAAgBA,CAACV,IAAI,EAAEiB,QAAQ,EAAEW,YAAY,EAAEC,UAAU,EAAE;EAChE,IAAItB,MAAM,GAAGqB,YAAY,GAAG,CAAC,CAAC,CAAC;EAC/B,MAAME,SAAS,GAAGF,YAAY,GAAGC,UAAU;EAE3C,OAAOtB,MAAM,GAAGuB,SAAS,GAAG,CAAC,IAAIvB,MAAM,GAAGP,IAAI,CAACI,UAAU,EAAE;IACvD,MAAMI,IAAI,GAAGR,IAAI,CAACsB,SAAS,CAACf,MAAM,EAAE,KAAK,CAAC;IAC1C,MAAMgB,IAAI,GAAGC,YAAY,CAACxB,IAAI,EAAEO,MAAM,GAAG,CAAC,CAAC;IAE3C,IAAIgB,IAAI,KAAKN,QAAQ,EAAE;MACnB,OAAO;QAAEV,MAAM;QAAEC;MAAK,CAAC;IAC3B;;IAEA;IACA,IAAIA,IAAI,KAAK,CAAC,IAAIA,IAAI,KAAK,CAAC,EAAE,MAAM,CAAC;IACrC,IAAIA,IAAI,GAAG,CAAC,EAAE;MACVD,MAAM,IAAI,CAAC;MACX;IACJ;IAEAA,MAAM,IAAIC,IAAI;EAClB;EAEA,OAAO,IAAI;AACf;;AAEA;AACA,SAASgB,YAAYA,CAACxB,IAAI,EAAEO,MAAM,EAAE;EAChC,IAAIA,MAAM,GAAG,CAAC,GAAGP,IAAI,CAACI,UAAU,EAAE,OAAO,EAAE;EAC3C,IAAImB,IAAI,GAAG,EAAE;EACb,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxBR,IAAI,IAAIS,MAAM,CAACC,YAAY,CAACjC,IAAI,CAACkC,QAAQ,CAAC3B,MAAM,GAAGwB,CAAC,CAAC,CAAC;EAC1D;EACA,OAAOR,IAAI;AACf;AAEA,SAASV,aAAaA,CAACb,IAAI,EAAEO,MAAM,EAAE;EACjC,IAAI;IACA;IACA;IACA,IAAIA,MAAM,GAAG,EAAE,IAAIP,IAAI,CAACI,UAAU,EAAE,OAAO,EAAE;IAE7C,MAAM+B,UAAU,GAAGnC,IAAI,CAACkC,QAAQ,CAAC3B,MAAM,GAAG,EAAE,CAAC;IAE7C,MAAMK,QAAQ,GAAG,EAAE;IACnB,IAAIwB,aAAa,GAAG7B,MAAM,GAAG,EAAE;IAE/B,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,UAAU,IAAIC,aAAa,GAAGpC,IAAI,CAACI,UAAU,EAAE2B,CAAC,EAAE,EAAE;MACpE;MACA,IAAIK,aAAa,GAAG,CAAC,GAAGpC,IAAI,CAACI,UAAU,EAAE;MAEzC,MAAMiC,SAAS,GAAGrC,IAAI,CAACsB,SAAS,CAACc,aAAa,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;MAC/D,MAAME,WAAW,GAAGtC,IAAI,CAACkC,QAAQ,CAACE,aAAa,GAAG,CAAC,CAAC;MACpDA,aAAa,IAAI,CAAC;MAElB,IAAIA,aAAa,GAAGE,WAAW,GAAGtC,IAAI,CAACI,UAAU,EAAE;MAEnD,MAAMmC,UAAU,GAAG,IAAIC,UAAU,CAACxC,IAAI,CAACF,MAAM,EAAEsC,aAAa,EAAEE,WAAW,CAAC;MAC1E,MAAMG,KAAK,GAAG,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACJ,UAAU,CAAC;MAClDH,aAAa,IAAIE,WAAW;MAE5B1B,QAAQ,CAACgC,IAAI,CAAC;QACVH,KAAK,EAAEA,KAAK,IAAI,WAAWV,CAAC,GAAG,CAAC,EAAE;QAClCM,SAAS,EAAEA,SAAS;QACpBQ,QAAQ,EAAE;MACd,CAAC,CAAC;IACN;IAEA,IAAIjC,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACrBZ,OAAO,CAACC,GAAG,CAAC,aAAaS,QAAQ,CAACE,MAAM,0BAA0B,CAAC;IACvE;IACA,OAAOF,QAAQ;EAEnB,CAAC,CAAC,OAAOI,KAAK,EAAE;IACZd,OAAO,CAACc,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;IAChD,OAAO,EAAE;EACb;AACJ;AAEA,SAAS8B,qBAAqBA,CAAC9C,IAAI,EAAE+C,UAAU,EAAE;EAC7C;EACA;EACA,MAAMnC,QAAQ,GAAG,EAAE;EAEnB,IAAI;IACA;IACA,IAAImC,UAAU,GAAG,CAAC,EAAE,OAAO,EAAE;IAC7B,MAAMC,QAAQ,GAAGhD,IAAI,CAACsB,SAAS,CAACyB,UAAU,GAAG,CAAC,EAAE,KAAK,CAAC;IACtD,MAAME,OAAO,GAAGF,UAAU,GAAGC,QAAQ;;IAErC;IACA,KAAK,IAAIjB,CAAC,GAAGgB,UAAU,EAAEhB,CAAC,GAAGkB,OAAO,GAAG,GAAG,EAAElB,CAAC,EAAE,EAAE;MAC7C;MACA,IAAI/B,IAAI,CAACsB,SAAS,CAACS,CAAC,EAAE,KAAK,CAAC,KAAK,UAAU;MAAI;MAC3C/B,IAAI,CAACsB,SAAS,CAACS,CAAC,EAAE,KAAK,CAAC,KAAK,UAAU,EAAE;QAAG;QAC5C,MAAMmB,WAAW,GAAGrC,aAAa,CAACb,IAAI,EAAE+B,CAAC,CAAC;QAC1C,IAAImB,WAAW,CAACpC,MAAM,GAAG,CAAC,EAAE;UACxB,OAAOoC,WAAW;QACtB;MACJ;IACJ;EACJ,CAAC,CAAC,OAAOlC,KAAK,EAAE;IACZd,OAAO,CAACc,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;EAC5D;EAEA,OAAOJ,QAAQ;AACnB;;AAEA;AACA,SAASG,iBAAiBA,CAACf,IAAI,EAAE+C,UAAU,EAAE;EACzC,MAAMnC,QAAQ,GAAG,EAAE;EACnB,IAAI;IACA;IACA,IAAIuC,YAAY,GAAGJ,UAAU;IAC7B,MAAMC,QAAQ,GAAGhD,IAAI,CAACsB,SAAS,CAACyB,UAAU,GAAG,CAAC,EAAE,KAAK,CAAC;IACtD,MAAME,OAAO,GAAGF,UAAU,GAAGC,QAAQ;IAErC,OAAOG,YAAY,GAAGF,OAAO,EAAE;MAC3B,MAAMG,UAAU,GAAG9C,QAAQ,CAACN,IAAI,EAAE,MAAM,EAAEmD,YAAY,CAAC;MACvD,IAAIC,UAAU,KAAK,CAAC,CAAC,IAAIA,UAAU,IAAIH,OAAO,EAAE;;MAEhD;MACA,MAAMI,UAAU,GAAG/C,QAAQ,CAACN,IAAI,EAAE,MAAM,EAAEoD,UAAU,CAAC;MACrD,IAAIC,UAAU,KAAK,CAAC,CAAC,EAAE;QACnB,MAAMC,cAAc,GAAGC,mBAAmB,CAACvD,IAAI,EAAEoD,UAAU,CAAC;QAC5D,IAAIE,cAAc,CAACxC,MAAM,GAAG,CAAC,EAAE;UAC3B,OAAOwC,cAAc;QACzB;MACJ;MAEAH,YAAY,GAAGC,UAAU,GAAG,GAAG,CAAC,CAAC;IACrC;EACJ,CAAC,CAAC,OAAOpC,KAAK,EAAE;IACZd,OAAO,CAACc,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;EACxD;EACA,OAAOJ,QAAQ;AACnB;AAEA,SAAS2C,mBAAmBA,CAACvD,IAAI,EAAEoD,UAAU,EAAE;EAC3C,MAAMxC,QAAQ,GAAG,EAAE;EACnB,IAAI;IACA;IACA,MAAM4C,UAAU,GAAGlD,QAAQ,CAACN,IAAI,EAAE,MAAM,EAAEoD,UAAU,CAAC;IACrD,IAAII,UAAU,KAAK,CAAC,CAAC,EAAE,OAAO,EAAE;;IAEhC;IACA,MAAMC,UAAU,GAAGnD,QAAQ,CAACN,IAAI,EAAE,MAAM,EAAEwD,UAAU,CAAC;IACrD,MAAME,UAAU,GAAGpD,QAAQ,CAACN,IAAI,EAAE,MAAM,EAAEwD,UAAU,CAAC;IAErD,IAAIC,UAAU,KAAK,CAAC,CAAC,IAAIC,UAAU,KAAK,CAAC,CAAC,EAAE;MACxC;MACA,MAAMC,WAAW,GAAG3D,IAAI,CAACsB,SAAS,CAACmC,UAAU,GAAG,EAAE,EAAE,KAAK,CAAC;MAC1D,IAAIG,WAAW,GAAG,CAAC;MAEnB,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACC,GAAG,CAACsC,WAAW,EAAE,GAAG,CAAC,EAAE5B,CAAC,EAAE,EAAE;QACjD,MAAM8B,WAAW,GAAGJ,UAAU,GAAG,EAAE,GAAI1B,CAAC,GAAG,CAAE;QAC7C,IAAI8B,WAAW,GAAG,CAAC,GAAG7D,IAAI,CAACI,UAAU,EAAE;QAEvC,MAAMuD,WAAW,GAAG3D,IAAI,CAACsB,SAAS,CAACuC,WAAW,EAAE,KAAK,CAAC;QACtD,MAAMC,WAAW,GAAG9D,IAAI,CAACsB,SAAS,CAACuC,WAAW,GAAG,CAAC,EAAE,KAAK,CAAC;QAE1DjD,QAAQ,CAACgC,IAAI,CAAC;UACVH,KAAK,EAAE,WAAWV,CAAC,GAAG,CAAC,EAAE;UACzBM,SAAS,EAAEuB,WAAW,GAAG,IAAI;UAAE;UAC/Bf,QAAQ,EAAE;QACd,CAAC,CAAC;QAEFe,WAAW,IAAID,WAAW,GAAGG,WAAW;MAC5C;IACJ;EACJ,CAAC,CAAC,OAAO9C,KAAK,EAAE;IACZd,OAAO,CAACc,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;EAC1D;EACA,OAAOJ,QAAQ;AACnB;AAEA,OAAO,SAASmD,UAAUA,CAACC,OAAO,EAAE;EAChC,IAAI,CAACA,OAAO,IAAIC,KAAK,CAACD,OAAO,CAAC,EAAE,OAAO,MAAM;EAC7C,MAAME,GAAG,GAAG9C,IAAI,CAAC+C,KAAK,CAACH,OAAO,GAAG,IAAI,CAAC;EACtC,MAAMI,IAAI,GAAGhD,IAAI,CAAC+C,KAAK,CAAEH,OAAO,GAAG,IAAI,GAAI,EAAE,CAAC;EAC9C,MAAMK,IAAI,GAAGjD,IAAI,CAAC+C,KAAK,CAACH,OAAO,GAAG,EAAE,CAAC;EAErC,IAAIE,GAAG,GAAG,CAAC,EAAE;IACT,OAAO,GAAGA,GAAG,IAAIE,IAAI,CAACE,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,IAAIF,IAAI,CAACC,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;EAC3F;EACA,OAAO,GAAGH,IAAI,IAAIC,IAAI,CAACC,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;AACxD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}