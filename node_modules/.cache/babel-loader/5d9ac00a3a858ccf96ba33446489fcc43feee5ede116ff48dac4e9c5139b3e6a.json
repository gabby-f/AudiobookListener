{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gabby\\\\Documents\\\\Audiobook Listener\\\\src\\\\pages\\\\Audiobook.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { parseBlob } from 'music-metadata-browser';\nimport FileUploader from '@/components/audiobook/FileUploader';\nimport AudiobookPlayer from '@/components/audiobook/AudiobookPlayer';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst STORAGE_KEY = 'audiobook_player_state';\nexport default function AudiobookPage() {\n  _s();\n  const [audioFile, setAudioFile] = useState(null);\n  const [chapters, setChapters] = useState([]);\n  const [bookInfo, setBookInfo] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [savedState, setSavedState] = useState(null);\n\n  // Load saved state on mount\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY);\n    if (saved) {\n      try {\n        const state = JSON.parse(saved);\n        setSavedState(state);\n      } catch (error) {\n        console.error('Error loading saved state:', error);\n      }\n    }\n  }, []);\n  const parseM4BChapters = useCallback(async file => {\n    try {\n      const metadata = await parseBlob(file, {\n        duration: true,\n        skipCovers: false,\n        native: true\n      });\n      const extractedChapters = [];\n      const info = {\n        title: metadata.common.title || file.name.replace(/\\.[^/.]+$/, ''),\n        artist: metadata.common.artist || metadata.common.albumartist || null,\n        album: metadata.common.album || null,\n        cover: null\n      };\n\n      // Extract cover art\n      if (metadata.common.picture && metadata.common.picture.length > 0) {\n        const picture = metadata.common.picture[0];\n        const blob = new Blob([picture.data], {\n          type: picture.format\n        });\n        info.cover = URL.createObjectURL(blob);\n      }\n\n      // Extract chapters from metadata\n      const duration = metadata.format.duration || 0;\n\n      // Check for MP4/M4B chapter atoms\n      if (metadata.format.tagTypes && metadata.format.tagTypes.includes('MP4')) {\n        const mp4Native = metadata.native['MP4'] || [];\n\n        // Look for chapter list atom (chpl)\n        const chplTag = mp4Native.find(tag => tag.id === 'chpl');\n        if (chplTag && Array.isArray(chplTag.value)) {\n          chplTag.value.forEach((chapter, index) => {\n            extractedChapters.push({\n              title: chapter.title || `Chapter ${index + 1}`,\n              startTime: chapter.startTime / 1000,\n              duration: null\n            });\n          });\n        }\n      }\n\n      // Calculate chapter durations\n      if (extractedChapters.length > 0) {\n        extractedChapters.forEach((chapter, index) => {\n          const nextChapter = extractedChapters[index + 1];\n          chapter.duration = nextChapter ? nextChapter.startTime - chapter.startTime : duration - chapter.startTime;\n        });\n        console.log(`Extracted ${extractedChapters.length} chapters from metadata`);\n        return {\n          chapters: extractedChapters,\n          info\n        };\n      }\n\n      // Fallback: create time-based chapters\n      if (duration > 0) {\n        const chapterDuration = 600;\n        const numChapters = Math.ceil(duration / chapterDuration);\n        for (let i = 0; i < numChapters; i++) {\n          const startTime = i * chapterDuration;\n          extractedChapters.push({\n            title: `Part ${i + 1}`,\n            startTime: startTime,\n            duration: Math.min(chapterDuration, duration - startTime)\n          });\n        }\n        console.log('No chapters in metadata, created time-based segments');\n      }\n      return {\n        chapters: extractedChapters,\n        info\n      };\n    } catch (error) {\n      console.error('Error parsing metadata:', error);\n      return {\n        chapters: [],\n        info: {\n          title: file.name.replace(/\\.[^/.]+$/, ''),\n          artist: null,\n          cover: null\n        }\n      };\n    }\n  }, []);\n  const handleFileSelect = useCallback(async file => {\n    setIsLoading(true);\n    try {\n      const {\n        chapters: extractedChapters,\n        info\n      } = await parseM4BChapters(file);\n      setChapters(extractedChapters);\n      setBookInfo(info);\n      setAudioFile(file);\n\n      // Save file info for state restoration\n      const fileInfo = {\n        name: file.name,\n        size: file.size,\n        type: file.type,\n        lastModified: file.lastModified\n      };\n      localStorage.setItem(STORAGE_KEY + '_file', JSON.stringify(fileInfo));\n    } catch (error) {\n      console.error('Error parsing audiobook:', error);\n      setAudioFile(file);\n      setChapters([]);\n      setBookInfo({\n        title: file.name.replace(/\\.[^/.]+$/, '')\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [parseM4BChapters]);\n  const handleClose = useCallback(() => {\n    setAudioFile(null);\n    setChapters([]);\n    setBookInfo(null);\n    setSavedState(null);\n  }, []);\n  const handleSaveState = useCallback(state => {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\",\n    children: !audioFile ? /*#__PURE__*/_jsxDEV(FileUploader, {\n      onFileSelect: handleFileSelect,\n      isLoading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 150,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"h-screen\",\n      children: /*#__PURE__*/_jsxDEV(AudiobookPlayer, {\n        file: audioFile,\n        chapters: chapters,\n        bookInfo: bookInfo,\n        onClose: handleClose,\n        savedState: savedState,\n        onSaveState: handleSaveState\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 156,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 155,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 148,\n    columnNumber: 9\n  }, this);\n}\n_s(AudiobookPage, \"B0PFLbhgWuC6BvbAJ1IX90+9iRE=\");\n_c = AudiobookPage;\nvar _c;\n$RefreshReg$(_c, \"AudiobookPage\");","map":{"version":3,"names":["React","useState","useCallback","useEffect","parseBlob","FileUploader","AudiobookPlayer","jsxDEV","_jsxDEV","STORAGE_KEY","AudiobookPage","_s","audioFile","setAudioFile","chapters","setChapters","bookInfo","setBookInfo","isLoading","setIsLoading","savedState","setSavedState","saved","localStorage","getItem","state","JSON","parse","error","console","parseM4BChapters","file","metadata","duration","skipCovers","native","extractedChapters","info","title","common","name","replace","artist","albumartist","album","cover","picture","length","blob","Blob","data","type","format","URL","createObjectURL","tagTypes","includes","mp4Native","chplTag","find","tag","id","Array","isArray","value","forEach","chapter","index","push","startTime","nextChapter","log","chapterDuration","numChapters","Math","ceil","i","min","handleFileSelect","fileInfo","size","lastModified","setItem","stringify","handleClose","handleSaveState","className","children","onFileSelect","fileName","_jsxFileName","lineNumber","columnNumber","onClose","onSaveState","_c","$RefreshReg$"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/pages/Audiobook.jsx"],"sourcesContent":["import React, { useState, useCallback, useEffect } from 'react';\r\nimport { parseBlob } from 'music-metadata-browser';\r\nimport FileUploader from '@/components/audiobook/FileUploader';\r\nimport AudiobookPlayer from '@/components/audiobook/AudiobookPlayer';\r\n\r\nconst STORAGE_KEY = 'audiobook_player_state';\r\n\r\nexport default function AudiobookPage() {\r\n    const [audioFile, setAudioFile] = useState(null);\r\n    const [chapters, setChapters] = useState([]);\r\n    const [bookInfo, setBookInfo] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [savedState, setSavedState] = useState(null);\r\n\r\n    // Load saved state on mount\r\n    useEffect(() => {\r\n        const saved = localStorage.getItem(STORAGE_KEY);\r\n        if (saved) {\r\n            try {\r\n                const state = JSON.parse(saved);\r\n                setSavedState(state);\r\n            } catch (error) {\r\n                console.error('Error loading saved state:', error);\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    const parseM4BChapters = useCallback(async (file) => {\r\n        try {\r\n            const metadata = await parseBlob(file, { \r\n                duration: true,\r\n                skipCovers: false,\r\n                native: true\r\n            });\r\n            \r\n            const extractedChapters = [];\r\n            const info = {\r\n                title: metadata.common.title || file.name.replace(/\\.[^/.]+$/, ''),\r\n                artist: metadata.common.artist || metadata.common.albumartist || null,\r\n                album: metadata.common.album || null,\r\n                cover: null\r\n            };\r\n\r\n            // Extract cover art\r\n            if (metadata.common.picture && metadata.common.picture.length > 0) {\r\n                const picture = metadata.common.picture[0];\r\n                const blob = new Blob([picture.data], { type: picture.format });\r\n                info.cover = URL.createObjectURL(blob);\r\n            }\r\n\r\n            // Extract chapters from metadata\r\n            const duration = metadata.format.duration || 0;\r\n            \r\n            // Check for MP4/M4B chapter atoms\r\n            if (metadata.format.tagTypes && metadata.format.tagTypes.includes('MP4')) {\r\n                const mp4Native = metadata.native['MP4'] || [];\r\n                \r\n                // Look for chapter list atom (chpl)\r\n                const chplTag = mp4Native.find(tag => tag.id === 'chpl');\r\n                if (chplTag && Array.isArray(chplTag.value)) {\r\n                    chplTag.value.forEach((chapter, index) => {\r\n                        extractedChapters.push({\r\n                            title: chapter.title || `Chapter ${index + 1}`,\r\n                            startTime: chapter.startTime / 1000,\r\n                            duration: null\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Calculate chapter durations\r\n            if (extractedChapters.length > 0) {\r\n                extractedChapters.forEach((chapter, index) => {\r\n                    const nextChapter = extractedChapters[index + 1];\r\n                    chapter.duration = nextChapter \r\n                        ? nextChapter.startTime - chapter.startTime\r\n                        : duration - chapter.startTime;\r\n                });\r\n                \r\n                console.log(`Extracted ${extractedChapters.length} chapters from metadata`);\r\n                return { chapters: extractedChapters, info };\r\n            }\r\n\r\n            // Fallback: create time-based chapters\r\n            if (duration > 0) {\r\n                const chapterDuration = 600;\r\n                const numChapters = Math.ceil(duration / chapterDuration);\r\n                \r\n                for (let i = 0; i < numChapters; i++) {\r\n                    const startTime = i * chapterDuration;\r\n                    extractedChapters.push({\r\n                        title: `Part ${i + 1}`,\r\n                        startTime: startTime,\r\n                        duration: Math.min(chapterDuration, duration - startTime)\r\n                    });\r\n                }\r\n                \r\n                console.log('No chapters in metadata, created time-based segments');\r\n            }\r\n\r\n            return { chapters: extractedChapters, info };\r\n            \r\n        } catch (error) {\r\n            console.error('Error parsing metadata:', error);\r\n            return { chapters: [], info: { title: file.name.replace(/\\.[^/.]+$/, ''), artist: null, cover: null } };\r\n        }\r\n    }, []);\r\n\r\n    const handleFileSelect = useCallback(async (file) => {\r\n        setIsLoading(true);\r\n        \r\n        try {\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo(info);\r\n            setAudioFile(file);\r\n            \r\n            // Save file info for state restoration\r\n            const fileInfo = {\r\n                name: file.name,\r\n                size: file.size,\r\n                type: file.type,\r\n                lastModified: file.lastModified\r\n            };\r\n            localStorage.setItem(STORAGE_KEY + '_file', JSON.stringify(fileInfo));\r\n        } catch (error) {\r\n            console.error('Error parsing audiobook:', error);\r\n            setAudioFile(file);\r\n            setChapters([]);\r\n            setBookInfo({ title: file.name.replace(/\\.[^/.]+$/, '') });\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleClose = useCallback(() => {\r\n        setAudioFile(null);\r\n        setChapters([]);\r\n        setBookInfo(null);\r\n        setSavedState(null);\r\n    }, []);\r\n\r\n    const handleSaveState = useCallback((state) => {\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\r\n    }, []);\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\">\r\n            {!audioFile ? (\r\n                <FileUploader \r\n                    onFileSelect={handleFileSelect} \r\n                    isLoading={isLoading}\r\n                />\r\n            ) : (\r\n                <div className=\"h-screen\">\r\n                    <AudiobookPlayer\r\n                        file={audioFile}\r\n                        chapters={chapters}\r\n                        bookInfo={bookInfo}\r\n                        onClose={handleClose}\r\n                        savedState={savedState}\r\n                        onSaveState={handleSaveState}\r\n                    />\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}