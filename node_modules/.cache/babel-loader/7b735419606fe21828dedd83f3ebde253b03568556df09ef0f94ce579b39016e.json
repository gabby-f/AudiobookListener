{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\nconst Token = require(\"token-types\");\nconst FourCC_1 = require(\"../common/FourCC\");\nvar DataType;\n(function (DataType) {\n  DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n  DataType[DataType[\"binary\"] = 1] = \"binary\";\n  DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n  DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexports.DescriptorParser = {\n  len: 52,\n  get: (buf, off) => {\n    return {\n      // should equal 'MAC '\n      ID: FourCC_1.FourCcToken.get(buf, off),\n      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n      version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n      // the number of descriptor bytes (allows later expansion of this header)\n      descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n      // the number of header APE_HEADER bytes\n      headerBytes: Token.UINT32_LE.get(buf, off + 12),\n      // the number of header APE_HEADER bytes\n      seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n      // the number of header data bytes (from original file)\n      headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n      // the number of bytes of APE frame data\n      apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n      // the high order number of APE frame data bytes\n      apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n      // the terminating data of the file (not including tag data)\n      terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n      // the MD5 hash of the file (see notes for usage... it's a little tricky)\n      fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n    };\n  }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexports.Header = {\n  len: 24,\n  get: (buf, off) => {\n    return {\n      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n      compressionLevel: Token.UINT16_LE.get(buf, off),\n      // any format flags (for future use)\n      formatFlags: Token.UINT16_LE.get(buf, off + 2),\n      // the number of audio blocks in one frame\n      blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n      // the number of audio blocks in the final frame\n      finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n      // the total number of frames\n      totalFrames: Token.UINT32_LE.get(buf, off + 12),\n      // the bits per sample (typically 16)\n      bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n      // the number of channels (1 or 2)\n      channel: Token.UINT16_LE.get(buf, off + 18),\n      // the sample rate (typically 44100)\n      sampleRate: Token.UINT32_LE.get(buf, off + 20)\n    };\n  }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexports.TagFooter = {\n  len: 32,\n  get: (buf, off) => {\n    return {\n      // should equal 'APETAGEX'\n      ID: new Token.StringType(8, 'ascii').get(buf, off),\n      // equals CURRENT_APE_TAG_VERSION\n      version: Token.UINT32_LE.get(buf, off + 8),\n      // the complete size of the tag, including this footer (excludes header)\n      size: Token.UINT32_LE.get(buf, off + 12),\n      // the number of fields in the tag\n      fields: Token.UINT32_LE.get(buf, off + 16),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n    };\n  }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexports.TagItemHeader = {\n  len: 8,\n  get: (buf, off) => {\n    return {\n      // Length of assigned value in bytes\n      size: Token.UINT32_LE.get(buf, off),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n    };\n  }\n};\nconst TagField = footer => {\n  return new Token.Uint8ArrayType(footer.size - exports.TagFooter.len);\n};\nexports.TagField = TagField;\nfunction parseTagFlags(flags) {\n  return {\n    containsHeader: isBitSet(flags, 31),\n    containsFooter: isBitSet(flags, 30),\n    isHeader: isBitSet(flags, 31),\n    readOnly: isBitSet(flags, 0),\n    dataType: (flags & 6) >> 1\n  };\n}\nexports.parseTagFlags = parseTagFlags;\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nfunction isBitSet(num, bit) {\n  return (num & 1 << bit) !== 0;\n}\nexports.isBitSet = isBitSet;\n//# sourceMappingURL=APEv2Token.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}