{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdentificationHeader = exports.CommonHeader = exports.VorbisPictureToken = void 0;\nconst Token = require(\"token-types\");\nconst ID3v2Token_1 = require(\"../../id3v2/ID3v2Token\");\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nclass VorbisPictureToken {\n  static fromBase64(base64str) {\n    return this.fromBuffer(Buffer.from(base64str, 'base64'));\n  }\n  static fromBuffer(buffer) {\n    const pic = new VorbisPictureToken(buffer.length);\n    return pic.get(buffer, 0);\n  }\n  constructor(len) {\n    this.len = len;\n  }\n  get(buffer, offset) {\n    const type = ID3v2Token_1.AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n    const mimeLen = Token.UINT32_BE.get(buffer, offset += 4);\n    const format = buffer.toString('utf-8', offset += 4, offset + mimeLen);\n    const descLen = Token.UINT32_BE.get(buffer, offset += mimeLen);\n    const description = buffer.toString('utf-8', offset += 4, offset + descLen);\n    const width = Token.UINT32_BE.get(buffer, offset += descLen);\n    const height = Token.UINT32_BE.get(buffer, offset += 4);\n    const colour_depth = Token.UINT32_BE.get(buffer, offset += 4);\n    const indexed_color = Token.UINT32_BE.get(buffer, offset += 4);\n    const picDataLen = Token.UINT32_BE.get(buffer, offset += 4);\n    const data = Buffer.from(buffer.slice(offset += 4, offset + picDataLen));\n    return {\n      type,\n      format,\n      description,\n      width,\n      height,\n      colour_depth,\n      indexed_color,\n      data\n    };\n  }\n}\nexports.VorbisPictureToken = VorbisPictureToken;\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexports.CommonHeader = {\n  len: 7,\n  get: (buf, off) => {\n    return {\n      packetType: buf.readUInt8(off),\n      vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n    };\n  }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexports.IdentificationHeader = {\n  len: 23,\n  get: (uint8Array, off) => {\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset);\n    return {\n      version: dataView.getUint32(off + 0, true),\n      channelMode: dataView.getUint8(off + 4),\n      sampleRate: dataView.getUint32(off + 5, true),\n      bitrateMax: dataView.getUint32(off + 9, true),\n      bitrateNominal: dataView.getUint32(off + 13, true),\n      bitrateMin: dataView.getUint32(off + 17, true)\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}