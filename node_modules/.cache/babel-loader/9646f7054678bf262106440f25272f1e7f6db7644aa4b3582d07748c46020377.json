{"ast":null,"code":"import React,{useState,useCallback,useEffect}from'react';import{parseBlob}from'music-metadata-browser';import{extractM4BChapters}from'../utils/m4bParser';import FileUploader from'../Components/audiobook/FileUploader';import AudiobookPlayer from'../Components/audiobook/AudiobookPlayer';import{saveFile,getFile,deleteFile}from'../utils/idbFileStore';import{jsx as _jsx}from\"react/jsx-runtime\";const STORAGE_KEY='audiobook_player_state';export default function AudiobookPage(){const[audioFile,setAudioFile]=useState(null);const[chapters,setChapters]=useState([]);const[bookInfo,setBookInfo]=useState(null);const[isLoading,setIsLoading]=useState(false);const[savedState,setSavedState]=useState(null);const[autoPlayRestore,setAutoPlayRestore]=useState(false);const[restoreTitle,setRestoreTitle]=useState(null);// Load saved state on mount\nuseEffect(()=>{const saved=localStorage.getItem(STORAGE_KEY);if(saved){try{const state=JSON.parse(saved);setSavedState(state);}catch(error){console.error('Error loading saved state:',error);}}},[]);// Try to restore previously uploaded file from IndexedDB\nuseEffect(()=>{const tryRestoreFile=async()=>{try{const fileInfoRaw=localStorage.getItem(STORAGE_KEY+'_file');if(!fileInfoRaw)return;const fileInfo=JSON.parse(fileInfoRaw);const blob=await getFile('audio');if(blob){// Recreate a File from blob so components expecting File work\nconst restored=new File([blob],fileInfo.name,{type:fileInfo.type||blob.type||'application/octet-stream',lastModified:fileInfo.lastModified||Date.now()});// Set file and parse chapters\n// Indicate this was a restore so the player may attempt autoplay\nsetAutoPlayRestore(true);setRestoreTitle(fileInfo.name||restored.name||'Restored book');setAudioFile(restored);const{chapters:extractedChapters,info}=await parseM4BChapters(restored);setChapters(extractedChapters);setBookInfo(info);}}catch(err){console.warn('No stored file to restore or restore failed:',err);}};tryRestoreFile();},[parseM4BChapters]);const parseM4BChapters=useCallback(async file=>{try{const extractedChapters=[];const info={title:null,artist:null,album:null,cover:null};// First, try to extract chapters using binary parsing (like VLC)\nconsole.log('Attempting to extract chapters from M4B file...');const binaryChapters=await extractM4BChapters(file);if(binaryChapters.length>0){console.log(\"Successfully extracted \".concat(binaryChapters.length,\" chapters from binary parsing\"));extractedChapters.push(...binaryChapters);}// Also get metadata using music-metadata for title, artist, cover, etc.\nlet metadata;try{metadata=await parseBlob(file,{duration:true,skipCovers:false,native:true});// Extract basic info\ninfo.title=metadata.common.title||file.name.replace(/\\.[^/.]+$/,'');info.artist=metadata.common.artist||metadata.common.albumartist||null;info.album=metadata.common.album||null;// Extract cover art\nif(metadata.common.picture&&metadata.common.picture.length>0){const picture=metadata.common.picture[0];const blob=new Blob([picture.data],{type:picture.format});info.cover=URL.createObjectURL(blob);}const duration=metadata.format.duration||0;// If binary parsing didn't find chapters, try metadata\nif(extractedChapters.length===0){console.log('No chapters from binary parsing, trying music-metadata...');if(metadata.native){// Check all native keys for chapter data\nfor(const key in metadata.native){const items=metadata.native[key];if(Array.isArray(items)){const chapterItems=items.filter(tag=>tag.id==='chpl'||tag.id==='chapters'||tag.mean&&tag.mean.includes('chapter'));if(chapterItems.length>0){console.log(\"Found chapter items in native.\".concat(key));for(const chplData of chapterItems){let chapters=[];if(Array.isArray(chplData.value)){chapters=chplData.value;}else if(chplData.value&&typeof chplData.value==='object'){chapters=Array.isArray(chplData.value.chapters)?chplData.value.chapters:Object.values(chplData.value);}for(const chapter of chapters){if(chapter&&(chapter.title||chapter.startTime!==undefined)){extractedChapters.push({title:chapter.title||chapter.name||\"Chapter \".concat(extractedChapters.length+1),startTime:(chapter.startTime||chapter.start||0)/1000,duration:null});}}}}}}}}// Calculate chapter durations if chapters were found\nif(extractedChapters.length>0){extractedChapters.sort((a,b)=>a.startTime-b.startTime);extractedChapters.forEach((chapter,index)=>{const nextChapter=extractedChapters[index+1];chapter.duration=nextChapter?nextChapter.startTime-chapter.startTime:duration-chapter.startTime;});console.log(\"Successfully extracted \".concat(extractedChapters.length,\" chapters\"));return{chapters:extractedChapters,info};}// Fallback: create time-based chapters if no chapters found\nif(duration>0){const chapterDuration=600;// 10 minute segments\nconst numChapters=Math.ceil(duration/chapterDuration);for(let i=0;i<numChapters;i++){const startTime=i*chapterDuration;extractedChapters.push({title:\"Part \".concat(i+1),startTime:startTime,duration:Math.min(chapterDuration,duration-startTime)});}console.log(\"No chapters found. Created \".concat(extractedChapters.length,\" time-based segments\"));}}catch(metadataError){console.error('Error parsing metadata:',metadataError);info.title=file.name.replace(/\\.[^/.]+$/,'');}return{chapters:extractedChapters,info};}catch(error){console.error('Error parsing M4B file:',error);return{chapters:[],info:{title:file.name.replace(/\\.[^/.]+$/,''),artist:null,album:null,cover:null}};}},[]);const handleFileSelect=useCallback(async file=>{setIsLoading(true);try{const{chapters:extractedChapters,info}=await parseM4BChapters(file);setChapters(extractedChapters);setBookInfo(info);setAudioFile(file);// Save file info for state restoration\nconst fileInfo={name:file.name,size:file.size,type:file.type,lastModified:file.lastModified};localStorage.setItem(STORAGE_KEY+'_file',JSON.stringify(fileInfo));// Persist file blob in IndexedDB so we can restore across reloads\ntry{await saveFile('audio',file);}catch(idbErr){console.warn('Failed to save file to IndexedDB:',idbErr);}}catch(error){console.error('Error parsing audiobook:',error);setAudioFile(file);setChapters([]);setBookInfo({title:file.name.replace(/\\.[^/.]+$/,'')});}finally{setIsLoading(false);}},[parseM4BChapters]);const handleClose=useCallback(()=>{setAudioFile(null);setChapters([]);setBookInfo(null);setSavedState(null);// Remove persisted file and info\ntry{localStorage.removeItem(STORAGE_KEY+'_file');deleteFile('audio').catch(()=>{});}catch(err){// ignore\n}},[]);const handleSaveState=useCallback(state=>{localStorage.setItem(STORAGE_KEY,JSON.stringify(state));},[]);return/*#__PURE__*/_jsx(\"div\",{className:\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\",children:!audioFile?/*#__PURE__*/_jsx(FileUploader,{onFileSelect:handleFileSelect,isLoading:isLoading}):/*#__PURE__*/_jsx(\"div\",{className:\"h-screen\",children:/*#__PURE__*/_jsx(AudiobookPlayer,{file:audioFile,chapters:chapters,bookInfo:bookInfo,onClose:handleClose,savedState:savedState,onSaveState:handleSaveState,autoPlayRestore:autoPlayRestore,onAutoPlayHandled:()=>{setAutoPlayRestore(false);setRestoreTitle(null);},restoreTitle:restoreTitle})})});}","map":{"version":3,"names":["React","useState","useCallback","useEffect","parseBlob","extractM4BChapters","FileUploader","AudiobookPlayer","saveFile","getFile","deleteFile","jsx","_jsx","STORAGE_KEY","AudiobookPage","audioFile","setAudioFile","chapters","setChapters","bookInfo","setBookInfo","isLoading","setIsLoading","savedState","setSavedState","autoPlayRestore","setAutoPlayRestore","restoreTitle","setRestoreTitle","saved","localStorage","getItem","state","JSON","parse","error","console","tryRestoreFile","fileInfoRaw","fileInfo","blob","restored","File","name","type","lastModified","Date","now","extractedChapters","info","parseM4BChapters","err","warn","file","title","artist","album","cover","log","binaryChapters","length","concat","push","metadata","duration","skipCovers","native","common","replace","albumartist","picture","Blob","data","format","URL","createObjectURL","key","items","Array","isArray","chapterItems","filter","tag","id","mean","includes","chplData","value","Object","values","chapter","startTime","undefined","start","sort","a","b","forEach","index","nextChapter","chapterDuration","numChapters","Math","ceil","i","min","metadataError","handleFileSelect","size","setItem","stringify","idbErr","handleClose","removeItem","catch","handleSaveState","className","children","onFileSelect","onClose","onSaveState","onAutoPlayHandled"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/pages/Audiobook.jsx"],"sourcesContent":["import React, { useState, useCallback, useEffect } from 'react';\r\nimport { parseBlob } from 'music-metadata-browser';\r\nimport { extractM4BChapters } from '../utils/m4bParser';\r\nimport FileUploader from '../Components/audiobook/FileUploader';\r\nimport AudiobookPlayer from '../Components/audiobook/AudiobookPlayer';\r\nimport { saveFile, getFile, deleteFile } from '../utils/idbFileStore';\r\n\r\nconst STORAGE_KEY = 'audiobook_player_state';\r\n\r\nexport default function AudiobookPage() {\r\n    const [audioFile, setAudioFile] = useState(null);\r\n    const [chapters, setChapters] = useState([]);\r\n    const [bookInfo, setBookInfo] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [savedState, setSavedState] = useState(null);\r\n    const [autoPlayRestore, setAutoPlayRestore] = useState(false);\r\n    const [restoreTitle, setRestoreTitle] = useState(null);\r\n\r\n    // Load saved state on mount\r\n    useEffect(() => {\r\n        const saved = localStorage.getItem(STORAGE_KEY);\r\n        if (saved) {\r\n            try {\r\n                const state = JSON.parse(saved);\r\n                setSavedState(state);\r\n            } catch (error) {\r\n                console.error('Error loading saved state:', error);\r\n            }\r\n        }\r\n    }, []);\r\n\r\n\r\n\r\n    // Try to restore previously uploaded file from IndexedDB\r\n    useEffect(() => {\r\n        const tryRestoreFile = async () => {\r\n            try {\r\n                const fileInfoRaw = localStorage.getItem(STORAGE_KEY + '_file');\r\n                if (!fileInfoRaw) return;\r\n                const fileInfo = JSON.parse(fileInfoRaw);\r\n                const blob = await getFile('audio');\r\n                if (blob) {\r\n                    // Recreate a File from blob so components expecting File work\r\n                    const restored = new File([blob], fileInfo.name, {\r\n                        type: fileInfo.type || blob.type || 'application/octet-stream',\r\n                        lastModified: fileInfo.lastModified || Date.now()\r\n                    });\r\n                    // Set file and parse chapters\r\n                    // Indicate this was a restore so the player may attempt autoplay\r\n                    setAutoPlayRestore(true);\r\n                    setRestoreTitle(fileInfo.name || restored.name || 'Restored book');\r\n                    setAudioFile(restored);\r\n                    const { chapters: extractedChapters, info } = await parseM4BChapters(restored);\r\n                    setChapters(extractedChapters);\r\n                    setBookInfo(info);\r\n                }\r\n            } catch (err) {\r\n                console.warn('No stored file to restore or restore failed:', err);\r\n            }\r\n        };\r\n\r\n        tryRestoreFile();\r\n    }, [parseM4BChapters]);\r\n\r\n    const parseM4BChapters = useCallback(async (file) => {\r\n        try {\r\n            const extractedChapters = [];\r\n            const info = {\r\n                title: null,\r\n                artist: null,\r\n                album: null,\r\n                cover: null\r\n            };\r\n            \r\n            // First, try to extract chapters using binary parsing (like VLC)\r\n            console.log('Attempting to extract chapters from M4B file...');\r\n            const binaryChapters = await extractM4BChapters(file);\r\n            \r\n            if (binaryChapters.length > 0) {\r\n                console.log(`Successfully extracted ${binaryChapters.length} chapters from binary parsing`);\r\n                extractedChapters.push(...binaryChapters);\r\n            }\r\n            \r\n            // Also get metadata using music-metadata for title, artist, cover, etc.\r\n            let metadata;\r\n            try {\r\n                metadata = await parseBlob(file, { \r\n                    duration: true,\r\n                    skipCovers: false,\r\n                    native: true\r\n                });\r\n                \r\n                // Extract basic info\r\n                info.title = metadata.common.title || file.name.replace(/\\.[^/.]+$/, '');\r\n                info.artist = metadata.common.artist || metadata.common.albumartist || null;\r\n                info.album = metadata.common.album || null;\r\n                \r\n                // Extract cover art\r\n                if (metadata.common.picture && metadata.common.picture.length > 0) {\r\n                    const picture = metadata.common.picture[0];\r\n                    const blob = new Blob([picture.data], { type: picture.format });\r\n                    info.cover = URL.createObjectURL(blob);\r\n                }\r\n                \r\n                const duration = metadata.format.duration || 0;\r\n                \r\n                // If binary parsing didn't find chapters, try metadata\r\n                if (extractedChapters.length === 0) {\r\n                    console.log('No chapters from binary parsing, trying music-metadata...');\r\n                    \r\n                    if (metadata.native) {\r\n                        // Check all native keys for chapter data\r\n                        for (const key in metadata.native) {\r\n                            const items = metadata.native[key];\r\n                            \r\n                            if (Array.isArray(items)) {\r\n                                const chapterItems = items.filter(tag => \r\n                                    tag.id === 'chpl' || \r\n                                    tag.id === 'chapters' ||\r\n                                    (tag.mean && tag.mean.includes('chapter'))\r\n                                );\r\n                                \r\n                                if (chapterItems.length > 0) {\r\n                                    console.log(`Found chapter items in native.${key}`);\r\n                                    \r\n                                    for (const chplData of chapterItems) {\r\n                                        let chapters = [];\r\n                                        if (Array.isArray(chplData.value)) {\r\n                                            chapters = chplData.value;\r\n                                        } else if (chplData.value && typeof chplData.value === 'object') {\r\n                                            chapters = Array.isArray(chplData.value.chapters) \r\n                                                ? chplData.value.chapters \r\n                                                : Object.values(chplData.value);\r\n                                        }\r\n                                        \r\n                                        for (const chapter of chapters) {\r\n                                            if (chapter && (chapter.title || chapter.startTime !== undefined)) {\r\n                                                extractedChapters.push({\r\n                                                    title: chapter.title || chapter.name || `Chapter ${extractedChapters.length + 1}`,\r\n                                                    startTime: (chapter.startTime || chapter.start || 0) / 1000,\r\n                                                    duration: null\r\n                                                });\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // Calculate chapter durations if chapters were found\r\n                if (extractedChapters.length > 0) {\r\n                    extractedChapters.sort((a, b) => a.startTime - b.startTime);\r\n                    \r\n                    extractedChapters.forEach((chapter, index) => {\r\n                        const nextChapter = extractedChapters[index + 1];\r\n                        chapter.duration = nextChapter \r\n                            ? nextChapter.startTime - chapter.startTime\r\n                            : duration - chapter.startTime;\r\n                    });\r\n                    \r\n                    console.log(`Successfully extracted ${extractedChapters.length} chapters`);\r\n                    return { chapters: extractedChapters, info };\r\n                }\r\n                \r\n                // Fallback: create time-based chapters if no chapters found\r\n                if (duration > 0) {\r\n                    const chapterDuration = 600; // 10 minute segments\r\n                    const numChapters = Math.ceil(duration / chapterDuration);\r\n                    \r\n                    for (let i = 0; i < numChapters; i++) {\r\n                        const startTime = i * chapterDuration;\r\n                        extractedChapters.push({\r\n                            title: `Part ${i + 1}`,\r\n                            startTime: startTime,\r\n                            duration: Math.min(chapterDuration, duration - startTime)\r\n                        });\r\n                    }\r\n                    \r\n                    console.log(`No chapters found. Created ${extractedChapters.length} time-based segments`);\r\n                }\r\n                \r\n            } catch (metadataError) {\r\n                console.error('Error parsing metadata:', metadataError);\r\n                info.title = file.name.replace(/\\.[^/.]+$/, '');\r\n            }\r\n            \r\n            return { chapters: extractedChapters, info };\r\n            \r\n        } catch (error) {\r\n            console.error('Error parsing M4B file:', error);\r\n            return { \r\n                chapters: [], \r\n                info: { \r\n                    title: file.name.replace(/\\.[^/.]+$/, ''), \r\n                    artist: null, \r\n                    album: null,\r\n                    cover: null \r\n                } \r\n            };\r\n        }\r\n    }, []);\r\n\r\n    const handleFileSelect = useCallback(async (file) => {\r\n        setIsLoading(true);\r\n        \r\n        try {\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo(info);\r\n            setAudioFile(file);\r\n            \r\n            // Save file info for state restoration\r\n            const fileInfo = {\r\n                name: file.name,\r\n                size: file.size,\r\n                type: file.type,\r\n                lastModified: file.lastModified\r\n            };\r\n            localStorage.setItem(STORAGE_KEY + '_file', JSON.stringify(fileInfo));\r\n            // Persist file blob in IndexedDB so we can restore across reloads\r\n            try {\r\n                await saveFile('audio', file);\r\n            } catch (idbErr) {\r\n                console.warn('Failed to save file to IndexedDB:', idbErr);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error parsing audiobook:', error);\r\n            setAudioFile(file);\r\n            setChapters([]);\r\n            setBookInfo({ title: file.name.replace(/\\.[^/.]+$/, '') });\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleClose = useCallback(() => {\r\n        setAudioFile(null);\r\n        setChapters([]);\r\n        setBookInfo(null);\r\n        setSavedState(null);\r\n        // Remove persisted file and info\r\n        try {\r\n            localStorage.removeItem(STORAGE_KEY + '_file');\r\n            deleteFile('audio').catch(() => {});\r\n        } catch (err) {\r\n            // ignore\r\n        }\r\n    }, []);\r\n\r\n    const handleSaveState = useCallback((state) => {\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\r\n    }, []);\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\">\r\n            {!audioFile ? (\r\n                <FileUploader \r\n                    onFileSelect={handleFileSelect} \r\n                    isLoading={isLoading}\r\n                />\r\n            ) : (\r\n                <div className=\"h-screen\">\r\n                    <AudiobookPlayer\r\n                        file={audioFile}\r\n                        chapters={chapters}\r\n                        bookInfo={bookInfo}\r\n                        onClose={handleClose}\r\n                        savedState={savedState}\r\n                        onSaveState={handleSaveState}\r\n                        autoPlayRestore={autoPlayRestore}\r\n                        onAutoPlayHandled={() => { setAutoPlayRestore(false); setRestoreTitle(null); }}\r\n                        restoreTitle={restoreTitle}\r\n                    />\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}