{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { DEFAULT_HEADERS } from './constants';\nimport { isStorageVectorsError } from './errors';\nimport { post } from './fetch';\nimport { resolveFetch } from './helpers';\n/**\n * @hidden\n * Base implementation for vector data operations.\n * Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n */\nexport default class VectorDataApi {\n  /** Creates a new VectorDataApi instance */\n  constructor(url, headers = {}, fetch) {\n    this.shouldThrowOnError = false;\n    this.url = url.replace(/\\/$/, '');\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /** Enable throwing errors instead of returning them in the response */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /** Inserts or updates vectors in batch (1-500 per request) */\n  putVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.vectors.length < 1 || options.vectors.length > 500) {\n          throw new Error('Vector batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, `${this.url}/PutVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Retrieves vectors by their keys in batch */\n  getVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/GetVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Lists vectors in an index with pagination */\n  listVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate segment configuration\n        if (options.segmentCount !== undefined) {\n          if (options.segmentCount < 1 || options.segmentCount > 16) {\n            throw new Error('segmentCount must be between 1 and 16');\n          }\n          if (options.segmentIndex !== undefined) {\n            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n              throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n            }\n          }\n        }\n        const data = yield post(this.fetch, `${this.url}/ListVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Queries for similar vectors using approximate nearest neighbor search */\n  queryVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/QueryVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Deletes vectors by their keys in batch (1-500 per request) */\n  deleteVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.keys.length < 1 || options.keys.length > 500) {\n          throw new Error('Keys batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, `${this.url}/DeleteVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}\n//# sourceMappingURL=VectorDataApi.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}