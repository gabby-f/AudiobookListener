{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MpegParser = void 0;\nconst Token = require(\"token-types\");\nconst core_1 = require(\"strtok3/lib/core\");\nconst debug_1 = require(\"debug\");\nconst common = require(\"../common/Util\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst XingTag_1 = require(\"./XingTag\");\nconst debug = (0, debug_1.default)('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n  /**\n   * Audio Object Types\n   */\n  AudioObjectTypes: ['AAC Main', 'AAC LC', 'AAC SSR', 'AAC LTP' // Long Term Prediction\n  ],\n  /**\n   * Sampling Frequencies\n   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n   */\n  SamplingFrequencies: [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1]\n  /**\n   * Channel Configurations\n   */\n};\nconst MPEG4_ChannelConfigurations = [undefined, ['front-center'], ['front-left', 'front-right'], ['front-center', 'front-left', 'front-right'], ['front-center', 'front-left', 'front-right', 'back-center'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'], ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n  constructor(buf, off) {\n    // B(20,19): MPEG Audio versionIndex ID\n    this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n    // C(18,17): Layer description\n    this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n    if (this.versionIndex > 1 && this.layer === 0) {\n      this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n    } else {\n      this.parseMpegHeader(buf, off); // Conventional MPEG header\n    }\n    // D(16): Protection bit (if true 16-bit CRC follows header)\n    this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n  }\n  calcDuration(numFrames) {\n    return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n  }\n  calcSamplesPerFrame() {\n    return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n  }\n  calculateSideInfoLength() {\n    if (this.layer !== 3) return 2;\n    if (this.channelModeIndex === 3) {\n      // mono\n      if (this.version === 1) {\n        return 17;\n      } else if (this.version === 2 || this.version === 2.5) {\n        return 9;\n      }\n    } else {\n      if (this.version === 1) {\n        return 32;\n      } else if (this.version === 2 || this.version === 2.5) {\n        return 17;\n      }\n    }\n  }\n  calcSlotSize() {\n    return [null, 4, 1, 1][this.layer];\n  }\n  parseMpegHeader(buf, off) {\n    this.container = 'MPEG';\n    // E(15,12): Bitrate index\n    this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n    // F(11,10): Sampling rate frequency index\n    this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n    // G(9): Padding bit\n    this.padding = common.isBitSet(buf, off + 2, 6);\n    // H(8): Private bit\n    this.privateBit = common.isBitSet(buf, off + 2, 7);\n    // I(7,6): Channel Mode\n    this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n    // J(5,4): Mode extension (Only used in Joint stereo)\n    this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n    // K(3): Copyright\n    this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n    // L(2): Original\n    this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n    // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n    this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n    this.version = MpegFrameHeader.VersionID[this.versionIndex];\n    this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n    this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n    // Calculate bitrate\n    const bitrateInKbps = this.calcBitrate();\n    if (!bitrateInKbps) {\n      throw new Error('Cannot determine bit-rate');\n    }\n    this.bitrate = bitrateInKbps * 1000;\n    // Calculate sampling rate\n    this.samplingRate = this.calcSamplingRate();\n    if (this.samplingRate == null) {\n      throw new Error('Cannot determine sampling-rate');\n    }\n  }\n  parseAdtsHeader(buf, off) {\n    debug(`layer=0 => ADTS`);\n    this.version = this.versionIndex === 2 ? 4 : 2;\n    this.container = 'ADTS/MPEG-' + this.version;\n    const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n    this.codec = 'AAC';\n    this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n    debug(`MPEG-4 audio-codec=${this.codec}`);\n    const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n    this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n    debug(`sampling-rate=${this.samplingRate}`);\n    const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n    this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n    debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n    this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n  }\n  calcBitrate() {\n    if (this.bitrateIndex === 0x00 ||\n    // free\n    this.bitrateIndex === 0x0F) {\n      // reserved\n      return;\n    }\n    const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n    return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n  }\n  calcSamplingRate() {\n    if (this.sampRateFreqIndex === 0x03) return null; // 'reserved'\n    return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n  }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n  0x01: {\n    11: 32,\n    12: 32,\n    13: 32,\n    21: 32,\n    22: 8,\n    23: 8\n  },\n  0x02: {\n    11: 64,\n    12: 48,\n    13: 40,\n    21: 48,\n    22: 16,\n    23: 16\n  },\n  0x03: {\n    11: 96,\n    12: 56,\n    13: 48,\n    21: 56,\n    22: 24,\n    23: 24\n  },\n  0x04: {\n    11: 128,\n    12: 64,\n    13: 56,\n    21: 64,\n    22: 32,\n    23: 32\n  },\n  0x05: {\n    11: 160,\n    12: 80,\n    13: 64,\n    21: 80,\n    22: 40,\n    23: 40\n  },\n  0x06: {\n    11: 192,\n    12: 96,\n    13: 80,\n    21: 96,\n    22: 48,\n    23: 48\n  },\n  0x07: {\n    11: 224,\n    12: 112,\n    13: 96,\n    21: 112,\n    22: 56,\n    23: 56\n  },\n  0x08: {\n    11: 256,\n    12: 128,\n    13: 112,\n    21: 128,\n    22: 64,\n    23: 64\n  },\n  0x09: {\n    11: 288,\n    12: 160,\n    13: 128,\n    21: 144,\n    22: 80,\n    23: 80\n  },\n  0x0A: {\n    11: 320,\n    12: 192,\n    13: 160,\n    21: 160,\n    22: 96,\n    23: 96\n  },\n  0x0B: {\n    11: 352,\n    12: 224,\n    13: 192,\n    21: 176,\n    22: 112,\n    23: 112\n  },\n  0x0C: {\n    11: 384,\n    12: 256,\n    13: 224,\n    21: 192,\n    22: 128,\n    23: 128\n  },\n  0x0D: {\n    11: 416,\n    12: 320,\n    13: 256,\n    21: 224,\n    22: 144,\n    23: 144\n  },\n  0x0E: {\n    11: 448,\n    12: 384,\n    13: 320,\n    21: 256,\n    22: 160,\n    23: 160\n  }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n  1: {\n    0x00: 44100,\n    0x01: 48000,\n    0x02: 32000\n  },\n  2: {\n    0x00: 22050,\n    0x01: 24000,\n    0x02: 16000\n  },\n  2.5: {\n    0x00: 11025,\n    0x01: 12000,\n    0x02: 8000\n  }\n};\nMpegFrameHeader.samplesInFrameTable = [/* Layer   I    II   III */\n[0, 384, 1152, 1152], [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return new MpegFrameHeader(buf, off);\n  }\n};\nfunction getVbrCodecProfile(vbrScale) {\n  return 'V' + Math.floor((100 - vbrScale) / 10);\n}\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.frameCount = 0;\n    this.syncFrameCount = -1;\n    this.countSkipFrameData = 0;\n    this.totalDataLength = 0;\n    this.bitrates = [];\n    this.calculateEofDuration = false;\n    this.buf_frame_header = Buffer.alloc(4);\n    this.syncPeek = {\n      buf: Buffer.alloc(maxPeekLen),\n      len: 0\n    };\n  }\n  /**\n   * Called after ID3 headers have been parsed\n   */\n  async postId3v2Parse() {\n    this.metadata.setFormat('lossless', false);\n    try {\n      let quit = false;\n      while (!quit) {\n        await this.sync();\n        quit = await this.parseCommonMpegHeader();\n      }\n    } catch (err) {\n      if (err instanceof core_1.EndOfStreamError) {\n        debug(`End-of-stream`);\n        if (this.calculateEofDuration) {\n          const numberOfSamples = this.frameCount * this.samplesPerFrame;\n          this.metadata.setFormat('numberOfSamples', numberOfSamples);\n          const duration = numberOfSamples / this.metadata.format.sampleRate;\n          debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n          this.metadata.setFormat('duration', duration);\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n   */\n  finalize() {\n    const format = this.metadata.format;\n    const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n    if (format.duration && this.tokenizer.fileInfo.size) {\n      const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n      if (format.codecProfile && format.codecProfile[0] === 'V') {\n        this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n      }\n    } else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n      const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n      const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n      this.metadata.setFormat('numberOfSamples', numberOfSamples);\n      const duration = numberOfSamples / format.sampleRate;\n      debug(\"Calculate CBR duration based on file size: %s\", duration);\n      this.metadata.setFormat('duration', duration);\n    }\n  }\n  async sync() {\n    let gotFirstSync = false;\n    while (true) {\n      let bo = 0;\n      this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, {\n        length: maxPeekLen,\n        mayBeLess: true\n      });\n      if (this.syncPeek.len <= 163) {\n        throw new core_1.EndOfStreamError();\n      }\n      while (true) {\n        if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n          this.buf_frame_header[1] = this.syncPeek.buf[bo];\n          await this.tokenizer.ignore(bo);\n          debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n          if (this.syncFrameCount === this.frameCount) {\n            debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n            this.frameCount = 0;\n            this.frame_size = 0;\n          }\n          this.syncFrameCount = this.frameCount;\n          return; // sync\n        } else {\n          gotFirstSync = false;\n          bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n          if (bo === -1) {\n            if (this.syncPeek.len < this.syncPeek.buf.length) {\n              throw new core_1.EndOfStreamError();\n            }\n            await this.tokenizer.ignore(this.syncPeek.len);\n            break; // continue with next buffer\n          } else {\n            ++bo;\n            gotFirstSync = true;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Combined ADTS & MPEG (MP2 & MP3) header handling\n   * @return {Promise<boolean>} true if parser should quit\n   */\n  async parseCommonMpegHeader() {\n    if (this.frameCount === 0) {\n      this.mpegOffset = this.tokenizer.position - 1;\n    }\n    await this.tokenizer.peekBuffer(this.buf_frame_header, {\n      offset: 1,\n      length: 3\n    });\n    let header;\n    try {\n      header = FrameHeader.get(this.buf_frame_header, 0);\n    } catch (err) {\n      await this.tokenizer.ignore(1);\n      this.metadata.addWarning('Parse error: ' + err.message);\n      return false; // sync\n    }\n    await this.tokenizer.ignore(3);\n    this.metadata.setFormat('container', header.container);\n    this.metadata.setFormat('codec', header.codec);\n    this.metadata.setFormat('lossless', false);\n    this.metadata.setFormat('sampleRate', header.samplingRate);\n    this.frameCount++;\n    return header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n  }\n  /**\n   * @return {Promise<boolean>} true if parser should quit\n   */\n  async parseAudioFrameHeader(header) {\n    this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n    this.metadata.setFormat('bitrate', header.bitrate);\n    if (this.frameCount < 20 * 10000) {\n      debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n    }\n    const slot_size = header.calcSlotSize();\n    if (slot_size === null) {\n      throw new Error('invalid slot_size');\n    }\n    const samples_per_frame = header.calcSamplesPerFrame();\n    debug(`samples_per_frame=${samples_per_frame}`);\n    const bps = samples_per_frame / 8.0;\n    const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);\n    this.frame_size = Math.floor(fsize);\n    this.audioFrameHeader = header;\n    this.bitrates.push(header.bitrate);\n    // xtra header only exists in first frame\n    if (this.frameCount === 1) {\n      this.offset = FrameHeader.len;\n      await this.skipSideInformation();\n      return false;\n    }\n    if (this.frameCount === 3) {\n      // the stream is CBR if the first 3 frame bitrates are the same\n      if (this.areAllSame(this.bitrates)) {\n        // Actual calculation will be done in finalize\n        this.samplesPerFrame = samples_per_frame;\n        this.metadata.setFormat('codecProfile', 'CBR');\n        if (this.tokenizer.fileInfo.size) return true; // Will calculate duration based on the file size\n      } else if (this.metadata.format.duration) {\n        return true; // We already got the duration, stop processing MPEG stream any further\n      }\n      if (!this.options.duration) {\n        return true; // Enforce duration not enabled, stop processing entire stream\n      }\n    }\n    // once we know the file is VBR attach listener to end of\n    // stream so we can do the duration calculation when we\n    // have counted all the frames\n    if (this.options.duration && this.frameCount === 4) {\n      this.samplesPerFrame = samples_per_frame;\n      this.calculateEofDuration = true;\n    }\n    this.offset = 4;\n    if (header.isProtectedByCRC) {\n      await this.parseCrc();\n      return false;\n    } else {\n      await this.skipSideInformation();\n      return false;\n    }\n  }\n  async parseAdts(header) {\n    const buf = Buffer.alloc(3);\n    await this.tokenizer.readBuffer(buf);\n    header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n    this.totalDataLength += header.frameLength;\n    this.samplesPerFrame = 1024;\n    const framesPerSec = header.samplingRate / this.samplesPerFrame;\n    const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n    const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n    this.metadata.setFormat('bitrate', bitrate);\n    debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n    await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n    // Consume remaining header and frame data\n    if (this.frameCount === 3) {\n      this.metadata.setFormat('codecProfile', header.codecProfile);\n      if (header.mp4ChannelConfig) {\n        this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n      }\n      if (this.options.duration) {\n        this.calculateEofDuration = true;\n      } else {\n        return true; // Stop parsing after the third frame\n      }\n    }\n    return false;\n  }\n  async parseCrc() {\n    this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n    this.offset += 2;\n    return this.skipSideInformation();\n  }\n  async skipSideInformation() {\n    const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n    // side information\n    await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n    this.offset += sideinfo_length;\n    await this.readXtraInfoHeader();\n    return;\n  }\n  async readXtraInfoHeader() {\n    const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n    this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n    switch (headerTag) {\n      case 'Info':\n        this.metadata.setFormat('codecProfile', 'CBR');\n        return this.readXingInfoHeader();\n      case 'Xing':\n        const infoTag = await this.readXingInfoHeader();\n        const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n        this.metadata.setFormat('codecProfile', codecProfile);\n        return null;\n      case 'Xtra':\n        // ToDo: ???\n        break;\n      case 'LAME':\n        const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n        if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n          this.offset += XingTag_1.LameEncoderVersion.len;\n          this.metadata.setFormat('tool', 'LAME ' + version);\n          await this.skipFrameData(this.frame_size - this.offset);\n          return null;\n        } else {\n          this.metadata.addWarning('Corrupt LAME header');\n          break;\n        }\n      // ToDo: ???\n    }\n    // ToDo: promise duration???\n    const frameDataLeft = this.frame_size - this.offset;\n    if (frameDataLeft < 0) {\n      this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n    } else {\n      await this.skipFrameData(frameDataLeft);\n    }\n    return null;\n  }\n  /**\n   * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n   * @returns {Promise<string>}\n   */\n  async readXingInfoHeader() {\n    const offset = this.tokenizer.position;\n    const infoTag = await (0, XingTag_1.readXingHeader)(this.tokenizer);\n    this.offset += this.tokenizer.position - offset;\n    if (infoTag.lame) {\n      this.metadata.setFormat('tool', 'LAME ' + common.stripNulls(infoTag.lame.version));\n      if (infoTag.lame.extended) {\n        // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n        this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n        if (infoTag.lame.extended.track_gain) {\n          this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n        }\n        if (infoTag.lame.extended.album_gain) {\n          this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n        }\n        this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n      }\n    }\n    if (infoTag.streamSize) {\n      const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n      this.metadata.setFormat('duration', duration);\n      debug('Get duration from Xing header: %s', this.metadata.format.duration);\n      return infoTag;\n    }\n    // frames field is not present\n    const frameDataLeft = this.frame_size - this.offset;\n    await this.skipFrameData(frameDataLeft);\n    return infoTag;\n  }\n  async skipFrameData(frameDataLeft) {\n    if (frameDataLeft < 0) throw new Error('frame-data-left cannot be negative');\n    await this.tokenizer.ignore(frameDataLeft);\n    this.countSkipFrameData += frameDataLeft;\n  }\n  areAllSame(array) {\n    const first = array[0];\n    return array.every(element => {\n      return element === first;\n    });\n  }\n}\nexports.MpegParser = MpegParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}