{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ID3v2Parser = void 0;\nconst Token = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst FrameParser_1 = require(\"./FrameParser\");\nconst ID3v2Token_1 = require(\"./ID3v2Token\");\nclass ID3v2Parser {\n  static removeUnsyncBytes(buffer) {\n    let readI = 0;\n    let writeI = 0;\n    while (readI < buffer.length - 1) {\n      if (readI !== writeI) {\n        buffer[writeI] = buffer[readI];\n      }\n      readI += buffer[readI] === 0xFF && buffer[readI + 1] === 0 ? 2 : 1;\n      writeI++;\n    }\n    if (readI < buffer.length) {\n      buffer[writeI++] = buffer[readI];\n    }\n    return buffer.slice(0, writeI);\n  }\n  static getFrameHeaderLength(majorVer) {\n    switch (majorVer) {\n      case 2:\n        return 6;\n      case 3:\n      case 4:\n        return 10;\n      default:\n        throw new Error('header versionIndex is incorrect');\n    }\n  }\n  static readFrameFlags(b) {\n    return {\n      status: {\n        tag_alter_preservation: util.getBit(b, 0, 6),\n        file_alter_preservation: util.getBit(b, 0, 5),\n        read_only: util.getBit(b, 0, 4)\n      },\n      format: {\n        grouping_identity: util.getBit(b, 1, 7),\n        compression: util.getBit(b, 1, 3),\n        encryption: util.getBit(b, 1, 2),\n        unsynchronisation: util.getBit(b, 1, 1),\n        data_length_indicator: util.getBit(b, 1, 0)\n      }\n    };\n  }\n  static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {\n    const frameParser = new FrameParser_1.FrameParser(majorVer, warningCollector);\n    switch (majorVer) {\n      case 2:\n        return frameParser.readData(uint8Array, frameHeader.id, includeCovers);\n      case 3:\n      case 4:\n        if (frameHeader.flags.format.unsynchronisation) {\n          uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);\n        }\n        if (frameHeader.flags.format.data_length_indicator) {\n          uint8Array = uint8Array.slice(4, uint8Array.length);\n        }\n        return frameParser.readData(uint8Array, frameHeader.id, includeCovers);\n      default:\n        throw new Error('Unexpected majorVer: ' + majorVer);\n    }\n  }\n  /**\n   * Create a combined tag key, of tag & description\n   * @param tag e.g.: COM\n   * @param description e.g. iTunPGAP\n   * @returns string e.g. COM:iTunPGAP\n   */\n  static makeDescriptionTagName(tag, description) {\n    return tag + (description ? ':' + description : '');\n  }\n  async parse(metadata, tokenizer, options) {\n    this.tokenizer = tokenizer;\n    this.metadata = metadata;\n    this.options = options;\n    const id3Header = await this.tokenizer.readToken(ID3v2Token_1.ID3v2Header);\n    if (id3Header.fileIdentifier !== 'ID3') {\n      throw new Error('expected ID3-header file-identifier \\'ID3\\' was not found');\n    }\n    this.id3Header = id3Header;\n    this.headerType = 'ID3v2.' + id3Header.version.major;\n    return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);\n  }\n  async parseExtendedHeader() {\n    const extendedHeader = await this.tokenizer.readToken(ID3v2Token_1.ExtendedHeader);\n    const dataRemaining = extendedHeader.size - ID3v2Token_1.ExtendedHeader.len;\n    return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);\n  }\n  async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {\n    await this.tokenizer.ignore(dataRemaining);\n    return this.parseId3Data(this.id3Header.size - extendedHeaderSize);\n  }\n  async parseId3Data(dataLen) {\n    const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(dataLen));\n    for (const tag of this.parseMetadata(uint8Array)) {\n      if (tag.id === 'TXXX') {\n        if (tag.value) {\n          for (const text of tag.value.text) {\n            this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);\n          }\n        }\n      } else if (tag.id === 'COM') {\n        for (const value of tag.value) {\n          this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);\n        }\n      } else if (tag.id === 'COMM') {\n        for (const value of tag.value) {\n          this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value);\n        }\n      } else if (Array.isArray(tag.value)) {\n        for (const value of tag.value) {\n          this.addTag(tag.id, value);\n        }\n      } else {\n        this.addTag(tag.id, tag.value);\n      }\n    }\n  }\n  addTag(id, value) {\n    this.metadata.addTag(this.headerType, id, value);\n  }\n  parseMetadata(data) {\n    let offset = 0;\n    const tags = [];\n    while (true) {\n      if (offset === data.length) break;\n      const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);\n      if (offset + frameHeaderLength > data.length) {\n        this.metadata.addWarning('Illegal ID3v2 tag length');\n        break;\n      }\n      const frameHeaderBytes = data.slice(offset, offset += frameHeaderLength);\n      const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);\n      const frameDataBytes = data.slice(offset, offset += frameHeader.length);\n      const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);\n      if (values) {\n        tags.push({\n          id: frameHeader.id,\n          value: values\n        });\n      }\n    }\n    return tags;\n  }\n  readFrameHeader(uint8Array, majorVer) {\n    let header;\n    switch (majorVer) {\n      case 2:\n        header = {\n          id: Buffer.from(uint8Array.slice(0, 3)).toString('ascii'),\n          length: Token.UINT24_BE.get(uint8Array, 3)\n        };\n        if (!header.id.match(/[A-Z0-9]{3}/g)) {\n          this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);\n        }\n        break;\n      case 3:\n      case 4:\n        header = {\n          id: Buffer.from(uint8Array.slice(0, 4)).toString('ascii'),\n          length: (majorVer === 4 ? ID3v2Token_1.UINT32SYNCSAFE : Token.UINT32_BE).get(uint8Array, 4),\n          flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))\n        };\n        if (!header.id.match(/[A-Z0-9]{4}/g)) {\n          this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);\n        }\n        break;\n      default:\n        throw new Error('Unexpected majorVer: ' + majorVer);\n    }\n    return header;\n  }\n}\nexports.ID3v2Parser = ID3v2Parser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}