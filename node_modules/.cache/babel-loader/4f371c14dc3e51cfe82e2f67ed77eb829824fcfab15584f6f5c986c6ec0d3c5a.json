{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tslib_1 = require(\"tslib\");\nconst PostgrestError_1 = tslib_1.__importDefault(require(\"./PostgrestError\"));\nclass PostgrestBuilder {\n  /**\n   * Creates a builder configured for a specific PostgREST request.\n   *\n   * @example\n   * ```ts\n   * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n   *\n   * const builder = new PostgrestQueryBuilder(\n   *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n   *   { headers: new Headers({ apikey: 'public-anon-key' }) }\n   * )\n   * ```\n   */\n  constructor(builder) {\n    var _a, _b;\n    this.shouldThrowOnError = false;\n    this.method = builder.method;\n    this.url = builder.url;\n    this.headers = new Headers(builder.headers);\n    this.schema = builder.schema;\n    this.body = builder.body;\n    this.shouldThrowOnError = (_a = builder.shouldThrowOnError) !== null && _a !== void 0 ? _a : false;\n    this.signal = builder.signal;\n    this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;\n    if (builder.fetch) {\n      this.fetch = builder.fetch;\n    } else {\n      this.fetch = fetch;\n    }\n  }\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /**\n   * Set an HTTP header for the request.\n   */\n  setHeader(name, value) {\n    this.headers = new Headers(this.headers);\n    this.headers.set(name, value);\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers.set('Accept-Profile', this.schema);\n    } else {\n      this.headers.set('Content-Profile', this.schema);\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers.set('Content-Type', 'application/json');\n    }\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch;\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal\n    }).then(async res => {\n      var _a, _b, _c, _d;\n      let error = null;\n      let data = null;\n      let count = null;\n      let status = res.status;\n      let statusText = res.statusText;\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text();\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers.get('Accept') === 'text/csv') {\n            data = body;\n          } else if (this.headers.get('Accept') && ((_a = this.headers.get('Accept')) === null || _a === void 0 ? void 0 : _a.includes('application/vnd.pgrst.plan+text'))) {\n            data = body;\n          } else {\n            data = JSON.parse(body);\n          }\n        }\n        const countHeader = (_b = this.headers.get('Prefer')) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n        const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1]);\n        }\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned'\n            };\n            data = null;\n            count = null;\n            status = 406;\n            statusText = 'Not Acceptable';\n          } else if (data.length === 1) {\n            data = data[0];\n          } else {\n            data = null;\n          }\n        }\n      } else {\n        const body = await res.text();\n        try {\n          error = JSON.parse(body);\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = [];\n            error = null;\n            status = 200;\n            statusText = 'OK';\n          }\n        } catch (_e) {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204;\n            statusText = 'No Content';\n          } else {\n            error = {\n              message: body\n            };\n          }\n        }\n        if (error && this.isMaybeSingle && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes('0 rows'))) {\n          error = null;\n          status = 200;\n          statusText = 'OK';\n        }\n        if (error && this.shouldThrowOnError) {\n          throw new PostgrestError_1.default(error);\n        }\n      }\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText\n      };\n      return postgrestResponse;\n    });\n    if (!this.shouldThrowOnError) {\n      res = res.catch(fetchError => {\n        var _a, _b, _c, _d, _e, _f;\n        // Build detailed error information including cause if available\n        // Note: We don't populate code/hint for client-side network errors since those\n        // fields are meant for upstream service errors (PostgREST/PostgreSQL)\n        let errorDetails = '';\n        // Add cause information if available (e.g., DNS errors, network failures)\n        const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n        if (cause) {\n          const causeMessage = (_a = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _a !== void 0 ? _a : '';\n          const causeCode = (_b = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _b !== void 0 ? _b : '';\n          errorDetails = `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _c !== void 0 ? _c : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n          errorDetails += `\\n\\nCaused by: ${(_d = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _d !== void 0 ? _d : 'Error'}: ${causeMessage}`;\n          if (causeCode) {\n            errorDetails += ` (${causeCode})`;\n          }\n          if (cause === null || cause === void 0 ? void 0 : cause.stack) {\n            errorDetails += `\\n${cause.stack}`;\n          }\n        } else {\n          // No cause available, just include the error stack\n          errorDetails = (_e = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _e !== void 0 ? _e : '';\n        }\n        return {\n          error: {\n            message: `${(_f = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _f !== void 0 ? _f : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n            details: errorDetails,\n            hint: '',\n            code: ''\n          },\n          data: null,\n          count: null,\n          status: 0,\n          statusText: ''\n        };\n      });\n    }\n    return res.then(onfulfilled, onrejected);\n  }\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns() {\n    /* istanbul ignore next */\n    return this;\n  }\n  /**\n   * Override the type of the returned `data` field in the response.\n   *\n   * @typeParam NewResult - The new type to cast the response data to\n   * @typeParam Options - Optional type configuration (defaults to { merge: true })\n   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n   * @example\n   * ```typescript\n   * // Merge with existing types (default behavior)\n   * const query = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ custom_field: string }>()\n   *\n   * // Replace existing types completely\n   * const replaceQuery = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n   * ```\n   * @returns A PostgrestBuilder instance with the new type\n   */\n  overrideTypes() {\n    return this;\n  }\n}\nexports.default = PostgrestBuilder;\n//# sourceMappingURL=PostgrestBuilder.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}