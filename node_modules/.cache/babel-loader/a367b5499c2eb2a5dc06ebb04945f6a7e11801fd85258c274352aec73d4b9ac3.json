{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinArtists = exports.MetadataCollector = void 0;\nconst type_1 = require(\"../type\");\nconst debug_1 = require(\"debug\");\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\nconst Util_1 = require(\"./Util\");\nconst FileType = require(\"file-type/core\");\nconst debug = (0, debug_1.default)('music-metadata:collector');\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'AIFF', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\nclass MetadataCollector {\n  constructor(opts) {\n    this.opts = opts;\n    this.format = {\n      tagTypes: [],\n      trackInfo: []\n    };\n    this.native = {};\n    this.common = {\n      track: {\n        no: null,\n        of: null\n      },\n      disk: {\n        no: null,\n        of: null\n      },\n      movementIndex: {}\n    };\n    this.quality = {\n      warnings: []\n    };\n    /**\n     * Keeps track of origin priority for each mapped id\n     */\n    this.commonOrigin = {};\n    /**\n     * Maps a tag type to a priority\n     */\n    this.originPriority = {};\n    this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n    let priority = 1;\n    for (const tagType of TagPriority) {\n      this.originPriority[tagType] = priority++;\n    }\n    this.originPriority.artificial = 500; // Filled using alternative tags\n    this.originPriority.id3v1 = 600; // Consider as the worst because of the field length limit\n  }\n  /**\n   * @returns {boolean} true if one or more tags have been found\n   */\n  hasAny() {\n    return Object.keys(this.native).length > 0;\n  }\n  addStreamInfo(streamInfo) {\n    debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n    this.format.trackInfo.push(streamInfo);\n  }\n  setFormat(key, value) {\n    debug(`format: ${key} = ${value}`);\n    this.format[key] = value; // as any to override readonly\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'format',\n          id: key,\n          value\n        }\n      });\n    }\n  }\n  addTag(tagType, tagId, value) {\n    debug(`tag ${tagType}.${tagId} = ${value}`);\n    if (!this.native[tagType]) {\n      this.format.tagTypes.push(tagType);\n      this.native[tagType] = [];\n    }\n    this.native[tagType].push({\n      id: tagId,\n      value\n    });\n    this.toCommon(tagType, tagId, value);\n  }\n  addWarning(warning) {\n    this.quality.warnings.push({\n      message: warning\n    });\n  }\n  postMap(tagType, tag) {\n    // Common tag (alias) found\n    // check if we need to do something special with common tag\n    // if the event has been aliased then we need to clean it before\n    // it is emitted to the user. e.g. genre (20) -> Electronic\n    switch (tag.id) {\n      case 'artist':\n        if (this.commonOrigin.artist === this.originPriority[tagType]) {\n          // Assume the artist field is used as artists\n          return this.postMap('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n        if (!this.common.artists) {\n          // Fill artists using artist source\n          this.setGenericTag('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n        break;\n      case 'artists':\n        if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n          if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n            // Fill artist using artists source\n            const artists = (this.common.artists || []).concat([tag.value]);\n            const value = joinArtists(artists);\n            const artistTag = {\n              id: 'artist',\n              value\n            };\n            this.setGenericTag('artificial', artistTag);\n          }\n        }\n        break;\n      case 'picture':\n        this.postFixPicture(tag.value).then(picture => {\n          if (picture !== null) {\n            tag.value = picture;\n            this.setGenericTag(tagType, tag);\n          }\n        });\n        return;\n      case 'totaltracks':\n        this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n      case 'totaldiscs':\n        this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n      case 'movementTotal':\n        this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n      case 'track':\n      case 'disk':\n      case 'movementIndex':\n        const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n        this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n        this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n        return;\n      case 'bpm':\n      case 'year':\n      case 'originalyear':\n        tag.value = parseInt(tag.value, 10);\n        break;\n      case 'date':\n        // ToDo: be more strict on 'YYYY...'\n        const year = parseInt(tag.value.substr(0, 4), 10);\n        if (!isNaN(year)) {\n          this.common.year = year;\n        }\n        break;\n      case 'discogs_label_id':\n      case 'discogs_release_id':\n      case 'discogs_master_release_id':\n      case 'discogs_artist_id':\n      case 'discogs_votes':\n        tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n        break;\n      case 'replaygain_track_gain':\n      case 'replaygain_track_peak':\n      case 'replaygain_album_gain':\n      case 'replaygain_album_peak':\n        tag.value = (0, Util_1.toRatio)(tag.value);\n        break;\n      case 'replaygain_track_minmax':\n        tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n        break;\n      case 'replaygain_undo':\n        const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n        tag.value = {\n          leftChannel: minMix[0],\n          rightChannel: minMix[1]\n        };\n        break;\n      case 'gapless': // iTunes gap-less flag\n      case 'compilation':\n      case 'podcast':\n      case 'showMovement':\n        tag.value = tag.value === '1' || tag.value === 1; // boolean\n        break;\n      case 'isrc':\n        // Only keep unique values\n        if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1) return;\n        break;\n      default:\n      // nothing to do\n    }\n    if (tag.value !== null) {\n      this.setGenericTag(tagType, tag);\n    }\n  }\n  /**\n   * Convert native tags to common tags\n   * @returns {IAudioMetadata} Native + common tags\n   */\n  toCommonMetadata() {\n    return {\n      format: this.format,\n      native: this.native,\n      quality: this.quality,\n      common: this.common\n    };\n  }\n  /**\n   * Fix some common issues with picture object\n   * @param picture Picture\n   */\n  async postFixPicture(picture) {\n    if (picture.data && picture.data.length > 0) {\n      if (!picture.format) {\n        const fileType = await FileType.fromBuffer(picture.data);\n        if (fileType) {\n          picture.format = fileType.mime;\n        } else {\n          return null;\n        }\n      }\n      picture.format = picture.format.toLocaleLowerCase();\n      switch (picture.format) {\n        case 'image/jpg':\n          picture.format = 'image/jpeg';\n        // ToDo: register warning\n      }\n      return picture;\n    }\n    this.addWarning(`Empty picture tag found`);\n    return null;\n  }\n  /**\n   * Convert native tag to common tags\n   */\n  toCommon(tagType, tagId, value) {\n    const tag = {\n      id: tagId,\n      value\n    };\n    const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n    if (genericTag) {\n      this.postMap(tagType, genericTag);\n    }\n  }\n  /**\n   * Set generic tag\n   */\n  setGenericTag(tagType, tag) {\n    debug(`common.${tag.id} = ${tag.value}`);\n    const prio0 = this.commonOrigin[tag.id] || 1000;\n    const prio1 = this.originPriority[tagType];\n    if ((0, GenericTagTypes_1.isSingleton)(tag.id)) {\n      if (prio1 <= prio0) {\n        this.common[tag.id] = tag.value;\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    } else {\n      if (prio1 === prio0) {\n        if (!(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n          this.common[tag.id].push(tag.value);\n        } else {\n          debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n        }\n        // no effect? this.commonOrigin[tag.id] = prio1;\n      } else if (prio1 < prio0) {\n        this.common[tag.id] = [tag.value];\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    }\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'common',\n          id: tag.id,\n          value: tag.value\n        }\n      });\n    }\n    // ToDo: trigger metadata event\n  }\n}\nexports.MetadataCollector = MetadataCollector;\nfunction joinArtists(artists) {\n  if (artists.length > 2) {\n    return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n  }\n  return artists.join(' & ');\n}\nexports.joinArtists = joinArtists;\n//# sourceMappingURL=MetadataCollector.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}