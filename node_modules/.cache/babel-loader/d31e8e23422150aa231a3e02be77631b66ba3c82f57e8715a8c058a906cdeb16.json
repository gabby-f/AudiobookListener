{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaveParser = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst riff = require(\"../riff/RiffChunk\");\nconst WaveChunk = require(\"./../wav/WaveChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst util = require(\"../common/Util\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst BwfChunk_1 = require(\"../wav/BwfChunk\");\nconst debug = (0, debug_1.default)('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n * - http://soundfile.sapp.org/doc/WaveFormat\n *\n * ToDo: Split WAVE part from RIFF parser\n */\nclass WaveParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const riffHeader = await this.tokenizer.readToken(riff.Header);\n    debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n    if (riffHeader.chunkID !== 'RIFF') return; // Not RIFF format\n    return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n      if (!(err instanceof strtok3.EndOfStreamError)) {\n        throw err;\n      }\n    });\n  }\n  async parseRiffChunk(chunkSize) {\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    this.metadata.setFormat('container', type);\n    switch (type) {\n      case 'WAVE':\n        return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n      default:\n        throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n    }\n  }\n  async readWaveChunk(remaining) {\n    while (remaining >= riff.Header.len) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      remaining -= riff.Header.len + header.chunkSize;\n      if (header.chunkSize > remaining) {\n        this.metadata.addWarning('Data chunk size exceeds file size');\n      }\n      this.header = header;\n      debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n      switch (header.chunkID) {\n        case 'LIST':\n          await this.parseListTag(header);\n          break;\n        case 'fact':\n          // extended Format chunk,\n          this.metadata.setFormat('lossless', false);\n          this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n          break;\n        case 'fmt ':\n          // The Util Chunk, non-PCM Formats\n          const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n          let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n          if (!subFormat) {\n            debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n            subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n          }\n          this.metadata.setFormat('codec', subFormat);\n          this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n          this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n          this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n          this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n          this.blockAlign = fmt.nBlockAlign;\n          break;\n        case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n        case 'ID3 ':\n          // The way Mp3Tags stores ID3 meta-data\n          const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n          const rst = strtok3.fromBuffer(id3_data);\n          await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n          break;\n        case 'data':\n          // PCM-data\n          if (this.metadata.format.lossless !== false) {\n            this.metadata.setFormat('lossless', true);\n          }\n          let chunkSize = header.chunkSize;\n          if (this.tokenizer.fileInfo.size) {\n            const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            if (calcRemaining < chunkSize) {\n              this.metadata.addWarning('data chunk length exceeding file length');\n              chunkSize = calcRemaining;\n            }\n          }\n          const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign;\n          if (numberOfSamples) {\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n          }\n          if (this.metadata.format.codec === 'ADPCM') {\n            // ADPCM is 4 bits lossy encoding resulting in 352kbps\n            this.metadata.setFormat('bitrate', 352000);\n          } else {\n            this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n          }\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n        case 'bext':\n          // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n          const bext = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);\n          Object.keys(bext).forEach(key => {\n            this.metadata.addTag('exif', 'bext.' + key, bext[key]);\n          });\n          const bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;\n          await this.tokenizer.ignore(bextRemaining);\n          break;\n        case '\\x00\\x00\\x00\\x00':\n          // padding ??\n          debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n        default:\n          debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n          await this.tokenizer.ignore(header.chunkSize);\n      }\n      if (this.header.chunkSize % 2 === 1) {\n        debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n        await this.tokenizer.ignore(1);\n      }\n    }\n  }\n  async parseListTag(listHeader) {\n    const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\n    debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n    switch (listType) {\n      case 'INFO':\n        return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n      case 'adtl':\n      default:\n        this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n        debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n        return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n    }\n  }\n  async parseRiffInfoTags(chunkSize) {\n    while (chunkSize >= 8) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      const valueToken = new riff.ListInfoTagValue(header);\n      const value = await this.tokenizer.readToken(valueToken);\n      this.addTag(header.chunkID, util.stripNulls(value));\n      chunkSize -= 8 + valueToken.len;\n    }\n    if (chunkSize !== 0) {\n      throw Error('Illegal remaining size: ' + chunkSize);\n    }\n  }\n  addTag(id, value) {\n    this.metadata.addTag('exif', id, value);\n  }\n}\nexports.WaveParser = WaveParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}