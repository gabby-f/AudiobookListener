{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MP4Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst Token = require(\"token-types\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst type_1 = require(\"../type\");\nconst Atom_1 = require(\"./Atom\");\nconst AtomToken = require(\"./AtomToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n  raw: {\n    lossy: false,\n    format: 'raw'\n  },\n  MAC3: {\n    lossy: true,\n    format: 'MACE 3:1'\n  },\n  MAC6: {\n    lossy: true,\n    format: 'MACE 6:1'\n  },\n  ima4: {\n    lossy: true,\n    format: 'IMA 4:1'\n  },\n  ulaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  alaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  Qclp: {\n    lossy: true,\n    format: 'QUALCOMM PureVoice'\n  },\n  '.mp3': {\n    lossy: true,\n    format: 'MPEG-1 layer 3'\n  },\n  alac: {\n    lossy: false,\n    format: 'ALAC'\n  },\n  'ac-3': {\n    lossy: true,\n    format: 'AC-3'\n  },\n  mp4a: {\n    lossy: true,\n    format: 'MPEG-4/AAC'\n  },\n  mp4s: {\n    lossy: true,\n    format: 'MP4S'\n  },\n  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n  c608: {\n    lossy: true,\n    format: 'CEA-608'\n  },\n  c708: {\n    lossy: true,\n    format: 'CEA-708'\n  }\n};\nfunction distinct(value, index, self) {\n  return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nclass MP4Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.atomParsers = {\n      /**\n       * Parse movie header (mvhd) atom\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n       */\n      mvhd: async len => {\n        const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n        this.metadata.setFormat('creationTime', mvhd.creationTime);\n        this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n      },\n      /**\n       * Parse media header (mdhd) atom\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n       */\n      mdhd: async len => {\n        const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\n        // this.parse_mxhd(mdhd_data, this.currentTrack);\n        const td = this.getTrackDescription();\n        td.creationTime = mdhd_data.creationTime;\n        td.modificationTime = mdhd_data.modificationTime;\n        td.timeScale = mdhd_data.timeScale;\n        td.duration = mdhd_data.duration;\n      },\n      chap: async len => {\n        const td = this.getTrackDescription();\n        const trackIds = [];\n        while (len >= Token.UINT32_BE.len) {\n          trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n          len -= Token.UINT32_BE.len;\n        }\n        td.chapterList = trackIds;\n      },\n      tkhd: async len => {\n        const track = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));\n        this.tracks.push(track);\n      },\n      /**\n       * Parse mdat atom.\n       * Will scan for chapters\n       */\n      mdat: async len => {\n        this.audioLengthInBytes = len;\n        this.calculateBitRate();\n        if (this.options.includeChapters) {\n          const trackWithChapters = this.tracks.filter(track => track.chapterList);\n          if (trackWithChapters.length === 1) {\n            const chapterTrackIds = trackWithChapters[0].chapterList;\n            const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n            if (chapterTracks.length === 1) {\n              return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n            }\n          }\n        }\n        await this.tokenizer.ignore(len);\n      },\n      ftyp: async len => {\n        const types = [];\n        while (len > 0) {\n          const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n          len -= AtomToken.ftyp.len;\n          const value = ftype.type.replace(/\\W/g, '');\n          if (value.length > 0) {\n            types.push(value); // unshift for backward compatibility\n          }\n        }\n        debug(`ftyp: ${types.join('/')}`);\n        const x = types.filter(distinct).join('/');\n        this.metadata.setFormat('container', x);\n      },\n      /**\n       * Parse sample description atom\n       */\n      stsd: async len => {\n        const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n        const trackDescription = this.getTrackDescription();\n        trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n      },\n      /**\n       * sample-to-Chunk Atoms\n       */\n      stsc: async len => {\n        const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n        this.getTrackDescription().sampleToChunkTable = stsc.entries;\n      },\n      /**\n       * time-to-sample table\n       */\n      stts: async len => {\n        const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n        this.getTrackDescription().timeToSampleTable = stts.entries;\n      },\n      /**\n       * Parse sample-sizes atom ('stsz')\n       */\n      stsz: async len => {\n        const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n        const td = this.getTrackDescription();\n        td.sampleSize = stsz.sampleSize;\n        td.sampleSizeTable = stsz.entries;\n      },\n      /**\n       * Parse chunk-offset atom ('stco')\n       */\n      stco: async len => {\n        const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n        this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n      },\n      date: async len => {\n        const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n        this.addTag('date', date);\n      }\n    };\n  }\n  static read_BE_Integer(array, signed) {\n    const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n    const token = Token[integerType];\n    if (!token) {\n      throw new Error('Token for integer type not found: \"' + integerType + '\"');\n    }\n    return Number(token.get(array, 0));\n  }\n  async parse() {\n    this.tracks = [];\n    let remainingFileSize = this.tokenizer.fileInfo.size;\n    while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n      try {\n        const token = await this.tokenizer.peekToken(AtomToken.Header);\n        if (token.name === '\\0\\0\\0\\0') {\n          const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n          debug(errMsg);\n          this.addWarning(errMsg);\n          break;\n        }\n      } catch (error) {\n        const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n        debug(errMsg);\n        this.addWarning(errMsg);\n        break;\n      }\n      const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n      remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n    }\n    // Post process metadata\n    const formatList = [];\n    this.tracks.forEach(track => {\n      const trackFormats = [];\n      track.soundSampleDescription.forEach(ssd => {\n        const streamInfo = {};\n        const encoderInfo = encoderDict[ssd.dataFormat];\n        if (encoderInfo) {\n          trackFormats.push(encoderInfo.format);\n          streamInfo.codecName = encoderInfo.format;\n        } else {\n          streamInfo.codecName = `<${ssd.dataFormat}>`;\n        }\n        if (ssd.description) {\n          const {\n            description\n          } = ssd;\n          if (description.sampleRate > 0) {\n            streamInfo.type = type_1.TrackType.audio;\n            streamInfo.audio = {\n              samplingFrequency: description.sampleRate,\n              bitDepth: description.sampleSize,\n              channels: description.numAudioChannels\n            };\n          }\n        }\n        this.metadata.addStreamInfo(streamInfo);\n      });\n      if (trackFormats.length >= 1) {\n        formatList.push(trackFormats.join('/'));\n      }\n    });\n    if (formatList.length > 0) {\n      this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n    }\n    const audioTracks = this.tracks.filter(track => {\n      return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n    });\n    if (audioTracks.length >= 1) {\n      const audioTrack = audioTracks[0];\n      if (audioTrack.timeScale > 0) {\n        const duration = audioTrack.duration / audioTrack.timeScale; // calculate duration in seconds\n        this.metadata.setFormat('duration', duration);\n      }\n      const ssd = audioTrack.soundSampleDescription[0];\n      if (ssd.description) {\n        this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n        this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n        this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n        if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n          const totalSampleSize = audioTrack.timeToSampleTable.map(ttstEntry => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize);\n          const duration = totalSampleSize / ssd.description.sampleRate;\n          this.metadata.setFormat('duration', duration);\n        }\n      }\n      const encoderInfo = encoderDict[ssd.dataFormat];\n      if (encoderInfo) {\n        this.metadata.setFormat('lossless', !encoderInfo.lossy);\n      }\n      this.calculateBitRate();\n    }\n  }\n  async handleAtom(atom, remaining) {\n    if (atom.parent) {\n      switch (atom.parent.header.name) {\n        case 'ilst':\n        case '<id>':\n          return this.parseMetadataItemData(atom);\n      }\n    }\n    // const payloadLength = atom.getPayloadLength(remaining);\n    if (this.atomParsers[atom.header.name]) {\n      return this.atomParsers[atom.header.name](remaining);\n    } else {\n      debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n      await this.tokenizer.ignore(remaining);\n    }\n  }\n  getTrackDescription() {\n    return this.tracks[this.tracks.length - 1];\n  }\n  calculateBitRate() {\n    if (this.audioLengthInBytes && this.metadata.format.duration) {\n      this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n    }\n  }\n  addTag(id, value) {\n    this.metadata.addTag(tagFormat, id, value);\n  }\n  addWarning(message) {\n    debug('Warning: ' + message);\n    this.metadata.addWarning(message);\n  }\n  /**\n   * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n   * @param metaAtom\n   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n   */\n  parseMetadataItemData(metaAtom) {\n    let tagKey = metaAtom.header.name;\n    return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n      const payLoadLength = child.getPayloadLength(remaining);\n      switch (child.header.name) {\n        case 'data':\n          // value atom\n          return this.parseValueAtom(tagKey, child);\n        case 'name': // name atom (optional)\n        case 'mean':\n        case 'rate':\n          const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n          tagKey += ':' + name.name;\n          break;\n        default:\n          const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\n          this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n      }\n    }, metaAtom.getPayloadLength(0));\n  }\n  async parseValueAtom(tagKey, metaAtom) {\n    const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n    if (dataAtom.type.set !== 0) {\n      throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n    }\n    // Use well-known-type table\n    // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n    switch (dataAtom.type.type) {\n      case 0:\n        // reserved: Reserved for use where no type needs to be indicated\n        switch (tagKey) {\n          case 'trkn':\n          case 'disk':\n            const num = Token.UINT8.get(dataAtom.value, 3);\n            const of = Token.UINT8.get(dataAtom.value, 5);\n            // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n            this.addTag(tagKey, num + '/' + of);\n            break;\n          case 'gnre':\n            const genreInt = Token.UINT8.get(dataAtom.value, 1);\n            const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\n            // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n            this.addTag(tagKey, genreStr);\n            break;\n          case 'rate':\n            const rate = dataAtom.value.toString('ascii');\n            this.addTag(tagKey, rate);\n            break;\n          default:\n            debug('unknown proprietary value type for: ' + metaAtom.atomPath);\n        }\n        break;\n      case 1: // UTF-8: Without any count or NULL terminator\n      case 18:\n        // Unknown: Found in m4b in combination with a 'Â©gen' tag\n        this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n        break;\n      case 13:\n        // JPEG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/jpeg',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n      case 14:\n        // PNG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/png',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n      case 21:\n        // BE Signed Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n        break;\n      case 22:\n        // BE Unsigned Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n        break;\n      case 65:\n        // An 8-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt8(0));\n        break;\n      case 66:\n        // A big-endian 16-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n        break;\n      case 67:\n        // A big-endian 32-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n        break;\n      default:\n        this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n    }\n  }\n  /**\n   * @param sampleDescription\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n   */\n  parseSoundSampleDescription(sampleDescription) {\n    const ssd = {\n      dataFormat: sampleDescription.dataFormat,\n      dataReferenceIndex: sampleDescription.dataReferenceIndex\n    };\n    let offset = 0;\n    const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n    offset += AtomToken.SoundSampleDescriptionVersion.len;\n    if (version.version === 0 || version.version === 1) {\n      // Sound Sample Description (Version 0)\n      ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n    } else {\n      debug(`Warning: sound-sample-description ${version} not implemented`);\n    }\n    return ssd;\n  }\n  async parseChapterTrack(chapterTrack, track, len) {\n    if (!chapterTrack.sampleSize) {\n      if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length) throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n    }\n    const chapters = [];\n    for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n      const chunkOffset = chapterTrack.chunkOffsetTable[i];\n      const nextChunkLen = chunkOffset - this.tokenizer.position;\n      const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n      len -= nextChunkLen + sampleSize;\n      if (len < 0) throw new Error('Chapter chunk exceeding token length');\n      await this.tokenizer.ignore(nextChunkLen);\n      const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n      debug(`Chapter ${i + 1}: ${title}`);\n      const chapter = {\n        title,\n        sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n      };\n      debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n      chapters.push(chapter);\n    }\n    this.metadata.setFormat('chapters', chapters);\n    await this.tokenizer.ignore(len);\n  }\n  findSampleOffset(track, chapterOffset) {\n    let totalDuration = 0;\n    track.timeToSampleTable.forEach(e => {\n      totalDuration += e.count * e.duration;\n    });\n    debug(`Total duration=${totalDuration}`);\n    let chunkIndex = 0;\n    while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n      ++chunkIndex;\n    }\n    return this.getChunkDuration(chunkIndex + 1, track);\n  }\n  getChunkDuration(chunkId, track) {\n    let ttsi = 0;\n    let ttsc = track.timeToSampleTable[ttsi].count;\n    let ttsd = track.timeToSampleTable[ttsi].duration;\n    let curChunkId = 1;\n    let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n    let totalDuration = 0;\n    while (curChunkId < chunkId) {\n      const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n      totalDuration += nrOfSamples * ttsd;\n      ttsc -= nrOfSamples;\n      samplesPerChunk -= nrOfSamples;\n      if (samplesPerChunk === 0) {\n        ++curChunkId;\n        samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n      } else {\n        ++ttsi;\n        ttsc = track.timeToSampleTable[ttsi].count;\n        ttsd = track.timeToSampleTable[ttsi].duration;\n      }\n    }\n    return totalDuration;\n  }\n  getSamplesPerChunk(chunkId, stcTable) {\n    for (let i = 0; i < stcTable.length - 1; ++i) {\n      if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n        return stcTable[i].samplesPerChunk;\n      }\n    }\n    return stcTable[stcTable.length - 1].samplesPerChunk;\n  }\n}\nexports.MP4Parser = MP4Parser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}