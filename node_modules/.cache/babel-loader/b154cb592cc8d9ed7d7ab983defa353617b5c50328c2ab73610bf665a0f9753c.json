{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AIFFParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst AiffToken = require(\"./AiffToken\");\nconst iff = require(\"../iff\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\nconst compressionTypes = {\n  NONE: 'not compressed\tPCM\tApple Computer',\n  sowt: 'PCM (byte swapped)',\n  fl32: '32-bit floating point IEEE 32-bit float',\n  fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\n  alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\n  ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\n  ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\n  ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\n  FL32: 'Float 32\tIEEE 32-bit float '\n};\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n */\nclass AIFFParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(iff.Header);\n    if (header.chunkID !== 'FORM') throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    switch (type) {\n      case 'AIFF':\n        this.metadata.setFormat('container', type);\n        this.isCompressed = false;\n        break;\n      case 'AIFC':\n        this.metadata.setFormat('container', 'AIFF-C');\n        this.isCompressed = true;\n        break;\n      default:\n        throw Error('Unsupported AIFF type: ' + type);\n    }\n    this.metadata.setFormat('lossless', !this.isCompressed);\n    try {\n      while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n        debug('Reading AIFF chunk at offset=' + this.tokenizer.position);\n        const chunkHeader = await this.tokenizer.readToken(iff.Header);\n        const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n        const bytesRead = await this.readData(chunkHeader);\n        await this.tokenizer.ignore(nextChunk - bytesRead);\n      }\n    } catch (err) {\n      if (err instanceof strtok3.EndOfStreamError) {\n        debug(`End-of-stream`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  async readData(header) {\n    var _a;\n    switch (header.chunkID) {\n      case 'COMM':\n        // The Common Chunk\n        const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n        this.metadata.setFormat('bitsPerSample', common.sampleSize);\n        this.metadata.setFormat('sampleRate', common.sampleRate);\n        this.metadata.setFormat('numberOfChannels', common.numChannels);\n        this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n        this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n        this.metadata.setFormat('codec', (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]);\n        return header.chunkSize;\n      case 'ID3 ':\n        // ID3-meta-data\n        const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        return header.chunkSize;\n      case 'SSND':\n        // Sound Data Chunk\n        if (this.metadata.format.duration) {\n          this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n        }\n        return 0;\n      case 'NAME': // Sample name chunk\n      case 'AUTH': // Author chunk\n      case '(c) ': // Copyright chunk\n      case 'ANNO':\n        // Annotation chunk\n        return this.readTextChunk(header);\n      default:\n        debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\n        return 0;\n    }\n  }\n  async readTextChunk(header) {\n    const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\n    value.split('\\0').map(v => v.trim()).filter(v => v && v.length > 0).forEach(v => {\n      this.metadata.addTag('AIFF', header.chunkID, v.trim());\n    });\n    return header.chunkSize;\n  }\n}\nexports.AIFFParser = AIFFParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}