{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsfParser = void 0;\nconst debug_1 = require(\"debug\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst DsfChunk_1 = require(\"./DsfChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n  async postId3v2Parse() {\n    const p0 = this.tokenizer.position; // mark start position, normally 0\n    const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n    if (chunkHeader.id !== 'DSD ') throw new Error('Invalid chunk signature');\n    this.metadata.setFormat('container', 'DSF');\n    this.metadata.setFormat('lossless', true);\n    const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n    if (dsdChunk.metadataPointer === BigInt(0)) {\n      debug(`No ID3v2 tag present`);\n    } else {\n      debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n      await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n      // Jump to ID3 header\n      await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n      return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n    }\n  }\n  async parseChunks(bytesRemaining) {\n    while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n      debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n      switch (chunkHeader.id) {\n        case 'fmt ':\n          const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n          this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n          this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n          this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n          this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n          this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n          const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n          this.metadata.setFormat('bitrate', bitrate);\n          return;\n        // We got what we want, stop further processing of chunks\n        default:\n          this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);\n          break;\n      }\n      bytesRemaining -= chunkHeader.size;\n    }\n  }\n}\nexports.DsfParser = DsfParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}