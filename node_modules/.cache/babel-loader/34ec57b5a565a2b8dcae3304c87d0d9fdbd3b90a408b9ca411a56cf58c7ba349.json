{"ast":null,"code":"import { createClient } from '@supabase/supabase-js';\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase credentials in .env file');\n}\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n/**\r\n * Upload M4B file to Supabase storage\r\n */\nexport async function uploadAudioFile(file, onProgress) {\n  try {\n    const fileName = `${Date.now()}_${file.name}`;\n    const {\n      data,\n      error\n    } = await supabase.storage.from('audiobooks').upload(fileName, file, {\n      cacheControl: '3600',\n      upsert: false\n    });\n    if (error) throw error;\n    return {\n      storagePath: data.path,\n      publicUrl: supabase.storage.from('audiobooks').getPublicUrl(data.path).data.publicUrl\n    };\n  } catch (error) {\n    console.error('Error uploading file:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Save audiobook metadata to database\r\n */\nexport async function saveLibraryEntry(metadata) {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('library').insert([{\n      file_name: metadata.fileName,\n      title: metadata.title,\n      artist: metadata.artist,\n      album: metadata.album,\n      duration: metadata.duration,\n      storage_path: metadata.storagePath,\n      cover_url: metadata.coverUrl || null\n    }]).select();\n    if (error) throw error;\n    return data[0];\n  } catch (error) {\n    console.error('Error saving library entry:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Get all audiobooks from library\r\n */\nexport async function getLibrary() {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('library').select('*').order('created_at', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error fetching library:', error);\n    return [];\n  }\n}\n\n/**\r\n * Delete audiobook from library and storage\r\n */\nexport async function deleteLibraryEntry(id, storagePath) {\n  try {\n    // Delete from storage\n    if (storagePath) {\n      await supabase.storage.from('audiobooks').remove([storagePath]);\n    }\n\n    // Delete from database\n    const {\n      error\n    } = await supabase.from('library').delete().eq('id', id);\n    if (error) throw error;\n  } catch (error) {\n    console.error('Error deleting library entry:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Update playback state (position, speed, volume, etc)\r\n */\nexport async function updatePlaybackState(libraryId, state) {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('playback_state').upsert([{\n      library_id: libraryId,\n      current_position: state.currentPosition || 0,\n      is_playing: state.isPlaying || false,\n      playback_speed: state.playbackSpeed || 1,\n      volume: state.volume || 1,\n      is_muted: state.isMuted || false,\n      last_updated: new Date().toISOString()\n    }], {\n      onConflict: 'library_id'\n    }).select();\n    if (error) throw error;\n    return data[0];\n  } catch (error) {\n    console.error('Error updating playback state:', error);\n  }\n}\n\n/**\r\n * Get playback state for an audiobook\r\n */\nexport async function getPlaybackState(libraryId) {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('playback_state').select('*').eq('library_id', libraryId).single();\n    if (error && error.code !== 'PGRST116') throw error; // PGRST116 = no rows found\n    return data || null;\n  } catch (error) {\n    console.error('Error fetching playback state:', error);\n    return null;\n  }\n}\n\n/**\r\n * Subscribe to real-time playback state updates\r\n * Useful for syncing across browser tabs\r\n */\nexport function subscribeToPlaybackState(libraryId, callback) {\n  return supabase.from(`playback_state:library_id=eq.${libraryId}`).on('*', payload => {\n    callback(payload.new);\n  }).subscribe();\n}","map":{"version":3,"names":["createClient","supabaseUrl","process","env","REACT_APP_SUPABASE_URL","supabaseAnonKey","REACT_APP_SUPABASE_ANON_KEY","Error","supabase","uploadAudioFile","file","onProgress","fileName","Date","now","name","data","error","storage","from","upload","cacheControl","upsert","storagePath","path","publicUrl","getPublicUrl","console","saveLibraryEntry","metadata","insert","file_name","title","artist","album","duration","storage_path","cover_url","coverUrl","select","getLibrary","order","ascending","deleteLibraryEntry","id","remove","delete","eq","updatePlaybackState","libraryId","state","library_id","current_position","currentPosition","is_playing","isPlaying","playback_speed","playbackSpeed","volume","is_muted","isMuted","last_updated","toISOString","onConflict","getPlaybackState","single","code","subscribeToPlaybackState","callback","on","payload","new","subscribe"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/supabaseClient.js"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\r\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\r\n\r\nif (!supabaseUrl || !supabaseAnonKey) {\r\n  throw new Error('Missing Supabase credentials in .env file');\r\n}\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\r\n\r\n/**\r\n * Upload M4B file to Supabase storage\r\n */\r\nexport async function uploadAudioFile(file, onProgress) {\r\n  try {\r\n    const fileName = `${Date.now()}_${file.name}`;\r\n    \r\n    const { data, error } = await supabase.storage\r\n      .from('audiobooks')\r\n      .upload(fileName, file, {\r\n        cacheControl: '3600',\r\n        upsert: false,\r\n      });\r\n\r\n    if (error) throw error;\r\n\r\n    return {\r\n      storagePath: data.path,\r\n      publicUrl: supabase.storage.from('audiobooks').getPublicUrl(data.path).data.publicUrl\r\n    };\r\n  } catch (error) {\r\n    console.error('Error uploading file:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Save audiobook metadata to database\r\n */\r\nexport async function saveLibraryEntry(metadata) {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('library')\r\n      .insert([{\r\n        file_name: metadata.fileName,\r\n        title: metadata.title,\r\n        artist: metadata.artist,\r\n        album: metadata.album,\r\n        duration: metadata.duration,\r\n        storage_path: metadata.storagePath,\r\n        cover_url: metadata.coverUrl || null\r\n      }])\r\n      .select();\r\n\r\n    if (error) throw error;\r\n    return data[0];\r\n  } catch (error) {\r\n    console.error('Error saving library entry:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all audiobooks from library\r\n */\r\nexport async function getLibrary() {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('library')\r\n      .select('*')\r\n      .order('created_at', { ascending: false });\r\n\r\n    if (error) throw error;\r\n    return data || [];\r\n  } catch (error) {\r\n    console.error('Error fetching library:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Delete audiobook from library and storage\r\n */\r\nexport async function deleteLibraryEntry(id, storagePath) {\r\n  try {\r\n    // Delete from storage\r\n    if (storagePath) {\r\n      await supabase.storage\r\n        .from('audiobooks')\r\n        .remove([storagePath]);\r\n    }\r\n\r\n    // Delete from database\r\n    const { error } = await supabase\r\n      .from('library')\r\n      .delete()\r\n      .eq('id', id);\r\n\r\n    if (error) throw error;\r\n  } catch (error) {\r\n    console.error('Error deleting library entry:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Update playback state (position, speed, volume, etc)\r\n */\r\nexport async function updatePlaybackState(libraryId, state) {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('playback_state')\r\n      .upsert([{\r\n        library_id: libraryId,\r\n        current_position: state.currentPosition || 0,\r\n        is_playing: state.isPlaying || false,\r\n        playback_speed: state.playbackSpeed || 1,\r\n        volume: state.volume || 1,\r\n        is_muted: state.isMuted || false,\r\n        last_updated: new Date().toISOString()\r\n      }], { onConflict: 'library_id' })\r\n      .select();\r\n\r\n    if (error) throw error;\r\n    return data[0];\r\n  } catch (error) {\r\n    console.error('Error updating playback state:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Get playback state for an audiobook\r\n */\r\nexport async function getPlaybackState(libraryId) {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('playback_state')\r\n      .select('*')\r\n      .eq('library_id', libraryId)\r\n      .single();\r\n\r\n    if (error && error.code !== 'PGRST116') throw error; // PGRST116 = no rows found\r\n    return data || null;\r\n  } catch (error) {\r\n    console.error('Error fetching playback state:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Subscribe to real-time playback state updates\r\n * Useful for syncing across browser tabs\r\n */\r\nexport function subscribeToPlaybackState(libraryId, callback) {\r\n  return supabase\r\n    .from(`playback_state:library_id=eq.${libraryId}`)\r\n    .on('*', payload => {\r\n      callback(payload.new);\r\n    })\r\n    .subscribe();\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}