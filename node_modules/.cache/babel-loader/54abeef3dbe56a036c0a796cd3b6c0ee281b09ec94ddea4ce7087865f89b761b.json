{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ParserFactory_1 = require(\"./ParserFactory\");\nconst RandomUint8ArrayReader_1 = require(\"./common/RandomUint8ArrayReader\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\nconst Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\nfunction parseStream(stream, fileInfo, options = {}) {\n  return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo), options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param uint8Array - Uint8Array holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\nasync function parseBuffer(uint8Array, fileInfo, options = {}) {\n  const bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);\n  await scanAppendingHeaders(bufferReader, options);\n  const tokenizer = strtok3.fromBuffer(uint8Array, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo);\n  return parseFromTokenizer(tokenizer, options);\n}\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\nfunction parseFromTokenizer(tokenizer, options) {\n  return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nfunction orderTags(nativeTags) {\n  const tags = {};\n  for (const tag of nativeTags) {\n    (tags[tag.id] = tags[tag.id] || []).push(tag.value);\n  }\n  return tags;\n}\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nfunction ratingToStars(rating) {\n  return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\nexports.ratingToStars = ratingToStars;\n/**\n * Select most likely cover image.\n * @param pictures Usually metadata.common.picture\n * @return Cover image, if any, otherwise null\n */\nfunction selectCover(pictures) {\n  return pictures ? pictures.reduce((acc, cur) => {\n    if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)']) return cur;\n    return acc;\n  }) : null;\n}\nexports.selectCover = selectCover;\nasync function scanAppendingHeaders(randomReader, options = {}) {\n  let apeOffset = randomReader.fileSize;\n  if (await (0, ID3v1Parser_1.hasID3v1Header)(randomReader)) {\n    apeOffset -= 128;\n    const lyricsLen = await (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);\n    apeOffset -= lyricsLen;\n  }\n  options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\nexports.scanAppendingHeaders = scanAppendingHeaders;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}