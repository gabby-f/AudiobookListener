{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gabby\\\\Documents\\\\Audiobook Listener\\\\src\\\\pages\\\\Audiobook.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { parseBlob } from 'music-metadata-browser';\nimport { extractM4BChapters } from '../utils/m4bParser';\nimport FileUploader from '../Components/audiobook/FileUploader';\nimport AudiobookPlayer from '../Components/audiobook/AudiobookPlayer';\nimport Library from '../Components/audiobook/Library';\nimport { saveFile, getFile, getLibraryEntry, updateLibraryEntry } from '../utils/idbFileStore';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst STORAGE_KEY = 'audiobook_player_state';\nexport default function AudiobookPage() {\n  _s();\n  const [currentFileId, setCurrentFileId] = useState(null);\n  const [audioFile, setAudioFile] = useState(null);\n  const [chapters, setChapters] = useState([]);\n  const [bookInfo, setBookInfo] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [savedState, setSavedState] = useState(null);\n\n  // Load saved state on mount\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY);\n    if (saved) {\n      try {\n        const state = JSON.parse(saved);\n        setSavedState(state);\n      } catch (error) {\n        console.error('Error loading saved state:', error);\n      }\n    }\n  }, []);\n  const parseM4BChapters = useCallback(async file => {\n    try {\n      const extractedChapters = [];\n      const info = {\n        title: null,\n        artist: null,\n        album: null,\n        cover: null\n      };\n\n      // First, try to extract chapters using binary parsing (like VLC)\n      console.log('Attempting to extract chapters from M4B file...');\n      const binaryChapters = await extractM4BChapters(file);\n      if (binaryChapters.length > 0) {\n        console.log(`Successfully extracted ${binaryChapters.length} chapters from binary parsing`);\n        extractedChapters.push(...binaryChapters);\n      }\n\n      // Also get metadata using music-metadata for title, artist, cover, etc.\n      let metadata;\n      try {\n        metadata = await parseBlob(file, {\n          duration: true,\n          skipCovers: false,\n          native: true\n        });\n\n        // Extract basic info\n        info.title = metadata.common.title || file.name.replace(/\\.[^/.]+$/, '');\n        info.artist = metadata.common.artist || metadata.common.albumartist || null;\n        info.album = metadata.common.album || null;\n\n        // Extract cover art\n        if (metadata.common.picture && metadata.common.picture.length > 0) {\n          const picture = metadata.common.picture[0];\n          const blob = new Blob([picture.data], {\n            type: picture.format\n          });\n          info.cover = URL.createObjectURL(blob);\n        }\n        const duration = metadata.format.duration || 0;\n\n        // If binary parsing didn't find chapters, try metadata\n        if (extractedChapters.length === 0) {\n          console.log('No chapters from binary parsing, trying music-metadata...');\n          if (metadata.native) {\n            // Check all native keys for chapter data\n            for (const key in metadata.native) {\n              const items = metadata.native[key];\n              if (Array.isArray(items)) {\n                const chapterItems = items.filter(tag => tag.id === 'chpl' || tag.id === 'chapters' || tag.mean && tag.mean.includes('chapter'));\n                if (chapterItems.length > 0) {\n                  console.log(`Found chapter items in native.${key}`);\n                  for (const chplData of chapterItems) {\n                    let chapters = [];\n                    if (Array.isArray(chplData.value)) {\n                      chapters = chplData.value;\n                    } else if (chplData.value && typeof chplData.value === 'object') {\n                      chapters = Array.isArray(chplData.value.chapters) ? chplData.value.chapters : Object.values(chplData.value);\n                    }\n                    for (const chapter of chapters) {\n                      if (chapter && (chapter.title || chapter.startTime !== undefined)) {\n                        extractedChapters.push({\n                          title: chapter.title || chapter.name || `Chapter ${extractedChapters.length + 1}`,\n                          startTime: (chapter.startTime || chapter.start || 0) / 1000,\n                          duration: null\n                        });\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Calculate chapter durations if chapters were found\n        if (extractedChapters.length > 0) {\n          extractedChapters.sort((a, b) => a.startTime - b.startTime);\n          extractedChapters.forEach((chapter, index) => {\n            const nextChapter = extractedChapters[index + 1];\n            chapter.duration = nextChapter ? nextChapter.startTime - chapter.startTime : duration - chapter.startTime;\n          });\n          console.log(`Successfully extracted ${extractedChapters.length} chapters`);\n          return {\n            chapters: extractedChapters,\n            info\n          };\n        }\n\n        // Fallback: create time-based chapters if no chapters found\n        if (duration > 0) {\n          const chapterDuration = 600; // 10 minute segments\n          const numChapters = Math.ceil(duration / chapterDuration);\n          for (let i = 0; i < numChapters; i++) {\n            const startTime = i * chapterDuration;\n            extractedChapters.push({\n              title: `Part ${i + 1}`,\n              startTime: startTime,\n              duration: Math.min(chapterDuration, duration - startTime)\n            });\n          }\n          console.log(`No chapters found. Created ${extractedChapters.length} time-based segments`);\n        }\n      } catch (metadataError) {\n        console.error('Error parsing metadata:', metadataError);\n        info.title = file.name.replace(/\\.[^/.]+$/, '');\n      }\n      return {\n        chapters: extractedChapters,\n        info\n      };\n    } catch (error) {\n      console.error('Error parsing M4B file:', error);\n      return {\n        chapters: [],\n        info: {\n          title: file.name.replace(/\\.[^/.]+$/, ''),\n          artist: null,\n          album: null,\n          cover: null\n        }\n      };\n    }\n  }, []);\n\n  // Try to restore previously uploaded file from IndexedDB\n  useEffect(() => {\n    const tryRestoreFile = async () => {\n      try {\n        const fileInfoRaw = localStorage.getItem(STORAGE_KEY + '_file');\n        if (!fileInfoRaw) return;\n        const fileInfo = JSON.parse(fileInfoRaw);\n        const blob = await getFile('audio');\n        if (blob) {\n          // Recreate a File from blob so components expecting File work\n          const restored = new File([blob], fileInfo.name, {\n            type: fileInfo.type || blob.type || 'application/octet-stream',\n            lastModified: fileInfo.lastModified || Date.now()\n          });\n          // Set file and parse chapters\n          // Indicate this was a restore so the player may attempt autoplay\n          setAutoPlayRestore(true);\n          setRestoreTitle(fileInfo.name || restored.name || 'Restored book');\n          setAudioFile(restored);\n          const {\n            chapters: extractedChapters,\n            info\n          } = await parseM4BChapters(restored);\n          setChapters(extractedChapters);\n          setBookInfo(info);\n        }\n      } catch (err) {\n        console.warn('No stored file to restore or restore failed:', err);\n      }\n    };\n    tryRestoreFile();\n  }, []); // parseM4BChapters doesn't change, so it's safe to exclude from deps\n\n  const handleFileSelect = useCallback(async file => {\n    setIsLoading(true);\n    try {\n      const {\n        chapters: extractedChapters,\n        info\n      } = await parseM4BChapters(file);\n      setChapters(extractedChapters);\n      setBookInfo(info);\n      setAudioFile(file);\n\n      // Save file to library with metadata\n      try {\n        const fileId = await saveFile(file, {\n          title: info.title || file.name.replace(/\\.[^/.]+$/, ''),\n          artist: info.artist || 'Unknown Artist',\n          cover: info.cover || null,\n          duration: info.duration || 0\n        });\n        setCurrentFileId(fileId);\n      } catch (idbErr) {\n        console.warn('Failed to save file to library:', idbErr);\n      }\n    } catch (error) {\n      console.error('Error parsing audiobook:', error);\n      setAudioFile(file);\n      setChapters([]);\n      setBookInfo({\n        title: file.name.replace(/\\.[^/.]+$/, '')\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [parseM4BChapters]);\n  const handleClose = useCallback(() => {\n    setAudioFile(null);\n    setChapters([]);\n    setBookInfo(null);\n    setCurrentFileId(null);\n    setSavedState(null);\n    // Clear saved state\n    try {\n      localStorage.removeItem(STORAGE_KEY);\n    } catch (err) {\n      // ignore\n    }\n  }, []);\n  const handleLibrarySelect = useCallback(async (fileId, libraryEntry) => {\n    setIsLoading(true);\n    try {\n      // Load file from IndexedDB\n      const file = await getFile(fileId);\n      if (!file) {\n        throw new Error('File not found in storage');\n      }\n\n      // Parse chapters\n      const {\n        chapters: extractedChapters,\n        info\n      } = await parseM4BChapters(file);\n      setChapters(extractedChapters);\n      setBookInfo({\n        ...info,\n        title: libraryEntry.title || info.title,\n        artist: libraryEntry.artist || info.artist,\n        cover: libraryEntry.cover || info.cover\n      });\n      setAudioFile(file);\n      setCurrentFileId(fileId);\n\n      // Load saved playback position\n      const playbackPosition = libraryEntry.playbackPosition || 0;\n      setSavedState({\n        currentTime: playbackPosition,\n        currentChapterIndex: 0\n      });\n    } catch (error) {\n      console.error('Error loading file from library:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [parseM4BChapters]);\n  const handleSaveState = useCallback(state => {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\",\n    children: !audioFile ? /*#__PURE__*/_jsxDEV(FileUploader, {\n      onFileSelect: handleFileSelect,\n      isLoading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 289,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"h-screen\",\n      children: /*#__PURE__*/_jsxDEV(AudiobookPlayer, {\n        file: audioFile,\n        chapters: chapters,\n        bookInfo: bookInfo,\n        onClose: handleClose,\n        savedState: savedState,\n        onSaveState: handleSaveState,\n        autoPlayRestore: autoPlayRestore,\n        onAutoPlayHandled: () => {\n          setAutoPlayRestore(false);\n          setRestoreTitle(null);\n        },\n        restoreTitle: restoreTitle\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 294,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 287,\n    columnNumber: 9\n  }, this);\n}\n_s(AudiobookPage, \"EH2PAdgB/46Lf5DbCMKOZ83EioI=\");\n_c = AudiobookPage;\nvar _c;\n$RefreshReg$(_c, \"AudiobookPage\");","map":{"version":3,"names":["React","useState","useCallback","useEffect","parseBlob","extractM4BChapters","FileUploader","AudiobookPlayer","Library","saveFile","getFile","getLibraryEntry","updateLibraryEntry","jsxDEV","_jsxDEV","STORAGE_KEY","AudiobookPage","_s","currentFileId","setCurrentFileId","audioFile","setAudioFile","chapters","setChapters","bookInfo","setBookInfo","isLoading","setIsLoading","savedState","setSavedState","saved","localStorage","getItem","state","JSON","parse","error","console","parseM4BChapters","file","extractedChapters","info","title","artist","album","cover","log","binaryChapters","length","push","metadata","duration","skipCovers","native","common","name","replace","albumartist","picture","blob","Blob","data","type","format","URL","createObjectURL","key","items","Array","isArray","chapterItems","filter","tag","id","mean","includes","chplData","value","Object","values","chapter","startTime","undefined","start","sort","a","b","forEach","index","nextChapter","chapterDuration","numChapters","Math","ceil","i","min","metadataError","tryRestoreFile","fileInfoRaw","fileInfo","restored","File","lastModified","Date","now","setAutoPlayRestore","setRestoreTitle","err","warn","handleFileSelect","fileId","idbErr","handleClose","removeItem","handleLibrarySelect","libraryEntry","Error","playbackPosition","currentTime","currentChapterIndex","handleSaveState","setItem","stringify","className","children","onFileSelect","fileName","_jsxFileName","lineNumber","columnNumber","onClose","onSaveState","autoPlayRestore","onAutoPlayHandled","restoreTitle","_c","$RefreshReg$"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/pages/Audiobook.jsx"],"sourcesContent":["import React, { useState, useCallback, useEffect } from 'react';\r\nimport { parseBlob } from 'music-metadata-browser';\r\nimport { extractM4BChapters } from '../utils/m4bParser';\r\nimport FileUploader from '../Components/audiobook/FileUploader';\r\nimport AudiobookPlayer from '../Components/audiobook/AudiobookPlayer';\r\nimport Library from '../Components/audiobook/Library';\r\nimport { saveFile, getFile, getLibraryEntry, updateLibraryEntry } from '../utils/idbFileStore';\r\n\r\nconst STORAGE_KEY = 'audiobook_player_state';\r\n\r\nexport default function AudiobookPage() {\r\n    const [currentFileId, setCurrentFileId] = useState(null);\r\n    const [audioFile, setAudioFile] = useState(null);\r\n    const [chapters, setChapters] = useState([]);\r\n    const [bookInfo, setBookInfo] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [savedState, setSavedState] = useState(null);\r\n\r\n    // Load saved state on mount\r\n    useEffect(() => {\r\n        const saved = localStorage.getItem(STORAGE_KEY);\r\n        if (saved) {\r\n            try {\r\n                const state = JSON.parse(saved);\r\n                setSavedState(state);\r\n            } catch (error) {\r\n                console.error('Error loading saved state:', error);\r\n            }\r\n        }\r\n    }, []);\r\n    \r\n    const parseM4BChapters = useCallback(async (file) => {\r\n        try {\r\n            const extractedChapters = [];\r\n            const info = {\r\n                title: null,\r\n                artist: null,\r\n                album: null,\r\n                cover: null\r\n            };\r\n            \r\n            // First, try to extract chapters using binary parsing (like VLC)\r\n            console.log('Attempting to extract chapters from M4B file...');\r\n            const binaryChapters = await extractM4BChapters(file);\r\n            \r\n            if (binaryChapters.length > 0) {\r\n                console.log(`Successfully extracted ${binaryChapters.length} chapters from binary parsing`);\r\n                extractedChapters.push(...binaryChapters);\r\n            }\r\n            \r\n            // Also get metadata using music-metadata for title, artist, cover, etc.\r\n            let metadata;\r\n            try {\r\n                metadata = await parseBlob(file, { \r\n                    duration: true,\r\n                    skipCovers: false,\r\n                    native: true\r\n                });\r\n                \r\n                // Extract basic info\r\n                info.title = metadata.common.title || file.name.replace(/\\.[^/.]+$/, '');\r\n                info.artist = metadata.common.artist || metadata.common.albumartist || null;\r\n                info.album = metadata.common.album || null;\r\n                \r\n                // Extract cover art\r\n                if (metadata.common.picture && metadata.common.picture.length > 0) {\r\n                    const picture = metadata.common.picture[0];\r\n                    const blob = new Blob([picture.data], { type: picture.format });\r\n                    info.cover = URL.createObjectURL(blob);\r\n                }\r\n                \r\n                const duration = metadata.format.duration || 0;\r\n                \r\n                // If binary parsing didn't find chapters, try metadata\r\n                if (extractedChapters.length === 0) {\r\n                    console.log('No chapters from binary parsing, trying music-metadata...');\r\n                    \r\n                    if (metadata.native) {\r\n                        // Check all native keys for chapter data\r\n                        for (const key in metadata.native) {\r\n                            const items = metadata.native[key];\r\n                            \r\n                            if (Array.isArray(items)) {\r\n                                const chapterItems = items.filter(tag => \r\n                                    tag.id === 'chpl' || \r\n                                    tag.id === 'chapters' ||\r\n                                    (tag.mean && tag.mean.includes('chapter'))\r\n                                );\r\n                                \r\n                                if (chapterItems.length > 0) {\r\n                                    console.log(`Found chapter items in native.${key}`);\r\n                                    \r\n                                    for (const chplData of chapterItems) {\r\n                                        let chapters = [];\r\n                                        if (Array.isArray(chplData.value)) {\r\n                                            chapters = chplData.value;\r\n                                        } else if (chplData.value && typeof chplData.value === 'object') {\r\n                                            chapters = Array.isArray(chplData.value.chapters) \r\n                                                ? chplData.value.chapters \r\n                                                : Object.values(chplData.value);\r\n                                        }\r\n                                        \r\n                                        for (const chapter of chapters) {\r\n                                            if (chapter && (chapter.title || chapter.startTime !== undefined)) {\r\n                                                extractedChapters.push({\r\n                                                    title: chapter.title || chapter.name || `Chapter ${extractedChapters.length + 1}`,\r\n                                                    startTime: (chapter.startTime || chapter.start || 0) / 1000,\r\n                                                    duration: null\r\n                                                });\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // Calculate chapter durations if chapters were found\r\n                if (extractedChapters.length > 0) {\r\n                    extractedChapters.sort((a, b) => a.startTime - b.startTime);\r\n                    \r\n                    extractedChapters.forEach((chapter, index) => {\r\n                        const nextChapter = extractedChapters[index + 1];\r\n                        chapter.duration = nextChapter \r\n                            ? nextChapter.startTime - chapter.startTime\r\n                            : duration - chapter.startTime;\r\n                    });\r\n                    \r\n                    console.log(`Successfully extracted ${extractedChapters.length} chapters`);\r\n                    return { chapters: extractedChapters, info };\r\n                }\r\n                \r\n                // Fallback: create time-based chapters if no chapters found\r\n                if (duration > 0) {\r\n                    const chapterDuration = 600; // 10 minute segments\r\n                    const numChapters = Math.ceil(duration / chapterDuration);\r\n                    \r\n                    for (let i = 0; i < numChapters; i++) {\r\n                        const startTime = i * chapterDuration;\r\n                        extractedChapters.push({\r\n                            title: `Part ${i + 1}`,\r\n                            startTime: startTime,\r\n                            duration: Math.min(chapterDuration, duration - startTime)\r\n                        });\r\n                    }\r\n                    \r\n                    console.log(`No chapters found. Created ${extractedChapters.length} time-based segments`);\r\n                }\r\n                \r\n            } catch (metadataError) {\r\n                console.error('Error parsing metadata:', metadataError);\r\n                info.title = file.name.replace(/\\.[^/.]+$/, '');\r\n            }\r\n            \r\n            return { chapters: extractedChapters, info };\r\n            \r\n        } catch (error) {\r\n            console.error('Error parsing M4B file:', error);\r\n            return { \r\n                chapters: [], \r\n                info: { \r\n                    title: file.name.replace(/\\.[^/.]+$/, ''), \r\n                    artist: null, \r\n                    album: null,\r\n                    cover: null \r\n                } \r\n            };\r\n        }\r\n    }, []);\r\n\r\n    // Try to restore previously uploaded file from IndexedDB\r\n    useEffect(() => {\r\n        const tryRestoreFile = async () => {\r\n            try {\r\n                const fileInfoRaw = localStorage.getItem(STORAGE_KEY + '_file');\r\n                if (!fileInfoRaw) return;\r\n                const fileInfo = JSON.parse(fileInfoRaw);\r\n                const blob = await getFile('audio');\r\n                if (blob) {\r\n                    // Recreate a File from blob so components expecting File work\r\n                    const restored = new File([blob], fileInfo.name, {\r\n                        type: fileInfo.type || blob.type || 'application/octet-stream',\r\n                        lastModified: fileInfo.lastModified || Date.now()\r\n                    });\r\n                    // Set file and parse chapters\r\n                    // Indicate this was a restore so the player may attempt autoplay\r\n                    setAutoPlayRestore(true);\r\n                    setRestoreTitle(fileInfo.name || restored.name || 'Restored book');\r\n                    setAudioFile(restored);\r\n                    const { chapters: extractedChapters, info } = await parseM4BChapters(restored);\r\n                    setChapters(extractedChapters);\r\n                    setBookInfo(info);\r\n                }\r\n            } catch (err) {\r\n                console.warn('No stored file to restore or restore failed:', err);\r\n            }\r\n        };\r\n\r\n        tryRestoreFile();\r\n    }, []); // parseM4BChapters doesn't change, so it's safe to exclude from deps\r\n\r\n    const handleFileSelect = useCallback(async (file) => {\r\n        setIsLoading(true);\r\n        \r\n        try {\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo(info);\r\n            setAudioFile(file);\r\n            \r\n            // Save file to library with metadata\r\n            try {\r\n                const fileId = await saveFile(file, {\r\n                    title: info.title || file.name.replace(/\\.[^/.]+$/, ''),\r\n                    artist: info.artist || 'Unknown Artist',\r\n                    cover: info.cover || null,\r\n                    duration: info.duration || 0,\r\n                });\r\n                setCurrentFileId(fileId);\r\n            } catch (idbErr) {\r\n                console.warn('Failed to save file to library:', idbErr);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error parsing audiobook:', error);\r\n            setAudioFile(file);\r\n            setChapters([]);\r\n            setBookInfo({ title: file.name.replace(/\\.[^/.]+$/, '') });\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleClose = useCallback(() => {\r\n        setAudioFile(null);\r\n        setChapters([]);\r\n        setBookInfo(null);\r\n        setCurrentFileId(null);\r\n        setSavedState(null);\r\n        // Clear saved state\r\n        try {\r\n            localStorage.removeItem(STORAGE_KEY);\r\n        } catch (err) {\r\n            // ignore\r\n        }\r\n    }, []);\r\n\r\n    const handleLibrarySelect = useCallback(async (fileId, libraryEntry) => {\r\n        setIsLoading(true);\r\n        try {\r\n            // Load file from IndexedDB\r\n            const file = await getFile(fileId);\r\n            if (!file) {\r\n                throw new Error('File not found in storage');\r\n            }\r\n\r\n            // Parse chapters\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo({\r\n                ...info,\r\n                title: libraryEntry.title || info.title,\r\n                artist: libraryEntry.artist || info.artist,\r\n                cover: libraryEntry.cover || info.cover,\r\n            });\r\n            setAudioFile(file);\r\n            setCurrentFileId(fileId);\r\n\r\n            // Load saved playback position\r\n            const playbackPosition = libraryEntry.playbackPosition || 0;\r\n            setSavedState({\r\n                currentTime: playbackPosition,\r\n                currentChapterIndex: 0,\r\n            });\r\n        } catch (error) {\r\n            console.error('Error loading file from library:', error);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleSaveState = useCallback((state) => {\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\r\n    }, []);\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\">\r\n            {!audioFile ? (\r\n                <FileUploader \r\n                    onFileSelect={handleFileSelect} \r\n                    isLoading={isLoading}\r\n                />\r\n            ) : (\r\n                <div className=\"h-screen\">\r\n                    <AudiobookPlayer\r\n                        file={audioFile}\r\n                        chapters={chapters}\r\n                        bookInfo={bookInfo}\r\n                        onClose={handleClose}\r\n                        savedState={savedState}\r\n                        onSaveState={handleSaveState}\r\n                        autoPlayRestore={autoPlayRestore}\r\n                        onAutoPlayHandled={() => { setAutoPlayRestore(false); setRestoreTitle(null); }}\r\n                        restoreTitle={restoreTitle}\r\n                    />\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}