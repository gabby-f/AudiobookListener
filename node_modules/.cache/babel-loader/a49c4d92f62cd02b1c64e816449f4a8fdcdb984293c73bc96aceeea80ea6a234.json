{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\nconst initDebug = require(\"debug\");\nconst mm = require(\"music-metadata/lib/core\");\nconst readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\nconst debug = initDebug('music-metadata-browser:main');\nvar core_1 = require(\"music-metadata/lib/core\");\nObject.defineProperty(exports, \"parseBuffer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseBuffer;\n  }\n});\nObject.defineProperty(exports, \"parseFromTokenizer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseFromTokenizer;\n  }\n});\nObject.defineProperty(exports, \"orderTags\", {\n  enumerable: true,\n  get: function () {\n    return core_1.orderTags;\n  }\n});\nObject.defineProperty(exports, \"ratingToStars\", {\n  enumerable: true,\n  get: function () {\n    return core_1.ratingToStars;\n  }\n});\nObject.defineProperty(exports, \"selectCover\", {\n  enumerable: true,\n  get: function () {\n    return core_1.selectCover;\n  }\n});\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nexports.parseNodeStream = mm.parseStream;\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream (web stream according WTWG Streams Standard)\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nasync function parseReadableStream(stream, fileInfo, options) {\n  const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\n  const res = await (0, exports.parseNodeStream)(ns, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo, options);\n  await ns.close();\n  return res;\n}\nexports.parseReadableStream = parseReadableStream;\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nasync function parseBlob(blob, options) {\n  const fileInfo = {\n    mimeType: blob.type,\n    size: blob.size\n  };\n  if (blob instanceof File) {\n    fileInfo.path = blob.name;\n  }\n  const stream = blob.stream ? blob.stream() : convertBlobToReadableStream(blob);\n  return parseReadableStream(stream, {\n    mimeType: blob.type,\n    size: blob.size\n  }, options);\n}\nexports.parseBlob = parseBlob;\n/**\r\n * Convert Blob to ReadableStream\r\n * Fallback for Safari versions < 14.1\r\n * @param blob\r\n */\nfunction convertBlobToReadableStream(blob) {\n  const fileReader = new FileReader();\n  return new ReadableStream({\n    start(controller) {\n      // The following function handles each data chunk\n      fileReader.onloadend = event => {\n        let data = event.target.result;\n        if (data instanceof ArrayBuffer) {\n          data = new Uint8Array(data);\n        }\n        controller.enqueue(data);\n        controller.close();\n      };\n      fileReader.onerror = error => {\n        controller.close();\n      };\n      fileReader.onabort = error => {\n        controller.close();\n      };\n      fileReader.readAsArrayBuffer(blob);\n    }\n  });\n}\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nasync function fetchFromUrl(audioTrackUrl, options) {\n  const response = await fetch(audioTrackUrl);\n  const fileInfo = {\n    size: parseInt(response.headers.get('Content-Length'), 10),\n    mimeType: response.headers.get('Content-Type')\n  };\n  if (response.ok) {\n    if (response.body) {\n      const res = await parseReadableStream(response.body, fileInfo, options);\n      debug('Closing HTTP-readable-stream...');\n      if (!response.body.locked) {\n        // Prevent error in Firefox\n        await response.body.cancel();\n      }\n      debug('HTTP-readable-stream closed.');\n      return res;\n    } else {\n      // Fall back on Blob\n      return parseBlob(await response.blob(), options);\n    }\n  } else {\n    throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\n  }\n}\nexports.fetchFromUrl = fetchFromUrl;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}