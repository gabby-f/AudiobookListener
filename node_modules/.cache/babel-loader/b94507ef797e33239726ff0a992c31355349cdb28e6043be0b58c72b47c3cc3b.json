{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WavPackParser = void 0;\nconst Token = require(\"token-types\");\nconst APEv2Parser_1 = require(\"../apev2/APEv2Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst WavPackToken_1 = require(\"./WavPackToken\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)('music-metadata:parser:WavPack');\n/**\n * WavPack Parser\n */\nclass WavPackParser extends BasicParser_1.BasicParser {\n  async parse() {\n    this.audioDataSize = 0;\n    // First parse all WavPack blocks\n    await this.parseWavPackBlocks();\n    // try to parse APEv2 header\n    return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n  }\n  async parseWavPackBlocks() {\n    do {\n      const blockId = await this.tokenizer.peekToken(FourCC_1.FourCcToken);\n      if (blockId !== 'wvpk') break;\n      const header = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);\n      if (header.BlockID !== 'wvpk') throw new Error('Invalid WavPack Block-ID');\n      debug(`WavPack header blockIndex=${header.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`);\n      if (header.blockIndex === 0 && !this.metadata.format.container) {\n        this.metadata.setFormat('container', 'WavPack');\n        this.metadata.setFormat('lossless', !header.flags.isHybrid);\n        // tagTypes: this.type,\n        this.metadata.setFormat('bitsPerSample', header.flags.bitsPerSample);\n        if (!header.flags.isDSD) {\n          // In case isDSD, these values will ne set in ID_DSD_BLOCK\n          this.metadata.setFormat('sampleRate', header.flags.samplingRate);\n          this.metadata.setFormat('duration', header.totalSamples / header.flags.samplingRate);\n        }\n        this.metadata.setFormat('numberOfChannels', header.flags.isMono ? 1 : 2);\n        this.metadata.setFormat('numberOfSamples', header.totalSamples);\n        this.metadata.setFormat('codec', header.flags.isDSD ? 'DSD' : 'PCM');\n      }\n      const ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);\n      await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));\n      if (header.blockSamples > 0) {\n        this.audioDataSize += header.blockSize; // Count audio data for bit-rate calculation\n      }\n    } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);\n    this.metadata.setFormat('bitrate', this.audioDataSize * 8 / this.metadata.format.duration);\n  }\n  /**\n   * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks\n   * @param remainingLength\n   */\n  async parseMetadataSubBlock(header, remainingLength) {\n    while (remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len) {\n      const id = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken);\n      const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? Token.UINT24_LE : Token.UINT8);\n      const data = Buffer.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));\n      await this.tokenizer.readBuffer(data);\n      debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);\n      switch (id.functionId) {\n        case 0x0:\n          // ID_DUMMY: could be used to pad WavPack blocks\n          break;\n        case 0xe:\n          // ID_DSD_BLOCK\n          debug('ID_DSD_BLOCK');\n          // https://github.com/dbry/WavPack/issues/71#issuecomment-483094813\n          const mp = 1 << data.readUInt8(0);\n          const samplingRate = header.flags.samplingRate * mp * 8; // ToDo: second factor should be read from DSD-metadata block https://github.com/dbry/WavPack/issues/71#issuecomment-483094813\n          if (!header.flags.isDSD) throw new Error('Only expect DSD block if DSD-flag is set');\n          this.metadata.setFormat('sampleRate', samplingRate);\n          this.metadata.setFormat('duration', header.totalSamples / samplingRate);\n          break;\n        case 0x24:\n          // ID_ALT_TRAILER: maybe used to embed original ID3 tag header\n          debug('ID_ALT_TRAILER: trailer for non-wav files');\n          break;\n        case 0x26:\n          // ID_MD5_CHECKSUM\n          this.metadata.setFormat('audioMD5', data);\n          break;\n        case 0x2f:\n          // ID_BLOCK_CHECKSUM\n          debug(`ID_BLOCK_CHECKSUM: checksum=${data.toString('hex')}`);\n          break;\n        default:\n          debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);\n          break;\n      }\n      remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token.UINT24_LE.len : Token.UINT8.len) + dataSizeInWords * 2;\n      debug(`remainingLength=${remainingLength}`);\n      if (id.isOddSize) this.tokenizer.ignore(1);\n    }\n    if (remainingLength !== 0) throw new Error('metadata-sub-block should fit it remaining length');\n  }\n}\nexports.WavPackParser = WavPackParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}