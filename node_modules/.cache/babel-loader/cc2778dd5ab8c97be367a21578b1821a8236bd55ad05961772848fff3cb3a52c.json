{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tslib_1 = require(\"tslib\");\nconst PostgrestFilterBuilder_1 = tslib_1.__importDefault(require(\"./PostgrestFilterBuilder\"));\nclass PostgrestQueryBuilder {\n  /**\n   * Creates a query builder scoped to a Postgres table or view.\n   *\n   * @example\n   * ```ts\n   * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n   *\n   * const query = new PostgrestQueryBuilder(\n   *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n   *   { headers: { apikey: 'public-anon-key' } }\n   * )\n   * ```\n   */\n  constructor(url, {\n    headers = {},\n    schema,\n    fetch\n  }) {\n    this.url = url;\n    this.headers = new Headers(headers);\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select(columns, options) {\n    const {\n      head = false,\n      count\n    } = options !== null && options !== void 0 ? options : {};\n    const method = head ? 'HEAD' : 'GET';\n    // Remove whitespaces except when quoted\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`);\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch\n    });\n  }\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert(values, {\n    count,\n    defaultToNull = true\n  } = {}) {\n    var _a;\n    const method = 'POST';\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`);\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', `missing=default`);\n    }\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n  /**\n  * Perform an UPSERT on the table or view. Depending on the column(s) passed\n  * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n  * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n  * exist, or if it does exist, perform an alternative action depending on\n  * `ignoreDuplicates`.\n  *\n  * By default, upserted rows are not returned. To return it, chain the call\n  * with `.select()`.\n  *\n  * @param values - The values to upsert with. Pass an object to upsert a\n  * single row or an array to upsert multiple rows.\n  *\n  * @param options - Named parameters\n  *\n  * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n  * duplicate rows are determined. Two rows are duplicates if all the\n  * `onConflict` columns are equal.\n  *\n  * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n  * `false`, duplicate rows are merged with existing rows.\n  *\n  * @param options.count - Count algorithm to use to count upserted rows.\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  *\n  * @param options.defaultToNull - Make missing fields default to `null`.\n  * Otherwise, use the default value for the column. This only applies when\n  * inserting new rows, not when merging with existing rows under\n  * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n  *\n  * @example Upsert a single row using a unique key\n  * ```ts\n  * // Upserting a single row, overwriting based on the 'username' unique column\n  * const { data, error } = await supabase\n  *   .from('users')\n  *   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n  *\n  * // Example response:\n  * // {\n  * //   data: [\n  * //     { id: 4, message: 'bar', username: 'supabot' }\n  * //   ],\n  * //   error: null\n  * // }\n  * ```\n  *\n  * @example Upsert with conflict resolution and exact row counting\n  * ```ts\n  * // Upserting and returning exact count\n  * const { data, error, count } = await supabase\n  *   .from('users')\n  *   .upsert(\n  *     {\n  *       id: 3,\n  *       message: 'foo',\n  *       username: 'supabot'\n  *     },\n  *     {\n  *       onConflict: 'username',\n  *       count: 'exact'\n  *     }\n  *   )\n  *\n  * // Example response:\n  * // {\n  * //   data: [\n  * //     {\n  * //       id: 42,\n  * //       handle: \"saoirse\",\n  * //       display_name: \"Saoirse\"\n  * //     }\n  * //   ],\n  * //   count: 1,\n  * //   error: null\n  * // }\n  * ```\n  */\n  upsert(values, {\n    onConflict,\n    ignoreDuplicates = false,\n    count,\n    defaultToNull = true\n  } = {}) {\n    var _a;\n    const method = 'POST';\n    this.headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`);\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`);\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', 'missing=default');\n    }\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update(values, {\n    count\n  } = {}) {\n    var _a;\n    const method = 'PATCH';\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`);\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count\n  } = {}) {\n    var _a;\n    const method = 'DELETE';\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`);\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n}\nexports.default = PostgrestQueryBuilder;\n//# sourceMappingURL=PostgrestQueryBuilder.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}