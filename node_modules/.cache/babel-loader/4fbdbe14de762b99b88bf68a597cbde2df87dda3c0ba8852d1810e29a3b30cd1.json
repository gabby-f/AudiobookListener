{"ast":null,"code":"export default class Serializer {\n  constructor(allowedMetadataKeys) {\n    this.HEADER_LENGTH = 1;\n    this.USER_BROADCAST_PUSH_META_LENGTH = 6;\n    this.KINDS = {\n      userBroadcastPush: 3,\n      userBroadcast: 4\n    };\n    this.BINARY_ENCODING = 0;\n    this.JSON_ENCODING = 1;\n    this.BROADCAST_EVENT = 'broadcast';\n    this.allowedMetadataKeys = [];\n    this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];\n  }\n  encode(msg, callback) {\n    if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === 'string') {\n      return callback(this._binaryEncodeUserBroadcastPush(msg));\n    }\n    let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n    return callback(JSON.stringify(payload));\n  }\n  _binaryEncodeUserBroadcastPush(message) {\n    var _a;\n    if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {\n      return this._encodeBinaryUserBroadcastPush(message);\n    } else {\n      return this._encodeJsonUserBroadcastPush(message);\n    }\n  }\n  _encodeBinaryUserBroadcastPush(message) {\n    var _a, _b;\n    const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);\n    return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);\n  }\n  _encodeJsonUserBroadcastPush(message) {\n    var _a, _b;\n    const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};\n    const encoder = new TextEncoder();\n    const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;\n    return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);\n  }\n  _encodeUserBroadcastPush(message, encodingType, encodedPayload) {\n    var _a, _b;\n    const topic = message.topic;\n    const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : '';\n    const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : '';\n    const userEvent = message.payload.event;\n    // Filter metadata based on allowed keys\n    const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};\n    const metadata = Object.keys(rest).length === 0 ? '' : JSON.stringify(rest);\n    // Validate lengths don't exceed uint8 max value (255)\n    if (joinRef.length > 255) {\n      throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);\n    }\n    if (ref.length > 255) {\n      throw new Error(`ref length ${ref.length} exceeds maximum of 255`);\n    }\n    if (topic.length > 255) {\n      throw new Error(`topic length ${topic.length} exceeds maximum of 255`);\n    }\n    if (userEvent.length > 255) {\n      throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);\n    }\n    if (metadata.length > 255) {\n      throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);\n    }\n    const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;\n    const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind\n    view.setUint8(offset++, joinRef.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, userEvent.length);\n    view.setUint8(offset++, metadata.length);\n    view.setUint8(offset++, encodingType);\n    Array.from(joinRef, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(userEvent, char => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(metadata, char => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(encodedPayload), header.byteLength);\n    return combined.buffer;\n  }\n  decode(rawPayload, callback) {\n    if (this._isArrayBuffer(rawPayload)) {\n      let result = this._binaryDecode(rawPayload);\n      return callback(result);\n    }\n    if (typeof rawPayload === 'string') {\n      const jsonPayload = JSON.parse(rawPayload);\n      const [join_ref, ref, topic, event, payload] = jsonPayload;\n      return callback({\n        join_ref,\n        ref,\n        topic,\n        event,\n        payload\n      });\n    }\n    return callback({});\n  }\n  _binaryDecode(buffer) {\n    const view = new DataView(buffer);\n    const kind = view.getUint8(0);\n    const decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.userBroadcast:\n        return this._decodeUserBroadcast(buffer, view, decoder);\n    }\n  }\n  _decodeUserBroadcast(buffer, view, decoder) {\n    const topicSize = view.getUint8(1);\n    const userEventSize = view.getUint8(2);\n    const metadataSize = view.getUint8(3);\n    const payloadEncoding = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + 4;\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));\n    offset = offset + userEventSize;\n    const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));\n    offset = offset + metadataSize;\n    const payload = buffer.slice(offset, buffer.byteLength);\n    const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;\n    const data = {\n      type: this.BROADCAST_EVENT,\n      event: userEvent,\n      payload: parsedPayload\n    };\n    // Metadata is optional and always JSON encoded\n    if (metadataSize > 0) {\n      data['meta'] = JSON.parse(metadata);\n    }\n    return {\n      join_ref: null,\n      ref: null,\n      topic: topic,\n      event: this.BROADCAST_EVENT,\n      payload: data\n    };\n  }\n  _isArrayBuffer(buffer) {\n    var _a;\n    return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ArrayBuffer';\n  }\n  _pick(obj, keys) {\n    if (!obj || typeof obj !== 'object') {\n      return {};\n    }\n    return Object.fromEntries(Object.entries(obj).filter(([key]) => keys.includes(key)));\n  }\n}\n//# sourceMappingURL=serializer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}