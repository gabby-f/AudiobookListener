{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParserFactory = exports.parseHttpContentType = void 0;\nconst FileType = require(\"file-type/core\");\nconst ContentType = require(\"content-type\");\nconst MimeType = require(\"media-typer\");\nconst debug_1 = require(\"debug\");\nconst MetadataCollector_1 = require(\"./common/MetadataCollector\");\nconst AiffParser_1 = require(\"./aiff/AiffParser\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst AsfParser_1 = require(\"./asf/AsfParser\");\nconst FlacParser_1 = require(\"./flac/FlacParser\");\nconst MP4Parser_1 = require(\"./mp4/MP4Parser\");\nconst MpegParser_1 = require(\"./mpeg/MpegParser\");\nconst musepack_1 = require(\"./musepack\");\nconst OggParser_1 = require(\"./ogg/OggParser\");\nconst WaveParser_1 = require(\"./wav/WaveParser\");\nconst WavPackParser_1 = require(\"./wavpack/WavPackParser\");\nconst DsfParser_1 = require(\"./dsf/DsfParser\");\nconst DsdiffParser_1 = require(\"./dsdiff/DsdiffParser\");\nconst MatroskaParser_1 = require(\"./matroska/MatroskaParser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:factory');\nfunction parseHttpContentType(contentType) {\n  const type = ContentType.parse(contentType);\n  const mime = MimeType.parse(type.type);\n  return {\n    type: mime.type,\n    subtype: mime.subtype,\n    suffix: mime.suffix,\n    parameters: type.parameters\n  };\n}\nexports.parseHttpContentType = parseHttpContentType;\nasync function parse(tokenizer, parserId, opts = {}) {\n  // Parser found, execute parser\n  const parser = await ParserFactory.loadParser(parserId);\n  const metadata = new MetadataCollector_1.MetadataCollector(opts);\n  await parser.init(metadata, tokenizer, opts).parse();\n  return metadata.toCommonMetadata();\n}\nclass ParserFactory {\n  /**\n   * Parse metadata from tokenizer\n   * @param tokenizer - Tokenizer\n   * @param opts - Options\n   * @returns Native metadata\n   */\n  static async parseOnContentType(tokenizer, opts) {\n    const {\n      mimeType,\n      path,\n      url\n    } = await tokenizer.fileInfo;\n    // Resolve parser based on MIME-type or file extension\n    const parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\n    if (!parserId) {\n      debug('No parser found for MIME-type / extension: ' + mimeType);\n    }\n    return this.parse(tokenizer, parserId, opts);\n  }\n  static async parse(tokenizer, parserId, opts) {\n    if (!parserId) {\n      // Parser could not be determined on MIME-type or extension\n      debug('Guess parser on content...');\n      const buf = Buffer.alloc(4100);\n      await tokenizer.peekBuffer(buf, {\n        mayBeLess: true\n      });\n      if (tokenizer.fileInfo.path) {\n        parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\n      }\n      if (!parserId) {\n        const guessedType = await FileType.fromBuffer(buf);\n        if (!guessedType) {\n          throw new Error('Failed to determine audio format');\n        }\n        debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\n        parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\n        if (!parserId) {\n          throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\n        }\n      }\n    }\n    // Parser found, execute parser\n    return parse(tokenizer, parserId, opts);\n  }\n  /**\n   * @param filePath - Path, filename or extension to audio file\n   * @return Parser sub-module name\n   */\n  static getParserIdForExtension(filePath) {\n    if (!filePath) return;\n    const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\n    switch (extension) {\n      case '.mp2':\n      case '.mp3':\n      case '.m2a':\n      case '.aac':\n        // Assume it is ADTS-container\n        return 'mpeg';\n      case '.ape':\n        return 'apev2';\n      case '.mp4':\n      case '.m4a':\n      case '.m4b':\n      case '.m4pa':\n      case '.m4v':\n      case '.m4r':\n      case '.3gp':\n        return 'mp4';\n      case '.wma':\n      case '.wmv':\n      case '.asf':\n        return 'asf';\n      case '.flac':\n        return 'flac';\n      case '.ogg':\n      case '.ogv':\n      case '.oga':\n      case '.ogm':\n      case '.ogx':\n      case '.opus': // recommended filename extension for Ogg Opus\n      case '.spx':\n        // recommended filename extension for Ogg Speex\n        return 'ogg';\n      case '.aif':\n      case '.aiff':\n      case '.aifc':\n        return 'aiff';\n      case '.wav':\n      case '.bwf':\n        // Broadcast Wave Format\n        return 'riff';\n      case '.wv':\n      case '.wvp':\n        return 'wavpack';\n      case '.mpc':\n        return 'musepack';\n      case '.dsf':\n        return 'dsf';\n      case '.dff':\n        return 'dsdiff';\n      case '.mka':\n      case '.mkv':\n      case '.mk3d':\n      case '.mks':\n      case '.webm':\n        return 'matroska';\n    }\n  }\n  static async loadParser(moduleName) {\n    switch (moduleName) {\n      case 'aiff':\n        return new AiffParser_1.AIFFParser();\n      case 'adts':\n      case 'mpeg':\n        return new MpegParser_1.MpegParser();\n      case 'apev2':\n        return new APEv2Parser_1.APEv2Parser();\n      case 'asf':\n        return new AsfParser_1.AsfParser();\n      case 'dsf':\n        return new DsfParser_1.DsfParser();\n      case 'dsdiff':\n        return new DsdiffParser_1.DsdiffParser();\n      case 'flac':\n        return new FlacParser_1.FlacParser();\n      case 'mp4':\n        return new MP4Parser_1.MP4Parser();\n      case 'musepack':\n        return new musepack_1.default();\n      case 'ogg':\n        return new OggParser_1.OggParser();\n      case 'riff':\n        return new WaveParser_1.WaveParser();\n      case 'wavpack':\n        return new WavPackParser_1.WavPackParser();\n      case 'matroska':\n        return new MatroskaParser_1.MatroskaParser();\n      default:\n        throw new Error(`Unknown parser type: ${moduleName}`);\n    }\n  }\n  static getExtension(fname) {\n    const i = fname.lastIndexOf('.');\n    return i === -1 ? '' : fname.slice(i);\n  }\n  /**\n   * @param httpContentType - HTTP Content-Type, extension, path or filename\n   * @returns Parser sub-module name\n   */\n  static getParserIdForMimeType(httpContentType) {\n    let mime;\n    try {\n      mime = parseHttpContentType(httpContentType);\n    } catch (err) {\n      debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\n      return;\n    }\n    const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n    switch (mime.type) {\n      case 'audio':\n        switch (subType) {\n          case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\n          case 'mpeg':\n            return 'mpeg';\n          case 'aac':\n          case 'aacp':\n            return 'adts';\n          case 'flac':\n            return 'flac';\n          case 'ape':\n          case 'monkeys-audio':\n            return 'apev2';\n          case 'mp4':\n          case 'm4a':\n            return 'mp4';\n          case 'ogg': // RFC 7845\n          case 'opus': // RFC 6716\n          case 'speex':\n            // RFC 5574\n            return 'ogg';\n          case 'ms-wma':\n          case 'ms-wmv':\n          case 'ms-asf':\n            return 'asf';\n          case 'aiff':\n          case 'aif':\n          case 'aifc':\n            return 'aiff';\n          case 'vnd.wave':\n          case 'wav':\n          case 'wave':\n            return 'riff';\n          case 'wavpack':\n            return 'wavpack';\n          case 'musepack':\n            return 'musepack';\n          case 'matroska':\n          case 'webm':\n            return 'matroska';\n          case 'dsf':\n            return 'dsf';\n        }\n        break;\n      case 'video':\n        switch (subType) {\n          case 'ms-asf':\n          case 'ms-wmv':\n            return 'asf';\n          case 'm4v':\n          case 'mp4':\n            return 'mp4';\n          case 'ogg':\n            return 'ogg';\n          case 'matroska':\n          case 'webm':\n            return 'matroska';\n        }\n        break;\n      case 'application':\n        switch (subType) {\n          case 'vnd.ms-asf':\n            return 'asf';\n          case 'ogg':\n            return 'ogg';\n        }\n        break;\n    }\n  }\n}\nexports.ParserFactory = ParserFactory;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}