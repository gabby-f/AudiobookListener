{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrameParser = exports.parseGenre = void 0;\nconst debug_1 = require(\"debug\");\nconst Token = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst ID3v2Token_1 = require(\"./ID3v2Token\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst debug = (0, debug_1.default)('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\nfunction parseGenre(origVal) {\n  // match everything inside parentheses\n  const genres = [];\n  let code;\n  let word = '';\n  for (const c of origVal) {\n    if (typeof code === 'string') {\n      if (c === '(' && code === '') {\n        word += '(';\n        code = undefined;\n      } else if (c === ')') {\n        if (word !== '') {\n          genres.push(word);\n          word = '';\n        }\n        const genre = parseGenreCode(code);\n        if (genre) {\n          genres.push(genre);\n        }\n        code = undefined;\n      } else code += c;\n    } else if (c === '(') {\n      code = '';\n    } else {\n      word += c;\n    }\n  }\n  if (word) {\n    if (genres.length === 0 && word.match(/^\\d*$/)) {\n      word = ID3v1Parser_1.Genres[word];\n    }\n    genres.push(word);\n  }\n  return genres;\n}\nexports.parseGenre = parseGenre;\nfunction parseGenreCode(code) {\n  if (code === 'RX') return 'Remix';\n  if (code === 'CR') return 'Cover';\n  if (code.match(/^\\d*$/)) {\n    return ID3v1Parser_1.Genres[code];\n  }\n}\nclass FrameParser {\n  /**\n   * Create id3v2 frame parser\n   * @param major - Major version, e.g. (4) for  id3v2.4\n   * @param warningCollector - Used to collect decode issue\n   */\n  constructor(major, warningCollector) {\n    this.major = major;\n    this.warningCollector = warningCollector;\n  }\n  readData(uint8Array, type, includeCovers) {\n    if (uint8Array.length === 0) {\n      this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n      return;\n    }\n    const {\n      encoding,\n      bom\n    } = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0);\n    const length = uint8Array.length;\n    let offset = 0;\n    let output = []; // ToDo\n    const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n    let fzero;\n    const out = {};\n    debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n    switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n      case 'T*': // 4.2.1. Text information frames - details\n      case 'IPLS': // v2.3: Involved people list\n      case 'MVIN':\n      case 'MVNM':\n      case 'PCS':\n      case 'PCST':\n        let text;\n        try {\n          text = util.decodeString(uint8Array.slice(1), encoding).replace(/\\x00+$/, '');\n        } catch (error) {\n          this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\n        }\n        switch (type) {\n          case 'TMCL': // Musician credits list\n          case 'TIPL': // Involved people list\n          case 'IPLS':\n            // Involved people list\n            output = this.splitValue(type, text);\n            output = FrameParser.functionList(output);\n            break;\n          case 'TRK':\n          case 'TRCK':\n          case 'TPOS':\n            output = text;\n            break;\n          case 'TCOM':\n          case 'TEXT':\n          case 'TOLY':\n          case 'TOPE':\n          case 'TPE1':\n          case 'TSRC':\n            // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n            output = this.splitValue(type, text);\n            break;\n          case 'TCO':\n          case 'TCON':\n            output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\n            break;\n          case 'PCS':\n          case 'PCST':\n            // TODO: Why `default` not results `1` but `''`?\n            output = this.major >= 4 ? this.splitValue(type, text) : [text];\n            output = Array.isArray(output) && output[0] === '' ? 1 : 0;\n            break;\n          default:\n            output = this.major >= 4 ? this.splitValue(type, text) : [text];\n        }\n        break;\n      case 'TXXX':\n        output = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);\n        output = {\n          description: output.id,\n          text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\\x00+$/, ''))\n        };\n        break;\n      case 'PIC':\n      case 'APIC':\n        if (includeCovers) {\n          const pic = {};\n          offset += 1;\n          switch (this.major) {\n            case 2:\n              pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\n              offset += 3;\n              break;\n            case 3:\n            case 4:\n              fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n              pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n              offset = fzero + 1;\n              break;\n            default:\n              throw new Error('Warning: unexpected major versionIndex: ' + this.major);\n          }\n          pic.format = FrameParser.fixPictureMimeType(pic.format);\n          pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]];\n          offset += 1;\n          fzero = util.findZero(uint8Array, offset, length, encoding);\n          pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n          offset = fzero + nullTerminatorLength;\n          pic.data = Buffer.from(uint8Array.slice(offset, length));\n          output = pic;\n        }\n        break;\n      case 'CNT':\n      case 'PCNT':\n        output = Token.UINT32_BE.get(uint8Array, 0);\n        break;\n      case 'SYLT':\n        // skip text encoding (1 byte),\n        //      language (3 bytes),\n        //      time stamp format (1 byte),\n        //      content tagTypes (1 byte),\n        //      content descriptor (1 byte)\n        offset += 7;\n        output = [];\n        while (offset < length) {\n          const txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));\n          offset += 5; // push offset forward one +  4 byte timestamp\n          output.push(util.decodeString(txt, encoding));\n        }\n        break;\n      case 'ULT':\n      case 'USLT':\n      case 'COM':\n      case 'COMM':\n        offset += 1;\n        out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc);\n        offset += 3;\n        fzero = util.findZero(uint8Array, offset, length, encoding);\n        out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n        offset = fzero + nullTerminatorLength;\n        out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\\x00+$/, '');\n        output = [out];\n        break;\n      case 'UFID':\n        output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n        output = {\n          owner_identifier: output.id,\n          identifier: output.data\n        };\n        break;\n      case 'PRIV':\n        // private frame\n        output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n        output = {\n          owner_identifier: output.id,\n          data: output.data\n        };\n        break;\n      case 'POPM':\n        // Popularimeter\n        fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n        const email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n        offset = fzero + 1;\n        const dataLen = length - offset;\n        output = {\n          email,\n          rating: Token.UINT8.get(uint8Array, offset),\n          counter: dataLen >= 5 ? Token.UINT32_BE.get(uint8Array, offset + 1) : undefined\n        };\n        break;\n      case 'GEOB':\n        {\n          // General encapsulated object\n          fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n          const mimeType = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);\n          offset = fzero + 1;\n          fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n          const filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n          offset = fzero + 1;\n          fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n          const description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n          output = {\n            type: mimeType,\n            filename,\n            description,\n            data: uint8Array.slice(offset + 1, length)\n          };\n          break;\n        }\n      // W-Frames:\n      case 'WCOM':\n      case 'WCOP':\n      case 'WOAF':\n      case 'WOAR':\n      case 'WOAS':\n      case 'WORS':\n      case 'WPAY':\n      case 'WPUB':\n        // Decode URL\n        output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n        break;\n      case 'WXXX':\n        {\n          // Decode URL\n          fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n          const description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);\n          offset = fzero + (encoding === 'utf16le' ? 2 : 1);\n          output = {\n            description,\n            url: util.decodeString(uint8Array.slice(offset, length), defaultEnc)\n          };\n          break;\n        }\n      case 'WFD':\n      case 'WFED':\n        output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);\n        break;\n      case 'MCDI':\n        {\n          // Music CD identifier\n          output = uint8Array.slice(0, length);\n          break;\n        }\n      default:\n        debug('Warning: unsupported id3v2-tag-type: ' + type);\n        break;\n    }\n    return output;\n  }\n  static fixPictureMimeType(pictureType) {\n    pictureType = pictureType.toLocaleLowerCase();\n    switch (pictureType) {\n      case 'jpg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n    }\n    return pictureType;\n  }\n  /**\n   * Converts TMCL (Musician credits list) or TIPL (Involved people list)\n   * @param entries\n   */\n  static functionList(entries) {\n    const res = {};\n    for (let i = 0; i + 1 < entries.length; i += 2) {\n      const names = entries[i + 1].split(',');\n      res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;\n    }\n    return res;\n  }\n  /**\n   * id3v2.4 defines that multiple T* values are separated by 0x00\n   * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n   * @param tag - Tag name\n   * @param text - Concatenated tag value\n   * @returns Split tag value\n   */\n  splitValue(tag, text) {\n    let values;\n    if (this.major < 4) {\n      values = text.split(/\\x00/g);\n      if (values.length > 1) {\n        this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n      } else {\n        values = text.split(/\\//g);\n      }\n    } else {\n      values = text.split(/\\x00/g);\n    }\n    return FrameParser.trimArray(values);\n  }\n  static trimArray(values) {\n    return values.map(value => value.replace(/\\x00+$/, '').trim());\n  }\n  static readIdentifierAndData(uint8Array, offset, length, encoding) {\n    const fzero = util.findZero(uint8Array, offset, length, encoding);\n    const id = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n    offset = fzero + FrameParser.getNullTerminatorLength(encoding);\n    return {\n      id,\n      data: uint8Array.slice(offset, length)\n    };\n  }\n  static getNullTerminatorLength(enc) {\n    return enc === 'utf16le' ? 2 : 1;\n  }\n}\nexports.FrameParser = FrameParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}