{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MP4Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst Token = require(\"token-types\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst type_1 = require(\"../type\");\nconst Atom_1 = require(\"./Atom\");\nconst AtomToken = require(\"./AtomToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n  raw: {\n    lossy: false,\n    format: 'raw'\n  },\n  MAC3: {\n    lossy: true,\n    format: 'MACE 3:1'\n  },\n  MAC6: {\n    lossy: true,\n    format: 'MACE 6:1'\n  },\n  ima4: {\n    lossy: true,\n    format: 'IMA 4:1'\n  },\n  ulaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  alaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  Qclp: {\n    lossy: true,\n    format: 'QUALCOMM PureVoice'\n  },\n  '.mp3': {\n    lossy: true,\n    format: 'MPEG-1 layer 3'\n  },\n  alac: {\n    lossy: false,\n    format: 'ALAC'\n  },\n  'ac-3': {\n    lossy: true,\n    format: 'AC-3'\n  },\n  mp4a: {\n    lossy: true,\n    format: 'MPEG-4/AAC'\n  },\n  mp4s: {\n    lossy: true,\n    format: 'MP4S'\n  },\n  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n  c608: {\n    lossy: true,\n    format: 'CEA-608'\n  },\n  c708: {\n    lossy: true,\n    format: 'CEA-708'\n  }\n};\nfunction distinct(value, index, self) {\n  return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nclass MP4Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.atomParsers = {\n      /**\n       * Parse movie header (mvhd) atom\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n       */\n      mvhd: async len => {\n        const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n        this.metadata.setFormat('creationTime', mvhd.creationTime);\n        this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n      },\n      /**\n       * Parse media header (mdhd) atom\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n       */\n      mdhd: async len => {\n        const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\n        // this.parse_mxhd(mdhd_data, this.currentTrack);\n        const td = this.getTrackDescription();\n        td.creationTime = mdhd_data.creationTime;\n        td.modificationTime = mdhd_data.modificationTime;\n        td.timeScale = mdhd_data.timeScale;\n        td.duration = mdhd_data.duration;\n      },\n      chap: async len => {\n        const td = this.getTrackDescription();\n        const trackIds = [];\n        while (len >= Token.UINT32_BE.len) {\n          trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n          len -= Token.UINT32_BE.len;\n        }\n        td.chapterList = trackIds;\n      },\n      tkhd: async len => {\n        const track = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));\n        this.tracks.push(track);\n      },\n      /**\n       * Parse mdat atom.\n       * Will scan for chapters\n       */\n      mdat: async len => {\n        this.audioLengthInBytes = len;\n        this.calculateBitRate();\n        if (this.options.includeChapters) {\n          const trackWithChapters = this.tracks.filter(track => track.chapterList);\n          if (trackWithChapters.length === 1) {\n            const chapterTrackIds = trackWithChapters[0].chapterList;\n            const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n            if (chapterTracks.length === 1) {\n              return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n            }\n          }\n        }\n        await this.tokenizer.ignore(len);\n      },\n      ftyp: async len => {\n        const types = [];\n        while (len > 0) {\n          const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n          len -= AtomToken.ftyp.len;\n          const value = ftype.type.replace(/\\W/g, '');\n          if (value.length > 0) {\n            types.push(value); // unshift for backward compatibility\n          }\n        }\n        debug(\"ftyp: \".concat(types.join('/')));\n        const x = types.filter(distinct).join('/');\n        this.metadata.setFormat('container', x);\n      },\n      /**\n       * Parse sample description atom\n       */\n      stsd: async len => {\n        const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n        const trackDescription = this.getTrackDescription();\n        trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n      },\n      /**\n       * sample-to-Chunk Atoms\n       */\n      stsc: async len => {\n        const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n        this.getTrackDescription().sampleToChunkTable = stsc.entries;\n      },\n      /**\n       * time-to-sample table\n       */\n      stts: async len => {\n        const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n        this.getTrackDescription().timeToSampleTable = stts.entries;\n      },\n      /**\n       * Parse sample-sizes atom ('stsz')\n       */\n      stsz: async len => {\n        const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n        const td = this.getTrackDescription();\n        td.sampleSize = stsz.sampleSize;\n        td.sampleSizeTable = stsz.entries;\n      },\n      /**\n       * Parse chunk-offset atom ('stco')\n       */\n      stco: async len => {\n        const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n        this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n      },\n      date: async len => {\n        const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n        this.addTag('date', date);\n      }\n    };\n  }\n  static read_BE_Integer(array, signed) {\n    const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n    const token = Token[integerType];\n    if (!token) {\n      throw new Error('Token for integer type not found: \"' + integerType + '\"');\n    }\n    return Number(token.get(array, 0));\n  }\n  async parse() {\n    this.tracks = [];\n    let remainingFileSize = this.tokenizer.fileInfo.size;\n    while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n      try {\n        const token = await this.tokenizer.peekToken(AtomToken.Header);\n        if (token.name === '\\0\\0\\0\\0') {\n          const errMsg = \"Error at offset=\".concat(this.tokenizer.position, \": box.id=0\");\n          debug(errMsg);\n          this.addWarning(errMsg);\n          break;\n        }\n      } catch (error) {\n        const errMsg = \"Error at offset=\".concat(this.tokenizer.position, \": \").concat(error.message);\n        debug(errMsg);\n        this.addWarning(errMsg);\n        break;\n      }\n      const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n      remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n    }\n    // Post process metadata\n    const formatList = [];\n    this.tracks.forEach(track => {\n      const trackFormats = [];\n      track.soundSampleDescription.forEach(ssd => {\n        const streamInfo = {};\n        const encoderInfo = encoderDict[ssd.dataFormat];\n        if (encoderInfo) {\n          trackFormats.push(encoderInfo.format);\n          streamInfo.codecName = encoderInfo.format;\n        } else {\n          streamInfo.codecName = \"<\".concat(ssd.dataFormat, \">\");\n        }\n        if (ssd.description) {\n          const {\n            description\n          } = ssd;\n          if (description.sampleRate > 0) {\n            streamInfo.type = type_1.TrackType.audio;\n            streamInfo.audio = {\n              samplingFrequency: description.sampleRate,\n              bitDepth: description.sampleSize,\n              channels: description.numAudioChannels\n            };\n          }\n        }\n        this.metadata.addStreamInfo(streamInfo);\n      });\n      if (trackFormats.length >= 1) {\n        formatList.push(trackFormats.join('/'));\n      }\n    });\n    if (formatList.length > 0) {\n      this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n    }\n    const audioTracks = this.tracks.filter(track => {\n      return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n    });\n    if (audioTracks.length >= 1) {\n      const audioTrack = audioTracks[0];\n      if (audioTrack.timeScale > 0) {\n        const duration = audioTrack.duration / audioTrack.timeScale; // calculate duration in seconds\n        this.metadata.setFormat('duration', duration);\n      }\n      const ssd = audioTrack.soundSampleDescription[0];\n      if (ssd.description) {\n        this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n        this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n        this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n        if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n          const totalSampleSize = audioTrack.timeToSampleTable.map(ttstEntry => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize);\n          const duration = totalSampleSize / ssd.description.sampleRate;\n          this.metadata.setFormat('duration', duration);\n        }\n      }\n      const encoderInfo = encoderDict[ssd.dataFormat];\n      if (encoderInfo) {\n        this.metadata.setFormat('lossless', !encoderInfo.lossy);\n      }\n      this.calculateBitRate();\n    }\n  }\n  async handleAtom(atom, remaining) {\n    if (atom.parent) {\n      switch (atom.parent.header.name) {\n        case 'ilst':\n        case '<id>':\n          return this.parseMetadataItemData(atom);\n      }\n    }\n    // const payloadLength = atom.getPayloadLength(remaining);\n    if (this.atomParsers[atom.header.name]) {\n      return this.atomParsers[atom.header.name](remaining);\n    } else {\n      debug(\"No parser for atom path=\".concat(atom.atomPath, \", payload-len=\").concat(remaining, \", ignoring atom\"));\n      await this.tokenizer.ignore(remaining);\n    }\n  }\n  getTrackDescription() {\n    return this.tracks[this.tracks.length - 1];\n  }\n  calculateBitRate() {\n    if (this.audioLengthInBytes && this.metadata.format.duration) {\n      this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n    }\n  }\n  addTag(id, value) {\n    this.metadata.addTag(tagFormat, id, value);\n  }\n  addWarning(message) {\n    debug('Warning: ' + message);\n    this.metadata.addWarning(message);\n  }\n  /**\n   * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n   * @param metaAtom\n   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n   */\n  parseMetadataItemData(metaAtom) {\n    let tagKey = metaAtom.header.name;\n    return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n      const payLoadLength = child.getPayloadLength(remaining);\n      switch (child.header.name) {\n        case 'data':\n          // value atom\n          return this.parseValueAtom(tagKey, child);\n        case 'name': // name atom (optional)\n        case 'mean':\n        case 'rate':\n          const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n          tagKey += ':' + name.name;\n          break;\n        default:\n          const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\n          this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n      }\n    }, metaAtom.getPayloadLength(0));\n  }\n  async parseValueAtom(tagKey, metaAtom) {\n    const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n    if (dataAtom.type.set !== 0) {\n      throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n    }\n    // Use well-known-type table\n    // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n    switch (dataAtom.type.type) {\n      case 0:\n        // reserved: Reserved for use where no type needs to be indicated\n        switch (tagKey) {\n          case 'trkn':\n          case 'disk':\n            const num = Token.UINT8.get(dataAtom.value, 3);\n            const of = Token.UINT8.get(dataAtom.value, 5);\n            // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n            this.addTag(tagKey, num + '/' + of);\n            break;\n          case 'gnre':\n            const genreInt = Token.UINT8.get(dataAtom.value, 1);\n            const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\n            // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n            this.addTag(tagKey, genreStr);\n            break;\n          case 'rate':\n            const rate = dataAtom.value.toString('ascii');\n            this.addTag(tagKey, rate);\n            break;\n          default:\n            debug('unknown proprietary value type for: ' + metaAtom.atomPath);\n        }\n        break;\n      case 1: // UTF-8: Without any count or NULL terminator\n      case 18:\n        // Unknown: Found in m4b in combination with a '©gen' tag\n        this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n        break;\n      case 13:\n        // JPEG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/jpeg',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n      case 14:\n        // PNG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/png',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n      case 21:\n        // BE Signed Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n        break;\n      case 22:\n        // BE Unsigned Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n        break;\n      case 65:\n        // An 8-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt8(0));\n        break;\n      case 66:\n        // A big-endian 16-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n        break;\n      case 67:\n        // A big-endian 32-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n        break;\n      default:\n        this.addWarning(\"atom key=\".concat(tagKey, \", has unknown well-known-type (data-type): \").concat(dataAtom.type.type));\n    }\n  }\n  /**\n   * @param sampleDescription\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n   */\n  parseSoundSampleDescription(sampleDescription) {\n    const ssd = {\n      dataFormat: sampleDescription.dataFormat,\n      dataReferenceIndex: sampleDescription.dataReferenceIndex\n    };\n    let offset = 0;\n    const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n    offset += AtomToken.SoundSampleDescriptionVersion.len;\n    if (version.version === 0 || version.version === 1) {\n      // Sound Sample Description (Version 0)\n      ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n    } else {\n      debug(\"Warning: sound-sample-description \".concat(version, \" not implemented\"));\n    }\n    return ssd;\n  }\n  async parseChapterTrack(chapterTrack, track, len) {\n    if (!chapterTrack.sampleSize) {\n      if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length) throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n    }\n    const chapters = [];\n    for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n      const chunkOffset = chapterTrack.chunkOffsetTable[i];\n      const nextChunkLen = chunkOffset - this.tokenizer.position;\n      const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n      len -= nextChunkLen + sampleSize;\n      if (len < 0) throw new Error('Chapter chunk exceeding token length');\n      await this.tokenizer.ignore(nextChunkLen);\n      const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n      debug(\"Chapter \".concat(i + 1, \": \").concat(title));\n      const chapter = {\n        title,\n        sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n      };\n      debug(\"Chapter title=\".concat(chapter.title, \", offset=\").concat(chapter.sampleOffset, \"/\").concat(this.tracks[0].duration));\n      chapters.push(chapter);\n    }\n    this.metadata.setFormat('chapters', chapters);\n    await this.tokenizer.ignore(len);\n  }\n  findSampleOffset(track, chapterOffset) {\n    let totalDuration = 0;\n    track.timeToSampleTable.forEach(e => {\n      totalDuration += e.count * e.duration;\n    });\n    debug(\"Total duration=\".concat(totalDuration));\n    let chunkIndex = 0;\n    while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n      ++chunkIndex;\n    }\n    return this.getChunkDuration(chunkIndex + 1, track);\n  }\n  getChunkDuration(chunkId, track) {\n    let ttsi = 0;\n    let ttsc = track.timeToSampleTable[ttsi].count;\n    let ttsd = track.timeToSampleTable[ttsi].duration;\n    let curChunkId = 1;\n    let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n    let totalDuration = 0;\n    while (curChunkId < chunkId) {\n      const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n      totalDuration += nrOfSamples * ttsd;\n      ttsc -= nrOfSamples;\n      samplesPerChunk -= nrOfSamples;\n      if (samplesPerChunk === 0) {\n        ++curChunkId;\n        samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n      } else {\n        ++ttsi;\n        ttsc = track.timeToSampleTable[ttsi].count;\n        ttsd = track.timeToSampleTable[ttsi].duration;\n      }\n    }\n    return totalDuration;\n  }\n  getSamplesPerChunk(chunkId, stcTable) {\n    for (let i = 0; i < stcTable.length - 1; ++i) {\n      if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n        return stcTable[i].samplesPerChunk;\n      }\n    }\n    return stcTable[stcTable.length - 1].samplesPerChunk;\n  }\n}\nexports.MP4Parser = MP4Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MP4Parser","debug_1","require","Token","BasicParser_1","ID3v1Parser_1","type_1","Atom_1","AtomToken","debug","default","tagFormat","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","BasicParser","constructor","arguments","atomParsers","mvhd","len","tokenizer","readToken","MvhdAtom","metadata","setFormat","creationTime","modificationTime","mdhd","mdhd_data","MdhdAtom","td","getTrackDescription","timeScale","duration","chap","trackIds","UINT32_BE","push","readNumber","chapterList","tkhd","track","TrackHeaderAtom","tracks","mdat","audioLengthInBytes","calculateBitRate","options","includeChapters","trackWithChapters","filter","length","chapterTrackIds","chapterTracks","trackId","parseChapterTrack","ignore","ftyp","types","ftype","type","replace","concat","join","x","stsd","StsdAtom","trackDescription","soundSampleDescription","table","map","dfEntry","parseSoundSampleDescription","stsc","StscAtom","sampleToChunkTable","entries","stts","SttsAtom","timeToSampleTable","stsz","StszAtom","sampleSize","sampleSizeTable","stco","StcoAtom","chunkOffsetTable","date","StringType","addTag","read_BE_Integer","array","signed","integerType","token","Error","Number","get","parse","remainingFileSize","fileInfo","size","peekToken","Header","name","errMsg","position","addWarning","error","message","rootAtom","Atom","readAtom","atom","remaining","handleAtom","header","BigInt","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","dataFormat","codecName","description","sampleRate","TrackType","audio","samplingFrequency","bitDepth","channels","numAudioChannels","addStreamInfo","audioTracks","audioTrack","totalSampleSize","ttstEntry","count","reduce","total","parent","parseMetadataItemData","atomPath","id","metaAtom","tagKey","readAtoms","child","payLoadLength","getPayloadLength","parseValueAtom","NameAtom","dataAtom","BufferType","toString","DataAtom","set","num","UINT8","of","genreInt","genreStr","Genres","rate","skipCovers","data","Buffer","from","readInt8","readInt16BE","readInt32BE","sampleDescription","dataReferenceIndex","offset","version","SoundSampleDescriptionVersion","SoundSampleDescriptionV0","chapterTrack","chapters","i","chunkOffset","nextChunkLen","title","ChapterText","chapter","sampleOffset","findSampleOffset","chapterOffset","totalDuration","e","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","samplesPerChunk","getSamplesPerChunk","nrOfSamples","Math","min","stcTable","firstChunk"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/node_modules/music-metadata/lib/mp4/MP4Parser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MP4Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst Token = require(\"token-types\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst type_1 = require(\"../type\");\nconst Atom_1 = require(\"./Atom\");\nconst AtomToken = require(\"./AtomToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nclass MP4Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.atomParsers = {\n            /**\n             * Parse movie header (mvhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n             */\n            mvhd: async (len) => {\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n            },\n            /**\n             * Parse media header (mdhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n             */\n            mdhd: async (len) => {\n                const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\n                // this.parse_mxhd(mdhd_data, this.currentTrack);\n                const td = this.getTrackDescription();\n                td.creationTime = mdhd_data.creationTime;\n                td.modificationTime = mdhd_data.modificationTime;\n                td.timeScale = mdhd_data.timeScale;\n                td.duration = mdhd_data.duration;\n            },\n            chap: async (len) => {\n                const td = this.getTrackDescription();\n                const trackIds = [];\n                while (len >= Token.UINT32_BE.len) {\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n                    len -= Token.UINT32_BE.len;\n                }\n                td.chapterList = trackIds;\n            },\n            tkhd: async (len) => {\n                const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\n                this.tracks.push(track);\n            },\n            /**\n             * Parse mdat atom.\n             * Will scan for chapters\n             */\n            mdat: async (len) => {\n                this.audioLengthInBytes = len;\n                this.calculateBitRate();\n                if (this.options.includeChapters) {\n                    const trackWithChapters = this.tracks.filter(track => track.chapterList);\n                    if (trackWithChapters.length === 1) {\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\n                        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n                        if (chapterTracks.length === 1) {\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                        }\n                    }\n                }\n                await this.tokenizer.ignore(len);\n            },\n            ftyp: async (len) => {\n                const types = [];\n                while (len > 0) {\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n                    len -= AtomToken.ftyp.len;\n                    const value = ftype.type.replace(/\\W/g, '');\n                    if (value.length > 0) {\n                        types.push(value); // unshift for backward compatibility\n                    }\n                }\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n            },\n            /**\n             * Parse sample description atom\n             */\n            stsd: async (len) => {\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n                const trackDescription = this.getTrackDescription();\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            },\n            /**\n             * sample-to-Chunk Atoms\n             */\n            stsc: async (len) => {\n                const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n                this.getTrackDescription().sampleToChunkTable = stsc.entries;\n            },\n            /**\n             * time-to-sample table\n             */\n            stts: async (len) => {\n                const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n                this.getTrackDescription().timeToSampleTable = stts.entries;\n            },\n            /**\n             * Parse sample-sizes atom ('stsz')\n             */\n            stsz: async (len) => {\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n                const td = this.getTrackDescription();\n                td.sampleSize = stsz.sampleSize;\n                td.sampleSizeTable = stsz.entries;\n            },\n            /**\n             * Parse chunk-offset atom ('stco')\n             */\n            stco: async (len) => {\n                const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n                this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n            },\n            date: async (len) => {\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n                this.addTag('date', date);\n            }\n        };\n    }\n    static read_BE_Integer(array, signed) {\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n        const token = Token[integerType];\n        if (!token) {\n            throw new Error('Token for integer type not found: \"' + integerType + '\"');\n        }\n        return Number(token.get(array, 0));\n    }\n    async parse() {\n        this.tracks = [];\n        let remainingFileSize = this.tokenizer.fileInfo.size;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                debug(errMsg);\n                this.addWarning(errMsg);\n                break;\n            }\n            const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = type_1.TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = this.tracks.filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n        });\n        if (audioTracks.length >= 1) {\n            const audioTrack = audioTracks[0];\n            if (audioTrack.timeScale > 0) {\n                const duration = audioTrack.duration / audioTrack.timeScale; // calculate duration in seconds\n                this.metadata.setFormat('duration', duration);\n            }\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n                    const totalSampleSize = audioTrack.timeToSampleTable\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\n                        .reduce((total, sampleSize) => total + sampleSize);\n                    const duration = totalSampleSize / ssd.description.sampleRate;\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n            this.calculateBitRate();\n        }\n    }\n    async handleAtom(atom, remaining) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n            }\n        }\n        // const payloadLength = atom.getPayloadLength(remaining);\n        if (this.atomParsers[atom.header.name]) {\n            return this.atomParsers[atom.header.name](remaining);\n        }\n        else {\n            debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n            await this.tokenizer.ignore(remaining);\n        }\n    }\n    getTrackDescription() {\n        return this.tracks[this.tracks.length - 1];\n    }\n    calculateBitRate() {\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug('Warning: ' + message);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                case 'mean':\n                case 'rate':\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n                    tagKey += ':' + name.name;\n                    break;\n                default:\n                    const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\n                    this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n            }\n        }, metaAtom.getPayloadLength(0));\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk':\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        this.addTag(tagKey, num + '/' + of);\n                        break;\n                    case 'gnre':\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        this.addTag(tagKey, genreStr);\n                        break;\n                    case 'rate':\n                        const rate = dataAtom.value.toString('ascii');\n                        this.addTag(tagKey, rate);\n                        break;\n                    default:\n                        debug('unknown proprietary value type for: ' + metaAtom.atomPath);\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n                break;\n            case 22: // BE Unsigned Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n                break;\n            case 65: // An 8-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n        offset += AtomToken.SoundSampleDescriptionVersion.len;\n        if (version.version === 0 || version.version === 1) {\n            // Sound Sample Description (Version 0)\n            ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n        }\n        else {\n            debug(`Warning: sound-sample-description ${version} not implemented`);\n        }\n        return ssd;\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            if (len < 0)\n                throw new Error('Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let totalDuration = 0;\n        track.timeToSampleTable.forEach(e => {\n            totalDuration += e.count * e.duration;\n        });\n        debug(`Total duration=${totalDuration}`);\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\nexports.MP4Parser = MP4Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}