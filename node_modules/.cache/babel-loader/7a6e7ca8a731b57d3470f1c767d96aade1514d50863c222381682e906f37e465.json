{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsdiffParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n    if (header.chunkID !== 'FRM8') throw new Error('Unexpected chunk-ID');\n    const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n    switch (type) {\n      case 'DSD':\n        this.metadata.setFormat('container', `DSDIFF/${type}`);\n        this.metadata.setFormat('lossless', true);\n        return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n      default:\n        throw Error(`Unsupported DSDIFF type: ${type}`);\n    }\n  }\n  async readFmt8Chunks(remainingSize) {\n    while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n      //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n      debug(`Chunk id=${chunkHeader.chunkID}`);\n      await this.readData(chunkHeader);\n      remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize;\n    }\n  }\n  async readData(header) {\n    debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n    const p0 = this.tokenizer.position;\n    switch (header.chunkID.trim()) {\n      case 'FVER':\n        // 3.1 FORMAT VERSION CHUNK\n        const version = await this.tokenizer.readToken(Token.UINT32_LE);\n        debug(`DSDIFF version=${version}`);\n        break;\n      case 'PROP':\n        // 3.2 PROPERTY CHUNK\n        const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (propType !== 'SND ') throw new Error('Unexpected PROP-chunk ID');\n        await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n        break;\n      case 'ID3':\n        // Unofficial ID3 tag support\n        const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        break;\n      default:\n        debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        break;\n      case 'DSD':\n        this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        break;\n    }\n    const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n    if (remaining > 0) {\n      debug(`After Parsing chunk, remaining ${remaining} bytes`);\n      await this.tokenizer.ignore(Number(remaining));\n    }\n  }\n  async handleSoundPropertyChunks(remainingSize) {\n    debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    while (remainingSize > 0) {\n      const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n      debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n      const p0 = this.tokenizer.position;\n      switch (sndPropHeader.chunkID.trim()) {\n        case 'FS':\n          // 3.2.1 Sample Rate Chunk\n          const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n          this.metadata.setFormat('sampleRate', sampleRate);\n          break;\n        case 'CHNL':\n          // 3.2.2 Channels Chunk\n          const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n          this.metadata.setFormat('numberOfChannels', numChannels);\n          await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n          break;\n        case 'CMPR':\n          // 3.2.3 Compression Type Chunk\n          const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n          const count = await this.tokenizer.readToken(Token.UINT8);\n          const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n          if (compressionIdCode === 'DSD') {\n            this.metadata.setFormat('lossless', true);\n            this.metadata.setFormat('bitsPerSample', 1);\n          }\n          this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n          break;\n        case 'ABSS':\n          // 3.2.4 Absolute Start Time Chunk\n          const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n          const minutes = await this.tokenizer.readToken(Token.UINT8);\n          const seconds = await this.tokenizer.readToken(Token.UINT8);\n          const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n          debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n          break;\n        case 'LSCO':\n          // 3.2.5 Loudspeaker Configuration Chunk\n          const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n          debug(`LSCO lsConfig=${lsConfig}`);\n          break;\n        case 'COMT':\n        default:\n          debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n          await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n      }\n      const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n      if (remaining > 0) {\n        debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n        await this.tokenizer.ignore(Number(remaining));\n      }\n      remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;\n      debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    }\n    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n      const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n      this.metadata.setFormat('bitrate', bitrate);\n    }\n  }\n  async handleChannelChunks(remainingSize) {\n    debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n    const channels = [];\n    while (remainingSize >= FourCC_1.FourCcToken.len) {\n      const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n      debug(`Channel[ID=${channelId}]`);\n      channels.push(channelId);\n      remainingSize -= BigInt(FourCC_1.FourCcToken.len);\n    }\n    debug(`Channels: ${channels.join(', ')}`);\n    return channels;\n  }\n}\nexports.DsdiffParser = DsdiffParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}