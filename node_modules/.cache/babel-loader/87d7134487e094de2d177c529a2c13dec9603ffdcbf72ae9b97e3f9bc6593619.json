{"ast":null,"code":"\"use strict\";\n\n// ASF Objects\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WmPictureToken = exports.MetadataLibraryObjectState = exports.MetadataObjectState = exports.ExtendedStreamPropertiesObjectState = exports.ExtendedContentDescriptionObjectState = exports.ContentDescriptionObjectState = exports.readCodecEntries = exports.HeaderExtensionObject = exports.StreamPropertiesObject = exports.FilePropertiesObject = exports.IgnoreObjectState = exports.State = exports.HeaderObjectToken = exports.TopLevelHeaderObjectToken = exports.DataType = void 0;\nconst util = require(\"../common/Util\");\nconst Token = require(\"token-types\");\nconst GUID_1 = require(\"./GUID\");\nconst AsfUtil_1 = require(\"./AsfUtil\");\nconst ID3v2Token_1 = require(\"../id3v2/ID3v2Token\");\n/**\n * Data Type: Specifies the type of information being stored. The following values are recognized.\n */\nvar DataType;\n(function (DataType) {\n  /**\n   * Unicode string. The data consists of a sequence of Unicode characters.\n   */\n  DataType[DataType[\"UnicodeString\"] = 0] = \"UnicodeString\";\n  /**\n   * BYTE array. The type of data is implementation-specific.\n   */\n  DataType[DataType[\"ByteArray\"] = 1] = \"ByteArray\";\n  /**\n   * BOOL. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer. Only 0x0000 or 0x0001 are permitted values.\n   */\n  DataType[DataType[\"Bool\"] = 2] = \"Bool\";\n  /**\n   * DWORD. The data is 4 bytes long and should be interpreted as a 32-bit unsigned integer.\n   */\n  DataType[DataType[\"DWord\"] = 3] = \"DWord\";\n  /**\n   * QWORD. The data is 8 bytes long and should be interpreted as a 64-bit unsigned integer.\n   */\n  DataType[DataType[\"QWord\"] = 4] = \"QWord\";\n  /**\n   * WORD. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer.\n   */\n  DataType[DataType[\"Word\"] = 5] = \"Word\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * Token for: 3. ASF top-level Header Object\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3\n */\nexports.TopLevelHeaderObjectToken = {\n  len: 30,\n  get: (buf, off) => {\n    return {\n      objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),\n      objectSize: Number(Token.UINT64_LE.get(buf, off + 16)),\n      numberOfHeaderObjects: Token.UINT32_LE.get(buf, off + 24)\n      // Reserved: 2 bytes\n    };\n  }\n};\n/**\n * Token for: 3.1 Header Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_1\n */\nexports.HeaderObjectToken = {\n  len: 24,\n  get: (buf, off) => {\n    return {\n      objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),\n      objectSize: Number(Token.UINT64_LE.get(buf, off + 16))\n    };\n  }\n};\nclass State {\n  constructor(header) {\n    this.len = Number(header.objectSize) - exports.HeaderObjectToken.len;\n  }\n  postProcessTag(tags, name, valueType, data) {\n    if (name === 'WM/Picture') {\n      tags.push({\n        id: name,\n        value: WmPictureToken.fromBuffer(data)\n      });\n    } else {\n      const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);\n      if (!parseAttr) {\n        throw new Error('unexpected value headerType: ' + valueType);\n      }\n      tags.push({\n        id: name,\n        value: parseAttr(data)\n      });\n    }\n  }\n}\nexports.State = State;\n// ToDo: use ignore type\nclass IgnoreObjectState extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(buf, off) {\n    return null;\n  }\n}\nexports.IgnoreObjectState = IgnoreObjectState;\n/**\n * Token for: 3.2: File Properties Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_2\n */\nclass FilePropertiesObject extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(buf, off) {\n    return {\n      fileId: GUID_1.default.fromBin(buf, off),\n      fileSize: Token.UINT64_LE.get(buf, off + 16),\n      creationDate: Token.UINT64_LE.get(buf, off + 24),\n      dataPacketsCount: Token.UINT64_LE.get(buf, off + 32),\n      playDuration: Token.UINT64_LE.get(buf, off + 40),\n      sendDuration: Token.UINT64_LE.get(buf, off + 48),\n      preroll: Token.UINT64_LE.get(buf, off + 56),\n      flags: {\n        broadcast: util.getBit(buf, off + 64, 24),\n        seekable: util.getBit(buf, off + 64, 25)\n      },\n      // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),\n      minimumDataPacketSize: Token.UINT32_LE.get(buf, off + 68),\n      maximumDataPacketSize: Token.UINT32_LE.get(buf, off + 72),\n      maximumBitrate: Token.UINT32_LE.get(buf, off + 76)\n    };\n  }\n}\nFilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;\nexports.FilePropertiesObject = FilePropertiesObject;\n/**\n * Token for: 3.3 Stream Properties Object (mandatory, one per stream)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_3\n */\nclass StreamPropertiesObject extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(buf, off) {\n    return {\n      streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),\n      errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)\n      // ToDo\n    };\n  }\n}\nStreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;\nexports.StreamPropertiesObject = StreamPropertiesObject;\n/**\n * 3.4: Header Extension Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_4\n */\nclass HeaderExtensionObject {\n  constructor() {\n    this.len = 22;\n  }\n  get(buf, off) {\n    return {\n      reserved1: GUID_1.default.fromBin(buf, off),\n      reserved2: buf.readUInt16LE(off + 16),\n      extensionDataSize: buf.readUInt32LE(off + 18)\n    };\n  }\n}\nHeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;\nexports.HeaderExtensionObject = HeaderExtensionObject;\n/**\n * 3.5: The Codec List Object provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5\n */\nconst CodecListObjectHeader = {\n  len: 20,\n  get: (buf, off) => {\n    return {\n      entryCount: buf.readUInt16LE(off + 16)\n    };\n  }\n};\nasync function readString(tokenizer) {\n  const length = await tokenizer.readNumber(Token.UINT16_LE);\n  return (await tokenizer.readToken(new Token.StringType(length * 2, 'utf16le'))).replace('\\0', '');\n}\n/**\n * 3.5: Read the Codec-List-Object, which provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5\n */\nasync function readCodecEntries(tokenizer) {\n  const codecHeader = await tokenizer.readToken(CodecListObjectHeader);\n  const entries = [];\n  for (let i = 0; i < codecHeader.entryCount; ++i) {\n    entries.push(await readCodecEntry(tokenizer));\n  }\n  return entries;\n}\nexports.readCodecEntries = readCodecEntries;\nasync function readInformation(tokenizer) {\n  const length = await tokenizer.readNumber(Token.UINT16_LE);\n  const buf = Buffer.alloc(length);\n  await tokenizer.readBuffer(buf);\n  return buf;\n}\n/**\n * Read Codec-Entries\n * @param tokenizer\n */\nasync function readCodecEntry(tokenizer) {\n  const type = await tokenizer.readNumber(Token.UINT16_LE);\n  return {\n    type: {\n      videoCodec: (type & 0x0001) === 0x0001,\n      audioCodec: (type & 0x0002) === 0x0002\n    },\n    codecName: await readString(tokenizer),\n    description: await readString(tokenizer),\n    information: await readInformation(tokenizer)\n  };\n}\n/**\n * 3.10 Content Description Object (optional, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_10\n */\nclass ContentDescriptionObjectState extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(buf, off) {\n    const tags = [];\n    let pos = off + 10;\n    for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {\n      const length = buf.readUInt16LE(off + i * 2);\n      if (length > 0) {\n        const tagName = ContentDescriptionObjectState.contentDescTags[i];\n        const end = pos + length;\n        tags.push({\n          id: tagName,\n          value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end))\n        });\n        pos = end;\n      }\n    }\n    return tags;\n  }\n}\nContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;\nContentDescriptionObjectState.contentDescTags = ['Title', 'Author', 'Copyright', 'Description', 'Rating'];\nexports.ContentDescriptionObjectState = ContentDescriptionObjectState;\n/**\n * 3.11 Extended Content Description Object (optional, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_11\n */\nclass ExtendedContentDescriptionObjectState extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(buf, off) {\n    const tags = [];\n    const attrCount = buf.readUInt16LE(off);\n    let pos = off + 2;\n    for (let i = 0; i < attrCount; i += 1) {\n      const nameLen = buf.readUInt16LE(pos);\n      pos += 2;\n      const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));\n      pos += nameLen;\n      const valueType = buf.readUInt16LE(pos);\n      pos += 2;\n      const valueLen = buf.readUInt16LE(pos);\n      pos += 2;\n      const value = buf.slice(pos, pos + valueLen);\n      pos += valueLen;\n      this.postProcessTag(tags, name, valueType, value);\n    }\n    return tags;\n  }\n}\nExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;\nexports.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;\n/**\n * 4.1 Extended Stream Properties Object (optional, 1 per media stream)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_1\n */\nclass ExtendedStreamPropertiesObjectState extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(buf, off) {\n    return {\n      startTime: Token.UINT64_LE.get(buf, off),\n      endTime: Token.UINT64_LE.get(buf, off + 8),\n      dataBitrate: buf.readInt32LE(off + 12),\n      bufferSize: buf.readInt32LE(off + 16),\n      initialBufferFullness: buf.readInt32LE(off + 20),\n      alternateDataBitrate: buf.readInt32LE(off + 24),\n      alternateBufferSize: buf.readInt32LE(off + 28),\n      alternateInitialBufferFullness: buf.readInt32LE(off + 32),\n      maximumObjectSize: buf.readInt32LE(off + 36),\n      flags: {\n        reliableFlag: util.getBit(buf, off + 40, 0),\n        seekableFlag: util.getBit(buf, off + 40, 1),\n        resendLiveCleanpointsFlag: util.getBit(buf, off + 40, 2)\n      },\n      // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),\n      streamNumber: buf.readInt16LE(off + 42),\n      streamLanguageId: buf.readInt16LE(off + 44),\n      averageTimePerFrame: buf.readInt32LE(off + 52),\n      streamNameCount: buf.readInt32LE(off + 54),\n      payloadExtensionSystems: buf.readInt32LE(off + 56),\n      streamNames: [],\n      streamPropertiesObject: null\n    };\n  }\n}\nExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;\nexports.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;\n/**\n * 4.7  Metadata Object (optional, 0 or 1)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_7\n */\nclass MetadataObjectState extends State {\n  constructor(header) {\n    super(header);\n  }\n  get(uint8Array, off) {\n    const tags = [];\n    const buf = Buffer.from(uint8Array);\n    const descriptionRecordsCount = buf.readUInt16LE(off);\n    let pos = off + 2;\n    for (let i = 0; i < descriptionRecordsCount; i += 1) {\n      pos += 4;\n      const nameLen = buf.readUInt16LE(pos);\n      pos += 2;\n      const dataType = buf.readUInt16LE(pos);\n      pos += 2;\n      const dataLen = buf.readUInt32LE(pos);\n      pos += 4;\n      const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));\n      pos += nameLen;\n      const data = buf.slice(pos, pos + dataLen);\n      pos += dataLen;\n      this.postProcessTag(tags, name, dataType, data);\n    }\n    return tags;\n  }\n}\nMetadataObjectState.guid = GUID_1.default.MetadataObject;\nexports.MetadataObjectState = MetadataObjectState;\n// 4.8\tMetadata Library Object (optional, 0 or 1)\nclass MetadataLibraryObjectState extends MetadataObjectState {\n  constructor(header) {\n    super(header);\n  }\n}\nMetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;\nexports.MetadataLibraryObjectState = MetadataLibraryObjectState;\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd757977(v=vs.85).aspx\n */\nclass WmPictureToken {\n  static fromBase64(base64str) {\n    return this.fromBuffer(Buffer.from(base64str, 'base64'));\n  }\n  static fromBuffer(buffer) {\n    const pic = new WmPictureToken(buffer.length);\n    return pic.get(buffer, 0);\n  }\n  constructor(len) {\n    this.len = len;\n  }\n  get(buffer, offset) {\n    const typeId = buffer.readUInt8(offset++);\n    const size = buffer.readInt32LE(offset);\n    let index = 5;\n    while (buffer.readUInt16BE(index) !== 0) {\n      index += 2;\n    }\n    const format = buffer.slice(5, index).toString('utf16le');\n    while (buffer.readUInt16BE(index) !== 0) {\n      index += 2;\n    }\n    const description = buffer.slice(5, index).toString('utf16le');\n    return {\n      type: ID3v2Token_1.AttachedPictureType[typeId],\n      format,\n      description,\n      size,\n      data: buffer.slice(index + 4)\n    };\n  }\n}\nexports.WmPictureToken = WmPictureToken;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}