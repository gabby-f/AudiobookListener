{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FlacParser = void 0;\nconst token_types_1 = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst util = require(\"../common/Util\");\nconst Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\nconst VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\nconst debug = (0, debug_1.default)('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n  BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n  BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n  BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n  BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n  BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n  BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n  BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.padding = 0;\n  }\n  /**\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n   * @param {INativeMetadataCollector} metadata Output\n   * @param {ITokenizer} tokenizer Input\n   * @param {IOptions} options Parsing options\n   */\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n    return this;\n  }\n  async postId3v2Parse() {\n    const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    if (fourCC.toString() !== 'fLaC') {\n      throw new Error('Invalid FLAC preamble');\n    }\n    let blockHeader;\n    do {\n      // Read block header\n      blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\n      // Parse block data\n      await this.parseDataBlock(blockHeader);\n    } while (!blockHeader.lastBlock);\n    if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n      const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n      this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n    }\n  }\n  parseDataBlock(blockHeader) {\n    debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n    switch (blockHeader.type) {\n      case BlockType.STREAMINFO:\n        return this.parseBlockStreamInfo(blockHeader.length);\n      case BlockType.PADDING:\n        this.padding += blockHeader.length;\n        break;\n      case BlockType.APPLICATION:\n        break;\n      case BlockType.SEEKTABLE:\n        break;\n      case BlockType.VORBIS_COMMENT:\n        return this.parseComment(blockHeader.length);\n      case BlockType.CUESHEET:\n        break;\n      case BlockType.PICTURE:\n        return this.parsePicture(blockHeader.length).then();\n      default:\n        this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n    }\n    // Ignore data block\n    return this.tokenizer.ignore(blockHeader.length).then();\n  }\n  /**\n   * Parse STREAMINFO\n   */\n  async parseBlockStreamInfo(dataLen) {\n    if (dataLen !== Metadata.BlockStreamInfo.len) throw new Error('Unexpected block-stream-info length');\n    const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n    this.metadata.setFormat('container', 'FLAC');\n    this.metadata.setFormat('codec', 'FLAC');\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n    this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n    this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n    if (streamInfo.totalSamples > 0) {\n      this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n    }\n  }\n  /**\n   * Parse VORBIS_COMMENT\n   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n   */\n  async parseComment(dataLen) {\n    const data = await this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen));\n    const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n    decoder.readStringUtf8(); // vendor (skip)\n    const commentListLength = decoder.readInt32();\n    for (let i = 0; i < commentListLength; i++) {\n      const tag = decoder.parseUserComment();\n      this.vorbisParser.addTag(tag.key, tag.value);\n    }\n  }\n  async parsePicture(dataLen) {\n    if (this.options.skipCovers) {\n      return this.tokenizer.ignore(dataLen);\n    } else {\n      const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n      this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n  }\n}\nexports.FlacParser = FlacParser;\nclass Metadata {}\nMetadata.BlockHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return {\n      lastBlock: util.getBit(buf, off, 7),\n      type: util.getBitAllignedNumber(buf, off, 1, 7),\n      length: token_types_1.UINT24_BE.get(buf, off + 1)\n    };\n  }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nMetadata.BlockStreamInfo = {\n  len: 34,\n  get: (buf, off) => {\n    return {\n      // The minimum block size (in samples) used in the stream.\n      minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),\n      // The maximum block size (in samples) used in the stream.\n      // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n      maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1000,\n      // The minimum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),\n      // The maximum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),\n      // Sample rate in Hz. Though 20 bits are available,\n      // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n      // Also, a value of 0 is invalid.\n      sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,\n      // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n      // (number of channels)-1. FLAC supports from 1 to 8 channels\n      channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n      // bits per sample)-1.\n      // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n      bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n      // Total samples in stream.\n      // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n      // A value of zero here means the number of total samples is unknown.\n      totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n      // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n      fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}