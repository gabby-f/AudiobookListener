{"ast":null,"code":"/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\n\nexport async function extractM4BChapters(file) {\n  try {\n    const buffer = await file.arrayBuffer();\n    const view = new DataView(buffer);\n    console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\n\n    // Find the moov atom which contains all metadata\n    const moov = findAtom(view, 'moov', 0);\n    if (!moov) {\n      console.log('No moov atom found in file');\n      return [];\n    }\n    console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\n\n    // Method 1: Look for udta (user data) -> chpl (chapter list)\n    const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\n    if (udta) {\n      console.log('Found udta atom at offset:', udta.offset);\n      const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\n      if (chpl) {\n        console.log('Found chpl atom in udta at offset:', chpl.offset);\n        const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\n        if (chapters.length > 0) {\n          console.log('Successfully extracted', chapters.length, 'chapters from chpl');\n          return chapters;\n        }\n      }\n    }\n\n    // Method 2: Look for chapter track (text track referenced as chapters)\n    const chapters = parseChapterTrack(view, moov.offset, moov.size);\n    if (chapters.length > 0) {\n      console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\n      return chapters;\n    }\n    console.log('No chapters found in file');\n    return [];\n  } catch (error) {\n    console.error('Error extracting M4B chapters:', error);\n    return [];\n  }\n}\n\n// Find an atom starting from the beginning of the file\nfunction findAtom(view, atomName, startOffset = 0) {\n  let offset = startOffset;\n  const maxSearch = Math.min(view.byteLength, startOffset + 50000000); // Search up to 50MB\n\n  while (offset < maxSearch - 8) {\n    const size = view.getUint32(offset, false); // Big-endian\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0) break; // Size 0 means atom extends to EOF\n    if (size === 1) {\n      // Extended size in next 8 bytes\n      const extSize = view.getBigUint64(offset + 8, false);\n      offset += Number(extSize);\n    } else if (size < 8) {\n      // Invalid size\n      offset += 1;\n    } else {\n      offset += size;\n    }\n  }\n  return null;\n}\n\n// Find an atom within a parent atom's boundaries\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\n  let offset = parentOffset + 8; // Skip parent's size and name\n  const endOffset = parentOffset + parentSize;\n  while (offset < endOffset - 8 && offset < view.byteLength) {\n    const size = view.getUint32(offset, false);\n    const name = readAtomName(view, offset + 4);\n    if (name === atomName) {\n      return {\n        offset,\n        size\n      };\n    }\n\n    // Skip to next atom\n    if (size === 0 || size === 1) break; // Extended size not common in nested atoms\n    if (size < 8) {\n      offset += 1;\n      continue;\n    }\n    offset += size;\n  }\n  return null;\n}\n\n// Read 4-byte atom name as ASCII string\nfunction readAtomName(view, offset) {\n  if (offset + 4 > view.byteLength) return '';\n  let name = '';\n  for (let i = 0; i < 4; i++) {\n    name += String.fromCharCode(view.getUint8(offset + i));\n  }\n  return name;\n}\n\n// Parse the chpl (chapter list) atom\nfunction parseChplAtom(view, dataOffset, dataSize) {\n  try {\n    // chpl data structure:\n    // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\n    if (dataSize < 12) {\n      console.log('chpl atom too small:', dataSize);\n      return [];\n    }\n    const version = view.getUint8(dataOffset);\n    const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\n\n    console.log('chpl version:', version, 'entry count:', entryCount);\n    if (entryCount === 0 || entryCount > 1000) {\n      console.log('Invalid chapter count:', entryCount);\n      return [];\n    }\n    const chapters = [];\n    let currentOffset = dataOffset + 12;\n    const endOffset = dataOffset + dataSize;\n    for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\n      // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\n      if (currentOffset + 9 > endOffset) break;\n\n      // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\n      const timestampHigh = view.getUint32(currentOffset, false);\n      const timestampLow = view.getUint32(currentOffset + 4, false);\n      const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\n\n      const titleLength = view.getUint8(currentOffset + 8);\n      currentOffset += 9;\n      if (currentOffset + titleLength > endOffset) break;\n      let title = '';\n      if (titleLength > 0) {\n        const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\n        title = new TextDecoder('utf-8').decode(titleBytes);\n      }\n      currentOffset += titleLength;\n      chapters.push({\n        title: title.trim() || `Chapter ${i + 1}`,\n        startTime: timestamp,\n        duration: null\n      });\n    }\n\n    // Calculate durations\n    for (let i = 0; i < chapters.length - 1; i++) {\n      chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\n    }\n    console.log('Parsed chapters:', chapters);\n    return chapters;\n  } catch (error) {\n    console.error('Error parsing chpl atom:', error);\n    return [];\n  }\n}\nfunction parseChaptersFromMoov(view, moovOffset) {\n  // This is a fallback parser that looks through the moov structure\n  // for chapter information in various formats\n  const chapters = [];\n  try {\n    // Get moov size to know search bounds\n    if (moovOffset < 4) return [];\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n\n    // Search for chapter markers within moov\n    for (let i = moovOffset; i < moovEnd - 100; i++) {\n      // Look for common chapter patterns\n      if (view.getUint32(i, false) === 0x6368706c ||\n      // 'chpl' in reverse endian\n      view.getUint32(i, false) === 0x6c706863) {\n        // 'lphc' \n        const chapterData = parseChplAtom(view, i);\n        if (chapterData.length > 0) {\n          return chapterData;\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing moov for chapters:', error);\n  }\n  return chapters;\n}\n\n// Parse chapter track (similar to VLC's method for chapter tracks)\nfunction parseChapterTrack(view, moovOffset) {\n  const chapters = [];\n  try {\n    // Look for trak atoms within moov\n    let searchOffset = moovOffset;\n    const moovSize = view.getUint32(moovOffset - 4, false);\n    const moovEnd = moovOffset + moovSize;\n    while (searchOffset < moovEnd) {\n      const trakOffset = findAtom(view, 'trak', searchOffset);\n      if (trakOffset === -1 || trakOffset >= moovEnd) break;\n\n      // Check if this is a chapter track by looking for tref\n      const trefOffset = findAtom(view, 'tref', trakOffset);\n      if (trefOffset !== -1) {\n        const chapterEntries = parseChapterEntries(view, trakOffset);\n        if (chapterEntries.length > 0) {\n          return chapterEntries;\n        }\n      }\n      searchOffset = trakOffset + 100; // Move forward to find next trak\n    }\n  } catch (error) {\n    console.error('Error parsing chapter track:', error);\n  }\n  return chapters;\n}\nfunction parseChapterEntries(view, trakOffset) {\n  const chapters = [];\n  try {\n    // Look for stbl (sample table) which contains chapter info\n    const stblOffset = findAtom(view, 'stbl', trakOffset);\n    if (stblOffset === -1) return [];\n\n    // Look for stts (time-to-sample) and stsd (sample description)\n    const sttsOffset = findAtom(view, 'stts', stblOffset);\n    const stsdOffset = findAtom(view, 'stsd', stblOffset);\n    if (sttsOffset !== -1 && stsdOffset !== -1) {\n      // Parse sample times from stts\n      const sampleCount = view.getUint32(sttsOffset + 12, false);\n      let currentTime = 0;\n      for (let i = 0; i < Math.min(sampleCount, 100); i++) {\n        const entryOffset = sttsOffset + 16 + i * 8;\n        if (entryOffset + 8 > view.byteLength) break;\n        const sampleCount = view.getUint32(entryOffset, false);\n        const sampleDelta = view.getUint32(entryOffset + 4, false);\n        chapters.push({\n          title: `Chapter ${i + 1}`,\n          startTime: currentTime / 1000,\n          // Convert to seconds\n          duration: null\n        });\n        currentTime += sampleCount * sampleDelta;\n      }\n    }\n  } catch (error) {\n    console.error('Error parsing chapter entries:', error);\n  }\n  return chapters;\n}\nexport function formatTime(seconds) {\n  if (!seconds || isNaN(seconds)) return '0:00';\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hrs > 0) {\n    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","map":{"version":3,"names":["extractM4BChapters","file","buffer","arrayBuffer","view","DataView","console","log","byteLength","moov","findAtom","offset","size","udta","findAtomInParent","chpl","chapters","parseChplAtom","length","parseChapterTrack","error","atomName","startOffset","maxSearch","Math","min","getUint32","name","readAtomName","extSize","getBigUint64","Number","parentOffset","parentSize","endOffset","i","String","fromCharCode","getUint8","dataOffset","dataSize","version","entryCount","currentOffset","timestampHigh","timestampLow","timestamp","titleLength","title","titleBytes","Uint8Array","byteOffset","TextDecoder","decode","push","trim","startTime","duration","parseChaptersFromMoov","moovOffset","moovSize","moovEnd","chapterData","searchOffset","trakOffset","trefOffset","chapterEntries","parseChapterEntries","stblOffset","sttsOffset","stsdOffset","sampleCount","currentTime","entryOffset","sampleDelta","formatTime","seconds","isNaN","hrs","floor","mins","secs","toString","padStart"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/utils/m4bParser.js"],"sourcesContent":["/**\r\n * M4B Chapter Extractor - Extracts chapter information from M4B files\r\n * Similar to how VLC media player reads chapter data from MP4/M4B files\r\n * \r\n * MP4/M4B Atom structure: [size: 4 bytes big-endian][name: 4 bytes ASCII][data: size-8 bytes]\r\n */\r\n\r\nexport async function extractM4BChapters(file) {\r\n    try {\r\n        const buffer = await file.arrayBuffer();\r\n        const view = new DataView(buffer);\r\n        \r\n        console.log('Starting M4B chapter extraction, file size:', buffer.byteLength);\r\n        \r\n        // Find the moov atom which contains all metadata\r\n        const moov = findAtom(view, 'moov', 0);\r\n        if (!moov) {\r\n            console.log('No moov atom found in file');\r\n            return [];\r\n        }\r\n        \r\n        console.log('Found moov atom at offset:', moov.offset, 'size:', moov.size);\r\n        \r\n        // Method 1: Look for udta (user data) -> chpl (chapter list)\r\n        const udta = findAtomInParent(view, 'udta', moov.offset, moov.size);\r\n        if (udta) {\r\n            console.log('Found udta atom at offset:', udta.offset);\r\n            const chpl = findAtomInParent(view, 'chpl', udta.offset, udta.size);\r\n            if (chpl) {\r\n                console.log('Found chpl atom in udta at offset:', chpl.offset);\r\n                const chapters = parseChplAtom(view, chpl.offset + 8, chpl.size - 8);\r\n                if (chapters.length > 0) {\r\n                    console.log('Successfully extracted', chapters.length, 'chapters from chpl');\r\n                    return chapters;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Method 2: Look for chapter track (text track referenced as chapters)\r\n        const chapters = parseChapterTrack(view, moov.offset, moov.size);\r\n        if (chapters.length > 0) {\r\n            console.log('Successfully extracted', chapters.length, 'chapters from chapter track');\r\n            return chapters;\r\n        }\r\n        \r\n        console.log('No chapters found in file');\r\n        return [];\r\n        \r\n    } catch (error) {\r\n        console.error('Error extracting M4B chapters:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Find an atom starting from the beginning of the file\r\nfunction findAtom(view, atomName, startOffset = 0) {\r\n    let offset = startOffset;\r\n    const maxSearch = Math.min(view.byteLength, startOffset + 50000000); // Search up to 50MB\r\n    \r\n    while (offset < maxSearch - 8) {\r\n        const size = view.getUint32(offset, false); // Big-endian\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0) break; // Size 0 means atom extends to EOF\r\n        if (size === 1) {\r\n            // Extended size in next 8 bytes\r\n            const extSize = view.getBigUint64(offset + 8, false);\r\n            offset += Number(extSize);\r\n        } else if (size < 8) {\r\n            // Invalid size\r\n            offset += 1;\r\n        } else {\r\n            offset += size;\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Find an atom within a parent atom's boundaries\r\nfunction findAtomInParent(view, atomName, parentOffset, parentSize) {\r\n    let offset = parentOffset + 8; // Skip parent's size and name\r\n    const endOffset = parentOffset + parentSize;\r\n    \r\n    while (offset < endOffset - 8 && offset < view.byteLength) {\r\n        const size = view.getUint32(offset, false);\r\n        const name = readAtomName(view, offset + 4);\r\n        \r\n        if (name === atomName) {\r\n            return { offset, size };\r\n        }\r\n        \r\n        // Skip to next atom\r\n        if (size === 0 || size === 1) break; // Extended size not common in nested atoms\r\n        if (size < 8) {\r\n            offset += 1;\r\n            continue;\r\n        }\r\n        \r\n        offset += size;\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n// Read 4-byte atom name as ASCII string\r\nfunction readAtomName(view, offset) {\r\n    if (offset + 4 > view.byteLength) return '';\r\n    let name = '';\r\n    for (let i = 0; i < 4; i++) {\r\n        name += String.fromCharCode(view.getUint8(offset + i));\r\n    }\r\n    return name;\r\n}\r\n\r\n// Parse the chpl (chapter list) atom\r\nfunction parseChplAtom(view, dataOffset, dataSize) {\r\n    try {\r\n        // chpl data structure:\r\n        // version (1 byte) + flags (3 bytes) + reserved (4 bytes) + entry count (4 bytes)\r\n        if (dataSize < 12) {\r\n            console.log('chpl atom too small:', dataSize);\r\n            return [];\r\n        }\r\n        \r\n        const version = view.getUint8(dataOffset);\r\n        const entryCount = view.getUint32(dataOffset + 8, false); // Big-endian\r\n        \r\n        console.log('chpl version:', version, 'entry count:', entryCount);\r\n        \r\n        if (entryCount === 0 || entryCount > 1000) {\r\n            console.log('Invalid chapter count:', entryCount);\r\n            return [];\r\n        }\r\n        \r\n        const chapters = [];\r\n        let currentOffset = dataOffset + 12;\r\n        const endOffset = dataOffset + dataSize;\r\n        \r\n        for (let i = 0; i < entryCount && currentOffset < endOffset - 5; i++) {\r\n            // Each entry: timestamp (8 bytes, 100-nanosecond units) + title length (1 byte) + title\r\n            if (currentOffset + 9 > endOffset) break;\r\n            \r\n            // Read timestamp as 64-bit big-endian integer (in 100-nanosecond units)\r\n            const timestampHigh = view.getUint32(currentOffset, false);\r\n            const timestampLow = view.getUint32(currentOffset + 4, false);\r\n            const timestamp = (timestampHigh * 0x100000000 + timestampLow) / 10000000; // Convert to seconds\r\n            \r\n            const titleLength = view.getUint8(currentOffset + 8);\r\n            currentOffset += 9;\r\n            \r\n            if (currentOffset + titleLength > endOffset) break;\r\n            \r\n            let title = '';\r\n            if (titleLength > 0) {\r\n                const titleBytes = new Uint8Array(view.buffer, view.byteOffset + currentOffset, titleLength);\r\n                title = new TextDecoder('utf-8').decode(titleBytes);\r\n            }\r\n            \r\n            currentOffset += titleLength;\r\n            \r\n            chapters.push({\r\n                title: title.trim() || `Chapter ${i + 1}`,\r\n                startTime: timestamp,\r\n                duration: null\r\n            });\r\n        }\r\n        \r\n        // Calculate durations\r\n        for (let i = 0; i < chapters.length - 1; i++) {\r\n            chapters[i].duration = chapters[i + 1].startTime - chapters[i].startTime;\r\n        }\r\n        \r\n        console.log('Parsed chapters:', chapters);\r\n        return chapters;\r\n        \r\n    } catch (error) {\r\n        console.error('Error parsing chpl atom:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction parseChaptersFromMoov(view, moovOffset) {\r\n    // This is a fallback parser that looks through the moov structure\r\n    // for chapter information in various formats\r\n    const chapters = [];\r\n    \r\n    try {\r\n        // Get moov size to know search bounds\r\n        if (moovOffset < 4) return [];\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        // Search for chapter markers within moov\r\n        for (let i = moovOffset; i < moovEnd - 100; i++) {\r\n            // Look for common chapter patterns\r\n            if (view.getUint32(i, false) === 0x6368706c || // 'chpl' in reverse endian\r\n                view.getUint32(i, false) === 0x6c706863) {  // 'lphc' \r\n                const chapterData = parseChplAtom(view, i);\r\n                if (chapterData.length > 0) {\r\n                    return chapterData;\r\n                }\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing moov for chapters:', error);\r\n    }\r\n    \r\n    return chapters;\r\n}\r\n\r\n// Parse chapter track (similar to VLC's method for chapter tracks)\r\nfunction parseChapterTrack(view, moovOffset) {\r\n    const chapters = [];\r\n    try {\r\n        // Look for trak atoms within moov\r\n        let searchOffset = moovOffset;\r\n        const moovSize = view.getUint32(moovOffset - 4, false);\r\n        const moovEnd = moovOffset + moovSize;\r\n        \r\n        while (searchOffset < moovEnd) {\r\n            const trakOffset = findAtom(view, 'trak', searchOffset);\r\n            if (trakOffset === -1 || trakOffset >= moovEnd) break;\r\n            \r\n            // Check if this is a chapter track by looking for tref\r\n            const trefOffset = findAtom(view, 'tref', trakOffset);\r\n            if (trefOffset !== -1) {\r\n                const chapterEntries = parseChapterEntries(view, trakOffset);\r\n                if (chapterEntries.length > 0) {\r\n                    return chapterEntries;\r\n                }\r\n            }\r\n            \r\n            searchOffset = trakOffset + 100; // Move forward to find next trak\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter track:', error);\r\n    }\r\n    return chapters;\r\n}\r\n\r\nfunction parseChapterEntries(view, trakOffset) {\r\n    const chapters = [];\r\n    try {\r\n        // Look for stbl (sample table) which contains chapter info\r\n        const stblOffset = findAtom(view, 'stbl', trakOffset);\r\n        if (stblOffset === -1) return [];\r\n        \r\n        // Look for stts (time-to-sample) and stsd (sample description)\r\n        const sttsOffset = findAtom(view, 'stts', stblOffset);\r\n        const stsdOffset = findAtom(view, 'stsd', stblOffset);\r\n        \r\n        if (sttsOffset !== -1 && stsdOffset !== -1) {\r\n            // Parse sample times from stts\r\n            const sampleCount = view.getUint32(sttsOffset + 12, false);\r\n            let currentTime = 0;\r\n            \r\n            for (let i = 0; i < Math.min(sampleCount, 100); i++) {\r\n                const entryOffset = sttsOffset + 16 + (i * 8);\r\n                if (entryOffset + 8 > view.byteLength) break;\r\n                \r\n                const sampleCount = view.getUint32(entryOffset, false);\r\n                const sampleDelta = view.getUint32(entryOffset + 4, false);\r\n                \r\n                chapters.push({\r\n                    title: `Chapter ${i + 1}`,\r\n                    startTime: currentTime / 1000, // Convert to seconds\r\n                    duration: null\r\n                });\r\n                \r\n                currentTime += sampleCount * sampleDelta;\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing chapter entries:', error);\r\n    }\r\n    return chapters;\r\n}\r\n\r\nexport function formatTime(seconds) {\r\n    if (!seconds || isNaN(seconds)) return '0:00';\r\n    const hrs = Math.floor(seconds / 3600);\r\n    const mins = Math.floor((seconds % 3600) / 60);\r\n    const secs = Math.floor(seconds % 60);\r\n    \r\n    if (hrs > 0) {\r\n        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\r\n    }\r\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}