{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = exports.EndOfStreamError = void 0;\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\nconst Deferred_1 = require(\"./Deferred\");\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\nObject.defineProperty(exports, \"EndOfStreamError\", {\n  enumerable: true,\n  get: function () {\n    return EndOfFileStream_2.EndOfStreamError;\n  }\n});\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nclass StreamReader {\n  constructor(s) {\n    this.s = s;\n    /**\r\n     * Deferred used for postponed read request (as not data is yet available to read)\r\n     */\n    this.deferred = null;\n    this.endOfStream = false;\n    /**\r\n     * Store peeked data\r\n     * @type {Array}\r\n     */\n    this.peekQueue = [];\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n    this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n    this.s.once('error', err => this.reject(err));\n    this.s.once('close', () => this.reject(new Error('Stream closed')));\n  }\n  /**\r\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n   * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes peeked\r\n   */\n  async peek(uint8Array, offset, length) {\n    const bytesRead = await this.read(uint8Array, offset, length);\n    this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\n    return bytesRead;\n  }\n  /**\r\n   * Read chunk from stream\r\n   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes read\r\n   */\n  async read(buffer, offset, length) {\n    if (length === 0) {\n      return 0;\n    }\n    if (this.peekQueue.length === 0 && this.endOfStream) {\n      throw new EndOfFileStream_1.EndOfStreamError();\n    }\n    let remaining = length;\n    let bytesRead = 0;\n    // consume peeked data first\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n      if (!peekData) throw new Error('peekData should be defined');\n      const lenCopy = Math.min(peekData.length, remaining);\n      buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.subarray(lenCopy));\n      }\n    }\n    // continue reading from stream if required\n    while (remaining > 0 && !this.endOfStream) {\n      const reqLen = Math.min(remaining, maxStreamReadSize);\n      const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\n      bytesRead += chunkLen;\n      if (chunkLen < reqLen) break;\n      remaining -= chunkLen;\n    }\n    return bytesRead;\n  }\n  /**\r\n   * Read chunk from stream\r\n   * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset Offset target\r\n   * @param length Number of bytes to read\r\n   * @returns Number of bytes read\r\n   */\n  async readFromStream(buffer, offset, length) {\n    const readBuffer = this.s.read(length);\n    if (readBuffer) {\n      buffer.set(readBuffer, offset);\n      return readBuffer.length;\n    } else {\n      const request = {\n        buffer,\n        offset,\n        length,\n        deferred: new Deferred_1.Deferred()\n      };\n      this.deferred = request.deferred;\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n      return request.deferred.promise;\n    }\n  }\n  /**\r\n   * Process deferred read request\r\n   * @param request Deferred read request\r\n   */\n  readDeferred(request) {\n    const readBuffer = this.s.read(request.length);\n    if (readBuffer) {\n      request.buffer.set(readBuffer, request.offset);\n      request.deferred.resolve(readBuffer.length);\n      this.deferred = null;\n    } else {\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n    }\n  }\n  reject(err) {\n    this.endOfStream = true;\n    if (this.deferred) {\n      this.deferred.reject(err);\n      this.deferred = null;\n    }\n  }\n}\nexports.StreamReader = StreamReader;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}