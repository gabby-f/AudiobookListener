{"ast":null,"code":"'use strict';\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexports.tarHeaderChecksumMatches = function (buffer) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n  if (isNaN(readSum)) {\n    return false;\n  }\n  let sum = 8 * 0x20; // Initialize signed bit sum\n\n  for (let i = offset; i < offset + 148; i++) {\n    sum += buffer[i];\n  }\n  for (let i = offset + 156; i < offset + 512; i++) {\n    sum += buffer[i];\n  }\n  return readSum === sum;\n};\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexports.uint32SyncSafeToken = {\n  get: (buffer, offset) => {\n    return buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;\n  },\n  len: 4\n};","map":{"version":3,"names":["exports","stringToBytes","string","map","character","charCodeAt","tarHeaderChecksumMatches","buffer","offset","arguments","length","undefined","readSum","parseInt","toString","replace","trim","isNaN","sum","i","uint32SyncSafeToken","get","len"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/node_modules/file-type/util.js"],"sourcesContent":["'use strict';\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexports.tarHeaderChecksumMatches = (buffer, offset = 0) => {\n\tconst readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\tif (isNaN(readSum)) {\n\t\treturn false;\n\t}\n\n\tlet sum = 8 * 0x20; // Initialize signed bit sum\n\n\tfor (let i = offset; i < offset + 148; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\tfor (let i = offset + 156; i < offset + 512; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\treturn readSum === sum;\n};\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexports.uint32SyncSafeToken = {\n\tget: (buffer, offset) => {\n\t\treturn (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);\n\t},\n\tlen: 4\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,aAAa,GAAGC,MAAM,IAAI,CAAC,GAAGA,MAAM,CAAC,CAACC,GAAG,CAACC,SAAS,IAAIA,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,OAAO,CAACM,wBAAwB,GAAG,UAACC,MAAM,EAAiB;EAAA,IAAfC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACrD,MAAMG,OAAO,GAAGC,QAAQ,CAACN,MAAM,CAACO,QAAQ,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,CAACC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAC5F,IAAIC,KAAK,CAACL,OAAO,CAAC,EAAE;IACnB,OAAO,KAAK;EACb;EAEA,IAAIM,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;;EAEpB,KAAK,IAAIC,CAAC,GAAGX,MAAM,EAAEW,CAAC,GAAGX,MAAM,GAAG,GAAG,EAAEW,CAAC,EAAE,EAAE;IAC3CD,GAAG,IAAIX,MAAM,CAACY,CAAC,CAAC;EACjB;EAEA,KAAK,IAAIA,CAAC,GAAGX,MAAM,GAAG,GAAG,EAAEW,CAAC,GAAGX,MAAM,GAAG,GAAG,EAAEW,CAAC,EAAE,EAAE;IACjDD,GAAG,IAAIX,MAAM,CAACY,CAAC,CAAC;EACjB;EAEA,OAAOP,OAAO,KAAKM,GAAG;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACAlB,OAAO,CAACoB,mBAAmB,GAAG;EAC7BC,GAAG,EAAEA,CAACd,MAAM,EAAEC,MAAM,KAAK;IACxB,OAAQD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,GAAMD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,IAAK,CAAE,GAAKD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,IAAK,EAAG,GAAKD,MAAM,CAACC,MAAM,CAAC,IAAK,EAAG;EAC3H,CAAC;EACDc,GAAG,EAAE;AACN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}