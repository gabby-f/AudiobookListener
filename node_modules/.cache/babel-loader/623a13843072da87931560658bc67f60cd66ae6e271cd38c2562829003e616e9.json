{"ast":null,"code":"import _objectSpread from\"C:/Users/gabby/Documents/Audiobook Listener/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{useState,useCallback,useEffect,useRef}from'react';import{parseBlob}from'music-metadata-browser';import{extractM4BChapters}from'../utils/m4bParser';import FileUploader from'../Components/audiobook/FileUploader';import AudiobookPlayer from'../Components/audiobook/AudiobookPlayer';import Library from'../Components/audiobook/Library';import{saveFile,getFile,updateLibraryEntry}from'../utils/idbFileStore';import{jsx as _jsx,jsxs as _jsxs,Fragment as _Fragment}from\"react/jsx-runtime\";const STORAGE_KEY='audiobook_player_state';export default function AudiobookPage(){const[currentFileId,setCurrentFileId]=useState(null);const[audioFile,setAudioFile]=useState(null);const[chapters,setChapters]=useState([]);const[bookInfo,setBookInfo]=useState(null);const[isLoading,setIsLoading]=useState(false);const[savedState,setSavedState]=useState(null);// Use ref to always have access to the latest currentFileId without recreating callbacks\nconst currentFileIdRef=useRef(null);// Keep ref in sync with state\nuseEffect(()=>{currentFileIdRef.current=currentFileId;},[currentFileId]);// Load saved state on mount\nuseEffect(()=>{const saved=localStorage.getItem(STORAGE_KEY);if(saved){try{const state=JSON.parse(saved);setSavedState(state);}catch(error){console.error('Error loading saved state:',error);}}},[]);const parseM4BChapters=useCallback(async file=>{try{const extractedChapters=[];const info={title:null,artist:null,album:null,cover:null};// First, try to extract chapters using binary parsing (like VLC)\nconsole.log('Attempting to extract chapters from M4B file...');const binaryChapters=await extractM4BChapters(file);if(binaryChapters.length>0){console.log(\"Successfully extracted \".concat(binaryChapters.length,\" chapters from binary parsing\"));extractedChapters.push(...binaryChapters);}// Also get metadata using music-metadata for title, artist, cover, etc.\nlet metadata;try{metadata=await parseBlob(file,{duration:true,skipCovers:false,native:true});// Extract basic info\ninfo.title=metadata.common.title||file.name.replace(/\\.[^/.]+$/,'');info.artist=metadata.common.artist||metadata.common.albumartist||null;info.album=metadata.common.album||null;// Extract cover art\nif(metadata.common.picture&&metadata.common.picture.length>0){const picture=metadata.common.picture[0];const blob=new Blob([picture.data],{type:picture.format});info.cover=URL.createObjectURL(blob);}const duration=metadata.format.duration||0;// If binary parsing didn't find chapters, try metadata\nif(extractedChapters.length===0){console.log('No chapters from binary parsing, trying music-metadata...');if(metadata.native){// Check all native keys for chapter data\nfor(const key in metadata.native){const items=metadata.native[key];if(Array.isArray(items)){const chapterItems=items.filter(tag=>tag.id==='chpl'||tag.id==='chapters'||tag.mean&&tag.mean.includes('chapter'));if(chapterItems.length>0){console.log(\"Found chapter items in native.\".concat(key));for(const chplData of chapterItems){let chapters=[];if(Array.isArray(chplData.value)){chapters=chplData.value;}else if(chplData.value&&typeof chplData.value==='object'){chapters=Array.isArray(chplData.value.chapters)?chplData.value.chapters:Object.values(chplData.value);}for(const chapter of chapters){if(chapter&&(chapter.title||chapter.startTime!==undefined)){extractedChapters.push({title:chapter.title||chapter.name||\"Chapter \".concat(extractedChapters.length+1),startTime:(chapter.startTime||chapter.start||0)/1000,duration:null});}}}}}}}}// Calculate chapter durations if chapters were found\nif(extractedChapters.length>0){extractedChapters.sort((a,b)=>a.startTime-b.startTime);extractedChapters.forEach((chapter,index)=>{const nextChapter=extractedChapters[index+1];chapter.duration=nextChapter?nextChapter.startTime-chapter.startTime:duration-chapter.startTime;});console.log(\"Successfully extracted \".concat(extractedChapters.length,\" chapters\"));return{chapters:extractedChapters,info};}// Fallback: create time-based chapters if no chapters found\nif(duration>0){const chapterDuration=600;// 10 minute segments\nconst numChapters=Math.ceil(duration/chapterDuration);for(let i=0;i<numChapters;i++){const startTime=i*chapterDuration;extractedChapters.push({title:\"Part \".concat(i+1),startTime:startTime,duration:Math.min(chapterDuration,duration-startTime)});}console.log(\"No chapters found. Created \".concat(extractedChapters.length,\" time-based segments\"));}}catch(metadataError){console.error('Error parsing metadata:',metadataError);info.title=file.name.replace(/\\.[^/.]+$/,'');}return{chapters:extractedChapters,info};}catch(error){console.error('Error parsing M4B file:',error);return{chapters:[],info:{title:file.name.replace(/\\.[^/.]+$/,''),artist:null,album:null,cover:null}};}},[]);const handleFileSelect=useCallback(async file=>{setIsLoading(true);try{const{chapters:extractedChapters,info}=await parseM4BChapters(file);setChapters(extractedChapters);setBookInfo(info);setAudioFile(file);// Save file to library with metadata\ntry{const fileId=await saveFile(file,{title:info.title||file.name.replace(/\\.[^/.]+$/,''),artist:info.artist||'Unknown Artist',cover:info.cover||null,duration:info.duration||0});setCurrentFileId(fileId);}catch(idbErr){console.warn('Failed to save file to library:',idbErr);}}catch(error){console.error('Error parsing audiobook:',error);setAudioFile(file);setChapters([]);setBookInfo({title:file.name.replace(/\\.[^/.]+$/,'')});}finally{setIsLoading(false);}},[parseM4BChapters]);const handleClose=useCallback(()=>{setAudioFile(null);setChapters([]);setBookInfo(null);setCurrentFileId(null);setSavedState(null);// Clear saved state\ntry{localStorage.removeItem(STORAGE_KEY);}catch(err){// ignore\n}},[]);const handleLibrarySelect=useCallback(async(fileId,libraryEntry)=>{setIsLoading(true);try{// Load file from IndexedDB\nconst file=await getFile(fileId);if(!file){throw new Error('File not found in storage');}console.log('Loading book from library:',libraryEntry.title,'playback position:',libraryEntry.playbackPosition);// Parse chapters\nconst{chapters:extractedChapters,info}=await parseM4BChapters(file);setChapters(extractedChapters);setBookInfo(_objectSpread(_objectSpread({},info),{},{title:libraryEntry.title||info.title,artist:libraryEntry.artist||info.artist,cover:libraryEntry.cover||info.cover}));setAudioFile(file);setCurrentFileId(fileId);// Load saved playback position (ensure it's a valid number)\nconst playbackPosition=typeof libraryEntry.playbackPosition==='number'?libraryEntry.playbackPosition:0;console.log('Setting saved state with currentTime:',playbackPosition);setSavedState({currentTime:playbackPosition,currentChapterIndex:0,volume:1,speed:1});}catch(error){console.error('Error loading file from library:',error);}finally{setIsLoading(false);}},[parseM4BChapters]);const handleSaveState=useCallback(async state=>{localStorage.setItem(STORAGE_KEY,JSON.stringify(state));// Also update library entry with playback position using ref to avoid stale closures\nconst fileId=currentFileIdRef.current;if(fileId){try{console.log('Saving playback position:',state.currentTime,'for file:',fileId);await updateLibraryEntry(fileId,{playbackPosition:state.currentTime||0});console.log('Successfully saved playback position to library');}catch(err){console.warn('Failed to update playback position in library:',err);}}else{console.warn('No currentFileId when trying to save state');}},[]);// Empty dependency array - callback is stable, uses ref for currentFileId\nreturn/*#__PURE__*/_jsx(\"div\",{className:\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\",children:!audioFile?/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(FileUploader,{onFileSelect:handleFileSelect,isLoading:isLoading}),/*#__PURE__*/_jsxs(\"div\",{className:\"px-6 py-8\",children:[/*#__PURE__*/_jsx(\"h2\",{className:\"text-2xl font-bold text-white mb-6\",children:\"Your Library\"}),/*#__PURE__*/_jsx(Library,{onSelectFile:handleLibrarySelect,onLoadingChange:setIsLoading})]})]}):/*#__PURE__*/_jsx(\"div\",{className:\"h-screen\",children:/*#__PURE__*/_jsx(AudiobookPlayer,{file:audioFile,chapters:chapters,bookInfo:bookInfo,onClose:handleClose,savedState:savedState,onSaveState:handleSaveState})})});}","map":{"version":3,"names":["React","useState","useCallback","useEffect","useRef","parseBlob","extractM4BChapters","FileUploader","AudiobookPlayer","Library","saveFile","getFile","updateLibraryEntry","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","STORAGE_KEY","AudiobookPage","currentFileId","setCurrentFileId","audioFile","setAudioFile","chapters","setChapters","bookInfo","setBookInfo","isLoading","setIsLoading","savedState","setSavedState","currentFileIdRef","current","saved","localStorage","getItem","state","JSON","parse","error","console","parseM4BChapters","file","extractedChapters","info","title","artist","album","cover","log","binaryChapters","length","concat","push","metadata","duration","skipCovers","native","common","name","replace","albumartist","picture","blob","Blob","data","type","format","URL","createObjectURL","key","items","Array","isArray","chapterItems","filter","tag","id","mean","includes","chplData","value","Object","values","chapter","startTime","undefined","start","sort","a","b","forEach","index","nextChapter","chapterDuration","numChapters","Math","ceil","i","min","metadataError","handleFileSelect","fileId","idbErr","warn","handleClose","removeItem","err","handleLibrarySelect","libraryEntry","Error","playbackPosition","_objectSpread","currentTime","currentChapterIndex","volume","speed","handleSaveState","setItem","stringify","className","children","onFileSelect","onSelectFile","onLoadingChange","onClose","onSaveState"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/src/pages/Audiobook.jsx"],"sourcesContent":["import React, { useState, useCallback, useEffect, useRef } from 'react';\r\nimport { parseBlob } from 'music-metadata-browser';\r\nimport { extractM4BChapters } from '../utils/m4bParser';\r\nimport FileUploader from '../Components/audiobook/FileUploader';\r\nimport AudiobookPlayer from '../Components/audiobook/AudiobookPlayer';\r\nimport Library from '../Components/audiobook/Library';\r\nimport { saveFile, getFile, updateLibraryEntry } from '../utils/idbFileStore';\r\n\r\nconst STORAGE_KEY = 'audiobook_player_state';\r\n\r\nexport default function AudiobookPage() {\r\n    const [currentFileId, setCurrentFileId] = useState(null);\r\n    const [audioFile, setAudioFile] = useState(null);\r\n    const [chapters, setChapters] = useState([]);\r\n    const [bookInfo, setBookInfo] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [savedState, setSavedState] = useState(null);\r\n    \r\n    // Use ref to always have access to the latest currentFileId without recreating callbacks\r\n    const currentFileIdRef = useRef(null);\r\n    \r\n    // Keep ref in sync with state\r\n    useEffect(() => {\r\n        currentFileIdRef.current = currentFileId;\r\n    }, [currentFileId]);\r\n\r\n    // Load saved state on mount\r\n    useEffect(() => {\r\n        const saved = localStorage.getItem(STORAGE_KEY);\r\n        if (saved) {\r\n            try {\r\n                const state = JSON.parse(saved);\r\n                setSavedState(state);\r\n            } catch (error) {\r\n                console.error('Error loading saved state:', error);\r\n            }\r\n        }\r\n    }, []);\r\n    \r\n    const parseM4BChapters = useCallback(async (file) => {\r\n        try {\r\n            const extractedChapters = [];\r\n            const info = {\r\n                title: null,\r\n                artist: null,\r\n                album: null,\r\n                cover: null\r\n            };\r\n            \r\n            // First, try to extract chapters using binary parsing (like VLC)\r\n            console.log('Attempting to extract chapters from M4B file...');\r\n            const binaryChapters = await extractM4BChapters(file);\r\n            \r\n            if (binaryChapters.length > 0) {\r\n                console.log(`Successfully extracted ${binaryChapters.length} chapters from binary parsing`);\r\n                extractedChapters.push(...binaryChapters);\r\n            }\r\n            \r\n            // Also get metadata using music-metadata for title, artist, cover, etc.\r\n            let metadata;\r\n            try {\r\n                metadata = await parseBlob(file, { \r\n                    duration: true,\r\n                    skipCovers: false,\r\n                    native: true\r\n                });\r\n                \r\n                // Extract basic info\r\n                info.title = metadata.common.title || file.name.replace(/\\.[^/.]+$/, '');\r\n                info.artist = metadata.common.artist || metadata.common.albumartist || null;\r\n                info.album = metadata.common.album || null;\r\n                \r\n                // Extract cover art\r\n                if (metadata.common.picture && metadata.common.picture.length > 0) {\r\n                    const picture = metadata.common.picture[0];\r\n                    const blob = new Blob([picture.data], { type: picture.format });\r\n                    info.cover = URL.createObjectURL(blob);\r\n                }\r\n                \r\n                const duration = metadata.format.duration || 0;\r\n                \r\n                // If binary parsing didn't find chapters, try metadata\r\n                if (extractedChapters.length === 0) {\r\n                    console.log('No chapters from binary parsing, trying music-metadata...');\r\n                    \r\n                    if (metadata.native) {\r\n                        // Check all native keys for chapter data\r\n                        for (const key in metadata.native) {\r\n                            const items = metadata.native[key];\r\n                            \r\n                            if (Array.isArray(items)) {\r\n                                const chapterItems = items.filter(tag => \r\n                                    tag.id === 'chpl' || \r\n                                    tag.id === 'chapters' ||\r\n                                    (tag.mean && tag.mean.includes('chapter'))\r\n                                );\r\n                                \r\n                                if (chapterItems.length > 0) {\r\n                                    console.log(`Found chapter items in native.${key}`);\r\n                                    \r\n                                    for (const chplData of chapterItems) {\r\n                                        let chapters = [];\r\n                                        if (Array.isArray(chplData.value)) {\r\n                                            chapters = chplData.value;\r\n                                        } else if (chplData.value && typeof chplData.value === 'object') {\r\n                                            chapters = Array.isArray(chplData.value.chapters) \r\n                                                ? chplData.value.chapters \r\n                                                : Object.values(chplData.value);\r\n                                        }\r\n                                        \r\n                                        for (const chapter of chapters) {\r\n                                            if (chapter && (chapter.title || chapter.startTime !== undefined)) {\r\n                                                extractedChapters.push({\r\n                                                    title: chapter.title || chapter.name || `Chapter ${extractedChapters.length + 1}`,\r\n                                                    startTime: (chapter.startTime || chapter.start || 0) / 1000,\r\n                                                    duration: null\r\n                                                });\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // Calculate chapter durations if chapters were found\r\n                if (extractedChapters.length > 0) {\r\n                    extractedChapters.sort((a, b) => a.startTime - b.startTime);\r\n                    \r\n                    extractedChapters.forEach((chapter, index) => {\r\n                        const nextChapter = extractedChapters[index + 1];\r\n                        chapter.duration = nextChapter \r\n                            ? nextChapter.startTime - chapter.startTime\r\n                            : duration - chapter.startTime;\r\n                    });\r\n                    \r\n                    console.log(`Successfully extracted ${extractedChapters.length} chapters`);\r\n                    return { chapters: extractedChapters, info };\r\n                }\r\n                \r\n                // Fallback: create time-based chapters if no chapters found\r\n                if (duration > 0) {\r\n                    const chapterDuration = 600; // 10 minute segments\r\n                    const numChapters = Math.ceil(duration / chapterDuration);\r\n                    \r\n                    for (let i = 0; i < numChapters; i++) {\r\n                        const startTime = i * chapterDuration;\r\n                        extractedChapters.push({\r\n                            title: `Part ${i + 1}`,\r\n                            startTime: startTime,\r\n                            duration: Math.min(chapterDuration, duration - startTime)\r\n                        });\r\n                    }\r\n                    \r\n                    console.log(`No chapters found. Created ${extractedChapters.length} time-based segments`);\r\n                }\r\n                \r\n            } catch (metadataError) {\r\n                console.error('Error parsing metadata:', metadataError);\r\n                info.title = file.name.replace(/\\.[^/.]+$/, '');\r\n            }\r\n            \r\n            return { chapters: extractedChapters, info };\r\n            \r\n        } catch (error) {\r\n            console.error('Error parsing M4B file:', error);\r\n            return { \r\n                chapters: [], \r\n                info: { \r\n                    title: file.name.replace(/\\.[^/.]+$/, ''), \r\n                    artist: null, \r\n                    album: null,\r\n                    cover: null \r\n                } \r\n            };\r\n        }\r\n    }, []);\r\n\r\n    const handleFileSelect = useCallback(async (file) => {\r\n        setIsLoading(true);\r\n        \r\n        try {\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo(info);\r\n            setAudioFile(file);\r\n            \r\n            // Save file to library with metadata\r\n            try {\r\n                const fileId = await saveFile(file, {\r\n                    title: info.title || file.name.replace(/\\.[^/.]+$/, ''),\r\n                    artist: info.artist || 'Unknown Artist',\r\n                    cover: info.cover || null,\r\n                    duration: info.duration || 0,\r\n                });\r\n                setCurrentFileId(fileId);\r\n            } catch (idbErr) {\r\n                console.warn('Failed to save file to library:', idbErr);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error parsing audiobook:', error);\r\n            setAudioFile(file);\r\n            setChapters([]);\r\n            setBookInfo({ title: file.name.replace(/\\.[^/.]+$/, '') });\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleClose = useCallback(() => {\r\n        setAudioFile(null);\r\n        setChapters([]);\r\n        setBookInfo(null);\r\n        setCurrentFileId(null);\r\n        setSavedState(null);\r\n        // Clear saved state\r\n        try {\r\n            localStorage.removeItem(STORAGE_KEY);\r\n        } catch (err) {\r\n            // ignore\r\n        }\r\n    }, []);\r\n\r\n    const handleLibrarySelect = useCallback(async (fileId, libraryEntry) => {\r\n        setIsLoading(true);\r\n        try {\r\n            // Load file from IndexedDB\r\n            const file = await getFile(fileId);\r\n            if (!file) {\r\n                throw new Error('File not found in storage');\r\n            }\r\n\r\n            console.log('Loading book from library:', libraryEntry.title, 'playback position:', libraryEntry.playbackPosition);\r\n\r\n            // Parse chapters\r\n            const { chapters: extractedChapters, info } = await parseM4BChapters(file);\r\n            setChapters(extractedChapters);\r\n            setBookInfo({\r\n                ...info,\r\n                title: libraryEntry.title || info.title,\r\n                artist: libraryEntry.artist || info.artist,\r\n                cover: libraryEntry.cover || info.cover,\r\n            });\r\n            setAudioFile(file);\r\n            setCurrentFileId(fileId);\r\n\r\n            // Load saved playback position (ensure it's a valid number)\r\n            const playbackPosition = typeof libraryEntry.playbackPosition === 'number' \r\n                ? libraryEntry.playbackPosition \r\n                : 0;\r\n            \r\n            console.log('Setting saved state with currentTime:', playbackPosition);\r\n            setSavedState({\r\n                currentTime: playbackPosition,\r\n                currentChapterIndex: 0,\r\n                volume: 1,\r\n                speed: 1,\r\n            });\r\n        } catch (error) {\r\n            console.error('Error loading file from library:', error);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [parseM4BChapters]);\r\n\r\n    const handleSaveState = useCallback(async (state) => {\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\r\n        \r\n        // Also update library entry with playback position using ref to avoid stale closures\r\n        const fileId = currentFileIdRef.current;\r\n        if (fileId) {\r\n            try {\r\n                console.log('Saving playback position:', state.currentTime, 'for file:', fileId);\r\n                await updateLibraryEntry(fileId, {\r\n                    playbackPosition: state.currentTime || 0,\r\n                });\r\n                console.log('Successfully saved playback position to library');\r\n            } catch (err) {\r\n                console.warn('Failed to update playback position in library:', err);\r\n            }\r\n        } else {\r\n            console.warn('No currentFileId when trying to save state');\r\n        }\r\n    }, []); // Empty dependency array - callback is stable, uses ref for currentFileId\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950\">\r\n            {!audioFile ? (\r\n                <>\r\n                    <FileUploader \r\n                        onFileSelect={handleFileSelect} \r\n                        isLoading={isLoading}\r\n                    />\r\n                    <div className=\"px-6 py-8\">\r\n                        <h2 className=\"text-2xl font-bold text-white mb-6\">Your Library</h2>\r\n                        <Library \r\n                            onSelectFile={handleLibrarySelect}\r\n                            onLoadingChange={setIsLoading}\r\n                        />\r\n                    </div>\r\n                </>\r\n            ) : (\r\n                <div className=\"h-screen\">\r\n                    <AudiobookPlayer\r\n                        file={audioFile}\r\n                        chapters={chapters}\r\n                        bookInfo={bookInfo}\r\n                        onClose={handleClose}\r\n                        savedState={savedState}\r\n                        onSaveState={handleSaveState}\r\n                    />\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}