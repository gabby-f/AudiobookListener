{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VorbisParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst VorbisDecoder_1 = require(\"./VorbisDecoder\");\nconst Vorbis_1 = require(\"./Vorbis\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n  constructor(metadata, options) {\n    this.metadata = metadata;\n    this.options = options;\n    this.pageSegments = [];\n  }\n  /**\n   * Vorbis 1 parser\n   * @param header Ogg Page Header\n   * @param pageData Page data\n   */\n  parsePage(header, pageData) {\n    if (header.headerType.firstPage) {\n      this.parseFirstPage(header, pageData);\n    } else {\n      if (header.headerType.continued) {\n        if (this.pageSegments.length === 0) {\n          throw new Error(\"Cannot continue on previous page\");\n        }\n        this.pageSegments.push(pageData);\n      }\n      if (header.headerType.lastPage || !header.headerType.continued) {\n        // Flush page segments\n        if (this.pageSegments.length > 0) {\n          const fullPage = Buffer.concat(this.pageSegments);\n          this.parseFullPage(fullPage);\n        }\n        // Reset page segments\n        this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n      }\n    }\n    if (header.headerType.lastPage) {\n      this.calculateDuration(header);\n    }\n  }\n  flush() {\n    this.parseFullPage(Buffer.concat(this.pageSegments));\n  }\n  parseUserComment(pageData, offset) {\n    const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n    const tag = decoder.parseUserComment();\n    this.addTag(tag.key, tag.value);\n    return tag.len;\n  }\n  addTag(id, value) {\n    if (id === 'METADATA_BLOCK_PICTURE' && typeof value === 'string') {\n      if (this.options.skipCovers) {\n        debug(`Ignore picture`);\n        return;\n      }\n      value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n      debug(`Push picture: id=${id}, format=${value.format}`);\n    } else {\n      debug(`Push tag: id=${id}, value=${value}`);\n    }\n    this.metadata.addTag('vorbis', id, value);\n  }\n  calculateDuration(header) {\n    if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n      // Calculate duration\n      this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n      this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n    }\n  }\n  /**\n   * Parse first Ogg/Vorbis page\n   * @param {IPageHeader} header\n   * @param {Buffer} pageData\n   */\n  parseFirstPage(header, pageData) {\n    this.metadata.setFormat('codec', 'Vorbis I');\n    debug(\"Parse first page\");\n    // Parse  Vorbis common header\n    const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n    if (commonHeader.vorbis !== 'vorbis') throw new Error('Metadata does not look like Vorbis');\n    if (commonHeader.packetType === 1) {\n      const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n      this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n      this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n      this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n      debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n    } else throw new Error('First Ogg page should be type 1: the identification header');\n  }\n  parseFullPage(pageData) {\n    // New page\n    const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n    debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n    switch (commonHeader.packetType) {\n      case 3:\n        //  type 3: comment header\n        return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n      case 1: // type 1: the identification header\n      case 5:\n        // type 5: setup header type\n        break;\n      // ignore\n    }\n  }\n  /**\n   * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n   */\n  parseUserCommentList(pageData, offset) {\n    const strLen = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n    // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n    offset += strLen;\n    let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n    while (userCommentListLength-- > 0) {\n      offset += this.parseUserComment(pageData, offset);\n    }\n  }\n}\nexports.VorbisParser = VorbisParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}