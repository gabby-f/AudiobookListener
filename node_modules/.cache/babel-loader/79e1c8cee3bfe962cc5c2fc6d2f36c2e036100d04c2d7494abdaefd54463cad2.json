{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsdiffParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n    if (header.chunkID !== 'FRM8') throw new Error('Unexpected chunk-ID');\n    const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n    switch (type) {\n      case 'DSD':\n        this.metadata.setFormat('container', \"DSDIFF/\".concat(type));\n        this.metadata.setFormat('lossless', true);\n        return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n      default:\n        throw Error(\"Unsupported DSDIFF type: \".concat(type));\n    }\n  }\n  async readFmt8Chunks(remainingSize) {\n    while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n      //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n      debug(\"Chunk id=\".concat(chunkHeader.chunkID));\n      await this.readData(chunkHeader);\n      remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize;\n    }\n  }\n  async readData(header) {\n    debug(\"Reading data of chunk[ID=\".concat(header.chunkID, \", size=\").concat(header.chunkSize, \"]\"));\n    const p0 = this.tokenizer.position;\n    switch (header.chunkID.trim()) {\n      case 'FVER':\n        // 3.1 FORMAT VERSION CHUNK\n        const version = await this.tokenizer.readToken(Token.UINT32_LE);\n        debug(\"DSDIFF version=\".concat(version));\n        break;\n      case 'PROP':\n        // 3.2 PROPERTY CHUNK\n        const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (propType !== 'SND ') throw new Error('Unexpected PROP-chunk ID');\n        await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n        break;\n      case 'ID3':\n        // Unofficial ID3 tag support\n        const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        break;\n      default:\n        debug(\"Ignore chunk[ID=\".concat(header.chunkID, \", size=\").concat(header.chunkSize, \"]\"));\n        break;\n      case 'DSD':\n        this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        break;\n    }\n    const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n    if (remaining > 0) {\n      debug(\"After Parsing chunk, remaining \".concat(remaining, \" bytes\"));\n      await this.tokenizer.ignore(Number(remaining));\n    }\n  }\n  async handleSoundPropertyChunks(remainingSize) {\n    debug(\"Parsing sound-property-chunks, remainingSize=\".concat(remainingSize));\n    while (remainingSize > 0) {\n      const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n      debug(\"Sound-property-chunk[ID=\".concat(sndPropHeader.chunkID, \", size=\").concat(sndPropHeader.chunkSize, \"]\"));\n      const p0 = this.tokenizer.position;\n      switch (sndPropHeader.chunkID.trim()) {\n        case 'FS':\n          // 3.2.1 Sample Rate Chunk\n          const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n          this.metadata.setFormat('sampleRate', sampleRate);\n          break;\n        case 'CHNL':\n          // 3.2.2 Channels Chunk\n          const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n          this.metadata.setFormat('numberOfChannels', numChannels);\n          await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n          break;\n        case 'CMPR':\n          // 3.2.3 Compression Type Chunk\n          const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n          const count = await this.tokenizer.readToken(Token.UINT8);\n          const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n          if (compressionIdCode === 'DSD') {\n            this.metadata.setFormat('lossless', true);\n            this.metadata.setFormat('bitsPerSample', 1);\n          }\n          this.metadata.setFormat('codec', \"\".concat(compressionIdCode, \" (\").concat(compressionName, \")\"));\n          break;\n        case 'ABSS':\n          // 3.2.4 Absolute Start Time Chunk\n          const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n          const minutes = await this.tokenizer.readToken(Token.UINT8);\n          const seconds = await this.tokenizer.readToken(Token.UINT8);\n          const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n          debug(\"ABSS \".concat(hours, \":\").concat(minutes, \":\").concat(seconds, \".\").concat(samples));\n          break;\n        case 'LSCO':\n          // 3.2.5 Loudspeaker Configuration Chunk\n          const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n          debug(\"LSCO lsConfig=\".concat(lsConfig));\n          break;\n        case 'COMT':\n        default:\n          debug(\"Unknown sound-property-chunk[ID=\".concat(sndPropHeader.chunkID, \", size=\").concat(sndPropHeader.chunkSize, \"]\"));\n          await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n      }\n      const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n      if (remaining > 0) {\n        debug(\"After Parsing sound-property-chunk \".concat(sndPropHeader.chunkSize, \", remaining \").concat(remaining, \" bytes\"));\n        await this.tokenizer.ignore(Number(remaining));\n      }\n      remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;\n      debug(\"Parsing sound-property-chunks, remainingSize=\".concat(remainingSize));\n    }\n    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n      const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n      this.metadata.setFormat('bitrate', bitrate);\n    }\n  }\n  async handleChannelChunks(remainingSize) {\n    debug(\"Parsing channel-chunks, remainingSize=\".concat(remainingSize));\n    const channels = [];\n    while (remainingSize >= FourCC_1.FourCcToken.len) {\n      const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n      debug(\"Channel[ID=\".concat(channelId, \"]\"));\n      channels.push(channelId);\n      remainingSize -= BigInt(FourCC_1.FourCcToken.len);\n    }\n    debug(\"Channels: \".concat(channels.join(', ')));\n    return channels;\n  }\n}\nexports.DsdiffParser = DsdiffParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","DsdiffParser","Token","require","debug_1","strtok3","FourCC_1","BasicParser_1","ID3v2Parser_1","DsdiffToken_1","debug","default","BasicParser","parse","header","tokenizer","readToken","ChunkHeader64","chunkID","Error","type","FourCcToken","trim","metadata","setFormat","concat","readFmt8Chunks","chunkSize","BigInt","len","remainingSize","chunkHeader","readData","p0","position","version","UINT32_LE","propType","handleSoundPropertyChunks","id3_data","Uint8ArrayType","Number","rst","fromBuffer","ID3v2Parser","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","UINT32_BE","numChannels","UINT16_BE","handleChannelChunks","compressionIdCode","count","UINT8","compressionName","StringType","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"sources":["C:/Users/gabby/Documents/Audiobook Listener/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsdiffParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n        if (header.chunkID !== 'FRM8')\n            throw new Error('Unexpected chunk-ID');\n        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n        switch (type) {\n            case 'DSD':\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\n                this.metadata.setFormat('lossless', true);\n                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n            default:\n                throw Error(`Unsupported DSDIFF type: ${type}`);\n        }\n    }\n    async readFmt8Chunks(remainingSize) {\n        while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n            debug(`Chunk id=${chunkHeader.chunkID}`);\n            await this.readData(chunkHeader);\n            remainingSize -= (BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize);\n        }\n    }\n    async readData(header) {\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        const p0 = this.tokenizer.position;\n        switch (header.chunkID.trim()) {\n            case 'FVER': // 3.1 FORMAT VERSION CHUNK\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\n                debug(`DSDIFF version=${version}`);\n                break;\n            case 'PROP': // 3.2 PROPERTY CHUNK\n                const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n                if (propType !== 'SND ')\n                    throw new Error('Unexpected PROP-chunk ID');\n                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n                break;\n            case 'ID3': // Unofficial ID3 tag support\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                break;\n            default:\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n                break;\n            case 'DSD':\n                this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n                this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n                break;\n        }\n        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n        if (remaining > 0) {\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\n            await this.tokenizer.ignore(Number(remaining));\n        }\n    }\n    async handleSoundPropertyChunks(remainingSize) {\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        while (remainingSize > 0) {\n            const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n            const p0 = this.tokenizer.position;\n            switch (sndPropHeader.chunkID.trim()) {\n                case 'FS': // 3.2.1 Sample Rate Chunk\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n                    this.metadata.setFormat('sampleRate', sampleRate);\n                    break;\n                case 'CHNL': // 3.2.2 Channels Chunk\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n                    this.metadata.setFormat('numberOfChannels', numChannels);\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n                    break;\n                case 'CMPR': // 3.2.3 Compression Type Chunk\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n                    const count = await this.tokenizer.readToken(Token.UINT8);\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n                    if (compressionIdCode === 'DSD') {\n                        this.metadata.setFormat('lossless', true);\n                        this.metadata.setFormat('bitsPerSample', 1);\n                    }\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n                    break;\n                case 'ABSS': // 3.2.4 Absolute Start Time Chunk\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n                    break;\n                case 'LSCO': // 3.2.5 Loudspeaker Configuration Chunk\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n                    debug(`LSCO lsConfig=${lsConfig}`);\n                    break;\n                case 'COMT':\n                default:\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n            }\n            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n            if (remaining > 0) {\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n                await this.tokenizer.ignore(Number(remaining));\n            }\n            remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        }\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n            this.metadata.setFormat('bitrate', bitrate);\n        }\n    }\n    async handleChannelChunks(remainingSize) {\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n        const channels = [];\n        while (remainingSize >= FourCC_1.FourCcToken.len) {\n            const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n            debug(`Channel[ID=${channelId}]`);\n            channels.push(channelId);\n            remainingSize -= BigInt(FourCC_1.FourCcToken.len);\n        }\n        debug(`Channels: ${channels.join(', ')}`);\n        return channels;\n    }\n}\nexports.DsdiffParser = DsdiffParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}