{"ast":null,"code":"/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\nexport var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function (REALTIME_PRESENCE_LISTEN_EVENTS) {\n  REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n  REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n  REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nexport default class RealtimePresence {\n  /**\n   * Creates a Presence helper that keeps the local presence state in sync with the server.\n   *\n   * @param channel - The realtime channel to bind to.\n   * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.\n   *\n   * @example\n   * ```ts\n   * const presence = new RealtimePresence(channel)\n   *\n   * channel.on('presence', ({ event, key }) => {\n   *   console.log(`Presence ${event} on ${key}`)\n   * })\n   * ```\n   */\n  constructor(channel, opts) {\n    this.channel = channel;\n    this.state = {};\n    this.pendingDiffs = [];\n    this.joinRef = null;\n    this.enabled = false;\n    this.caller = {\n      onJoin: () => {},\n      onLeave: () => {},\n      onSync: () => {}\n    };\n    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n      state: 'presence_state',\n      diff: 'presence_diff'\n    };\n    this.channel._on(events.state, {}, newState => {\n      const {\n        onJoin,\n        onLeave,\n        onSync\n      } = this.caller;\n      this.joinRef = this.channel._joinRef();\n      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach(diff => {\n        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel._on(events.diff, {}, diff => {\n      const {\n        onJoin,\n        onLeave,\n        onSync\n      } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger('presence', {\n        event: 'join',\n        key,\n        currentPresences,\n        newPresences\n      });\n    });\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger('presence', {\n        event: 'leave',\n        key,\n        currentPresences,\n        leftPresences\n      });\n    });\n    this.onSync(() => {\n      this.channel._trigger('presence', {\n        event: 'sync'\n      });\n    });\n  }\n  /**\n   * Used to sync the list of presences on the server with the\n   * client's state.\n   *\n   * An optional `onJoin` and `onLeave` callback can be provided to\n   * react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @internal\n   */\n  static syncState(currentState, newState, onJoin, onLeave) {\n    const state = this.cloneDeep(currentState);\n    const transformedState = this.transformState(newState);\n    const joins = {};\n    const leaves = {};\n    this.map(state, (key, presences) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences;\n      }\n    });\n    this.map(transformedState, (key, newPresences) => {\n      const currentPresences = state[key];\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map(m => m.presence_ref);\n        const curPresenceRefs = currentPresences.map(m => m.presence_ref);\n        const joinedPresences = newPresences.filter(m => curPresenceRefs.indexOf(m.presence_ref) < 0);\n        const leftPresences = currentPresences.filter(m => newPresenceRefs.indexOf(m.presence_ref) < 0);\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences;\n        }\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences;\n        }\n      } else {\n        joins[key] = newPresences;\n      }\n    });\n    return this.syncDiff(state, {\n      joins,\n      leaves\n    }, onJoin, onLeave);\n  }\n  /**\n   * Used to sync a diff of presence join and leave events from the\n   * server, as they happen.\n   *\n   * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n   * `onLeave` callbacks to react to a user joining or leaving from a\n   * device.\n   *\n   * @internal\n   */\n  static syncDiff(state, diff, onJoin, onLeave) {\n    const {\n      joins,\n      leaves\n    } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves)\n    };\n    if (!onJoin) {\n      onJoin = () => {};\n    }\n    if (!onLeave) {\n      onLeave = () => {};\n    }\n    this.map(joins, (key, newPresences) => {\n      var _a;\n      const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n      state[key] = this.cloneDeep(newPresences);\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map(m => m.presence_ref);\n        const curPresences = currentPresences.filter(m => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n        state[key].unshift(...curPresences);\n      }\n      onJoin(key, currentPresences, newPresences);\n    });\n    this.map(leaves, (key, leftPresences) => {\n      let currentPresences = state[key];\n      if (!currentPresences) return;\n      const presenceRefsToRemove = leftPresences.map(m => m.presence_ref);\n      currentPresences = currentPresences.filter(m => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n      state[key] = currentPresences;\n      onLeave(key, currentPresences, leftPresences);\n      if (currentPresences.length === 0) delete state[key];\n    });\n    return state;\n  }\n  /** @internal */\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n  }\n  /**\n   * Remove 'metas' key\n   * Change 'phx_ref' to 'presence_ref'\n   * Remove 'phx_ref' and 'phx_ref_prev'\n   *\n   * @example\n   * // returns {\n   *  abc123: [\n   *    { presence_ref: '2', user_id: 1 },\n   *    { presence_ref: '3', user_id: 2 }\n   *  ]\n   * }\n   * RealtimePresence.transformState({\n   *  abc123: {\n   *    metas: [\n   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n   *      { phx_ref: '3', user_id: 2 }\n   *    ]\n   *  }\n   * })\n   *\n   * @internal\n   */\n  static transformState(state) {\n    state = this.cloneDeep(state);\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key];\n      if ('metas' in presences) {\n        newState[key] = presences.metas.map(presence => {\n          presence['presence_ref'] = presence['phx_ref'];\n          delete presence['phx_ref'];\n          delete presence['phx_ref_prev'];\n          return presence;\n        });\n      } else {\n        newState[key] = presences;\n      }\n      return newState;\n    }, {});\n  }\n  /** @internal */\n  static cloneDeep(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  /** @internal */\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  /** @internal */\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  /** @internal */\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  /** @internal */\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef();\n  }\n}\n//# sourceMappingURL=RealtimePresence.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}